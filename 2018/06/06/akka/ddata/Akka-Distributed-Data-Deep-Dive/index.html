<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>Akka Distributed Data Deep Dive</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">Akka Distributed Data Deep Dive</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2018-06-06</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/ddata/">ddata</a></p></div><div class="article-content"><h2 id="一致性难题"><a class="header-anchor" href="#一致性难题">¶</a>一致性难题</h2>
<p><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/CAP_theorem">CAP</a> 定理阐述了在构建分布式系统时候，<strong>Consistency(一致性)</strong>， <strong>Availability(可用性)</strong>，<strong>Partition tolerance(分区容错性)</strong>，这三者只能取二。</p>
<p>计算给我们再多的资源(常常以为可以用空间来换取时间，比如加内存，加物理机，甚至加钱)，受制于目前计算机体系(多核CPU)，理论上不可能三者都满足。</p>
<p>CAP 理论通常都会表述如下：在一致性、可用性和分区容错性这三个特性中，一个分布式系统只能够选择满足其中两个。<strong>分区容错性</strong>是我们必须要满足的，它表示如果数据被冗余备份到三个节点，那么如果其中一个节点暂时变得不可用，而另两个节点仍然能够正常运行，那么就认为系统具备分区容错性。</p>
<p>假设我们希望系统具备分区容错性，只在可用性和一致性之间进行妥协。读者可能会问为什么。在接收到一个有超时限制的请求时，如果节点不可用，我们其实就需要在两种方案之间进行选择：要么返回错误（选择一致性），要么继续，即使服务器之间可能会不一致（选择可用性）。等待的时间过长会导致该请求被抛弃，所以时间是一个重要的因素，系统必须要在上面两者中做出决定。</p>
<p>为了达到高可用，就必须满足最终一致性；为了达到最终一致性，就会牺牲可用性，数据插入后并不得到一个真实的返回。这里就出现了一致性问题，即要求强一致性时，系统非常非常慢，因为事件A的操作完成后，才能执行后续操作；若是要求最终一致性，多个节点如果没有同步副本，执行查询并不能得到希望的结果，因为我们并不知道副本什么时候同步完成。</p>
<p>现在认为，只要是最终一致性的就可以接受的范围。并且你会发现，所有力求最终一致性的分布式系统，都应该使用CRDT。</p>
<blockquote>
<p>分布式事务常见的有几种解决方案：</p>
<ul>
<li>两阶段提交（2PC）</li>
<li>补偿事务（TCC）</li>
<li>本地消息表（异步确保）</li>
<li>MQ 事务消息</li>
<li>Sagas 事务模型</li>
</ul>
<p>具体依赖于系统的实现逻辑方案来决定。这里撇开分布式事务不谈。</p>
</blockquote>
<h2 id="Conflict-Free-Replicated-Data-Types-CRDT-无冲突复制数据类型"><a class="header-anchor" href="#Conflict-Free-Replicated-Data-Types-CRDT-无冲突复制数据类型">¶</a>Conflict Free Replicated Data Types - CRDT(无冲突复制数据类型)</h2>
<p>CRDT，顾名思义就是一类数据结构。指的是副本可以被同步到各个节点上，副本(replicas)与副本之间更新不需要依赖调停器(coordination)。有两种方式实现CRDT，<code>Operation-based CRDTs</code> 和 <code>State-based CRDTs</code>，两种方式都能实现强最终一致性(strong eventual consistencey)。</p>
<p>根据Shapiro本人的论文<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>，两种实现都是等价的，都可以相互模拟。</p>
<p><strong>State-based replication</strong>: 当一个副本(replica)收到来自客户端的一个<code>Update</code>时，首先更新自己的状态，之后将自身的所有状态发送给另一个副本。间接性地，每个副本都将自己的<code>full state</code>发送给系统内的其它副本。当一个副本收到来自其它副本的状态，提供一个<code>Merge</code>函数，将自身本地的状态和接收到的状态合并。如下所示，如果集合的值的状态可以表示为一个半格(<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Semilattice">semi-lattice</a> )(半格 —— 一个偏序集，带有连续/最小上界)并且更新是递增的(譬如，状态是一个整数，更新是一个自增操作)，并且如果<code>Merge</code>函数计算最小上界，则可以确保副本已经合并了相同的值(接近最小上界)。要让系统尽可能成为一个<strong>半格</strong>，<code>Merge</code>操作必须满足等幂(idempotent)、结合律(associative)、交换律(commutative)。一个副本对象满足这些特征的CRDT，称为<strong>CvRDT(convergent replicated data type)</strong>。</p>
<p><img src="/img/akka/ddata/1_Vn9ZGiUAcxQHw27RH3bz8g.png" alt="State-based approach. “s” denotes the source replica where the initial update is applied"></p>
<p><strong>Operation-based replication</strong>: 该方式并没有将一个副本的全部状态发送给另一个副本，而是通过广播的形式将<code>Update</code>操作发送给系统的其他副本，并由它们重演更新操作(类似于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%8A%B6%E6%80%81%E6%9C%BA%E5%A4%8D%E5%88%B6">状态机复制</a> )。因为是广播操作，如果有两个更新，<em>u_1</em> 和 <em>u_2</em>，作用于副本 <em>i</em> 上，然后副本 <em>i</em> 将这两个更新发送给另外两个副本 <em>r_1</em> 和 <em>r_2</em> ，这时更新到达副本的顺序是不同的，<em>r_1_可能先收到_u_1</em>，<em>u_2</em> ，<em>r_2</em> 可能是先收到 <em>u_2</em> 然后 <em>u_1</em> 。如何进行合并？不管顺序如何，这些更新是满足交换律的，副本最后得到的状态是相同的。类似于这种广播的形式发送<code>Update</code>到所有副本，这一类对象称之为<strong>CmRDT(commutative replicated data type)</strong>。</p>
<p><img src="/img/akka/ddata/1_E-_IN_tTSiirbJ1-7XTh5w.png" alt="Operation-based approach. “s” denotes source replicas and “d” denotes the downstream replicas"></p>
<p>CRDT解决了分布式系统的一个有趣而又基本的问题，但是有一些限制。CRDT不实现一致性，只针对部分问题空间的<code>Update</code>操作的交换，而不是所有。因此并不是所有问题都可以转化为CRDT。</p>
<p>关于CRDT的研究， Shapiro论文提出了几点理论<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>：</p>
<ul>
<li>(Convergent Replicated Data Type (CvRDT)). Assuming eventual delivery and termination, any state-based object that satisfies the monotonic semilattice property is SEC.</li>
<li>(Commutative Replicated Data Type (CmRDT)). Assuming causal delivery of updates and method termination, any op-based object that satisfies the commutativity property for all concurrent updates, and whose delivery precondition is satisfied by causal delivery, is SEC.</li>
<li>(CvRDT emulation). Any SEC op-based object can be emulated by a SEC state-based object of a corresponding interface.</li>
</ul>
<h2 id="Akka集群分片"><a class="header-anchor" href="#Akka集群分片">¶</a>Akka集群分片</h2>
<p>作为抛砖引玉，这里先介绍Akka Sharding的实现方式，再来介绍Akka Distributed Data。</p>
<p>Akka Sharding也是一种分布式集群的实现<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>，集群分片主要应用于需要有大量带有状态的Actor处理大量数据的情形。因为要处理Actor的状态，所以很多例子都要求分片上的Actor都是继承了PersistenceActor。为了避免混淆，我们这里不引入PersistenceActor，单独阐述Cluster Sharding的机制。</p>
<p>由于集群分片需要实现位置透明，即<code>ShardRegion.ExtractEntityId</code>需要通过<code>EntityId</code>知会分片Actor的具体位置，从而向对应的Actor发送消息；当然你也可以不需要知会Actor的位置。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CounterClusterConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">EntityEnvelope</span>(<span class="params">entityId: <span class="type">String</span>, payload: <span class="type">Any</span></span>)</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Get</span>(<span class="params">entityId: <span class="type">String</span></span>)</span></span><br><span class="line">  <span class="keyword">val</span> numberOfShards = <span class="number">100</span> <span class="comment">// 最大分片数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> extractEntityId: <span class="type">ShardRegion</span>.<span class="type">ExtractEntityId</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">EntityEnvelope</span>(entityId, payload) =&gt; (entityId, payload)</span><br><span class="line">    <span class="keyword">case</span> msg<span class="meta">@Get</span>(entityId) =&gt; (entityId, msg)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> extractShardId: <span class="type">ShardRegion</span>.<span class="type">ExtractShardId</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">EntityEnvelope</span>(entityId, _) =&gt; (math.abs(entityId.hashCode) % numberOfShards).toString</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Get</span>(entityId) =&gt; (math.abs(entityId.hashCode) % numberOfShards).toString</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ShardRegion</span>.<span class="type">StartEntity</span>(entityId) =&gt;</span><br><span class="line">      <span class="comment">// StartEntity is used by remembering entities feature</span></span><br><span class="line">      (math.abs(entityId.hashCode) % numberOfShards).toString</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Increment</span></span></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Decrement</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Stop</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterChanged</span>(<span class="params">delta: <span class="type">Int</span></span>)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> com.lightbend.akka.np_sharding.<span class="type">Counter</span>._</span><br><span class="line">  <span class="keyword">import</span> com.lightbend.akka.np_sharding.<span class="type">CounterClusterConfig</span>.<span class="type">Get</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> scala.concurrent.duration._</span><br><span class="line"></span><br><span class="line">  context.setReceiveTimeout(<span class="number">120.</span>seconds)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> entityType: <span class="type">String</span> = getClass.getSimpleName</span><br><span class="line">  <span class="keyword">val</span> entityId  : <span class="type">String</span> = self.path.name</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">preStart</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;==&gt;1. I was created...&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">postStop</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;==&gt;4. I was stop...&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Get</span>(id) =&gt;</span><br><span class="line">      log.debug(<span class="string">s&quot;==&gt;2. <span class="subst">$id</span> established...&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> it<span class="meta">@Increment</span> =&gt;</span><br><span class="line">      log.debug(<span class="string">&quot;==&gt;3. I am increase...&quot;</span>)</span><br><span class="line">      context stop self</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ShardRegion每次收到来自客户端的消息时，如果分片中没有对应ID的Actor，则会先创建该Actor，然后发送消息；若存在该ID的Actor，则消息直接被Actor处理。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> counterRegion: <span class="type">ActorRef</span> = <span class="type">ClusterSharding</span>(system).start(</span><br><span class="line">  typeName = <span class="string">&quot;Counter&quot;</span>,</span><br><span class="line">  entityProps = <span class="type">Props</span>[<span class="type">Counter</span>],</span><br><span class="line">  settings = <span class="type">ClusterShardingSettings</span>(system),</span><br><span class="line">  extractEntityId = <span class="type">CounterClusterConfig</span>.extractEntityId,</span><br><span class="line">  extractShardId = <span class="type">CounterClusterConfig</span>.extractShardId)</span><br><span class="line"></span><br><span class="line"><span class="comment">// scheduler sender message</span></span><br><span class="line">system.scheduler.schedule(<span class="number">0.</span>second,</span><br><span class="line">  <span class="number">5.</span>seconds,</span><br><span class="line">  <span class="keyword">new</span> <span class="type">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> id = java.util.<span class="type">UUID</span>.randomUUID.toString</span><br><span class="line">      counterRegion ! <span class="type">Get</span>(id)</span><br><span class="line">      counterRegion ! <span class="type">EntityEnvelope</span>(id, <span class="type">Increment</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">sys.addShutdownHook &#123;</span><br><span class="line">  <span class="type">Await</span>.result(system.whenTerminated, <span class="type">Duration</span>.<span class="type">Inf</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分片Region类似于线程池，既然可以重复利用，为什么不创建一个监督机制。这样每个Actor都是位置透明的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterSupervisor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> counter = context.actorOf(<span class="type">Props</span>[<span class="type">Counter</span>], <span class="string">&quot;theCounter&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> supervisorStrategy = <span class="type">OneForOneStrategy</span>() &#123;</span><br><span class="line">    <span class="keyword">case</span> _: <span class="type">IllegalArgumentException</span>     ⇒ <span class="type">SupervisorStrategy</span>.<span class="type">Resume</span></span><br><span class="line">    <span class="keyword">case</span> _: <span class="type">ActorInitializationException</span> ⇒ <span class="type">SupervisorStrategy</span>.<span class="type">Stop</span></span><br><span class="line">    <span class="keyword">case</span> _: <span class="type">DeathPactException</span>           ⇒ <span class="type">SupervisorStrategy</span>.<span class="type">Stop</span></span><br><span class="line">    <span class="keyword">case</span> _: <span class="type">Exception</span>                    ⇒ <span class="type">SupervisorStrategy</span>.<span class="type">Restart</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> msg ⇒ counter forward msg</span><br><span class="line">  &#125;</span><br><span class="line">&#125;```</span><br><span class="line"></span><br><span class="line">默认地，<span class="type">Akka</span> <span class="type">Sharding</span>使用的是[<span class="type">Distributed</span> <span class="type">Data</span> <span class="type">Mode</span>](https:<span class="comment">//doc.akka.io/docs/akka/current/cluster-sharding.html?language=scala#distributed-data-vs-persistence-mode)，</span></span><br><span class="line"></span><br><span class="line">```scala</span><br><span class="line">akka.cluster.sharding.state-store-mode = ddata</span><br></pre></td></tr></table></figure>
<p>你也可以使用Persistence Mode，</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">akka.cluster.sharding.state-store-mode = persistence</span><br></pre></td></tr></table></figure>
<p>这个描述的Distributed Data Mode跟接下来的 Akka Distribted Data并不是一回事。关于更多Akka Sharding 的技术细节可以参考官网。</p>
<h2 id="Akka-Distributed-Data"><a class="header-anchor" href="#Akka-Distributed-Data">¶</a>Akka Distributed Data</h2>
<p>Akka Distributed Data 是一个用于节点间共享数据的模组。它被设计成Key-Value存储，Value实现了CRDT(Conflict Free Replicated Data Types)。它允许节点的数据可以从其它任意节点更新，二不需要经过<code>Coordinator</code>处理，CRDT的Value总是合并(converge)。</p>
<p>前面已经描述了CRDT的原理和结构，那么理解Akka Distribted Data就可以得心应手了。区别于Akka Sharding，distributed-data中的<code>Replicator</code>是API提供的，所以直接拿来用就可以了。</p>
<p>副本(Replicator)，声明如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.cluster.ddata._</span><br><span class="line"> </span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> cluster = <span class="type">Cluster</span>(context.system)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">val</span> replicator: <span class="type">ActorRef</span> = <span class="type">DistributedData</span>(context.system).replicator</span><br></pre></td></tr></table></figure>
<p>Akka Distributed Data实际上相当于Redis的Key-Value存储，并且一致性都是可调的。由于Key的特殊性，它是Value类型的编码形式。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="type">Key</span> = <span class="type">ORMapKey</span>.create[<span class="type">String</span>, <span class="type">StoredOrder</span>](<span class="string">&quot;orders&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这里的<code>Key</code>变量以大写开头，允许用<code>match</code>表达式匹配。这是Scala语言规范，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">8.1.1 Variable Patterns</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">A variable pattern x is a simple identifier which starts with a *lower case* letter. It matches any value, and binds the variable name to that value. [...]</span><br></pre></td></tr></table></figure>
<p><code>Replicator</code>实际上是一个简单的Actor，我们通过消息协议进行副本的通讯。例如要处理更新操作，让<code>Replicator</code>发送<code>Replicator.Update</code>消息，</p>
<figure class="highlight scala"><figcaption><span>Replicator</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">storeOrderValidation</span></span>(id: <span class="type">OrderIdentifier</span>, storedOrder: <span class="type">StoredOrder</span>, request: <span class="type">StoreOrderValidation</span>) = &#123; </span><br><span class="line">  replicator ! <span class="type">Replicator</span>.<span class="type">Update</span>(</span><br><span class="line">    key = <span class="type">Key</span>, <i class="conum" data-value="1"></i></span><br><span class="line">    initial = <span class="type">ORMap</span>.empty[<span class="type">String</span>, <span class="type">StoredOrder</span>], <i class="conum" data-value="2"></i></span><br><span class="line">    writeConsistency = <span class="type">Replicator</span>.<span class="type">WriteMajority</span>(<span class="number">5.</span>seconds), <i class="conum" data-value="3"></i></span><br><span class="line">    request = <span class="type">Some</span>(request) <i class="conum" data-value="4"></i></span><br><span class="line">  ) &#123; orders =&gt; <i class="conum" data-value="5"></i></span><br><span class="line">    orders + (id.i.toString -&gt; storedOrder)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><i class="conum" data-value="1"></i> 副本需要知会Key是什么<br>
<i class="conum" data-value="2"></i> 分布式数据初始化值，这里定义了Key对应的Value是空的。Data Type为<code>ORMap[String, StoredOrder]</code><br>
<i class="conum" data-value="3"></i> 写一致性，它可以是<code>WriteLocal</code>，<code>WriteTo(number of nodes)</code>，<code>WriteMajority</code>以及<code>WriteAll</code>。这里我们使用<code>WriteMajority</code>。表示立即写入N/2 + 1个节点(N是集群中节点的个数)<br>
<i class="conum" data-value="4"></i> 可选的。该对象附带更新请求一并传递。<br>
<i class="conum" data-value="5"></i> 这里是一个函数，作用于要修改的值。例如这里的数据是添加一个新的<code>StoredOrder</code>到map中。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Update</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">A</span> &lt;: <span class="type">ReplicatedData</span>](</span><br><span class="line">    key: <span class="type">Key</span>[<span class="type">A</span>], initial: <span class="type">A</span>, writeConsistency: <span class="type">WriteConsistency</span>,</span><br><span class="line">    request: <span class="type">Option</span>[<span class="type">Any</span>] = <span class="type">None</span>)(modify: <span class="type">A</span> ? <span class="type">A</span>): <span class="type">Update</span>[<span class="type">A</span>]</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>整个过程就是，<code>Update</code>消息携带的<code>Key</code>，通过<code>modify</code>函数，写入<code>Value</code>到<code>ORMap</code>中。那么接下来会出现3种情况：</p>
<ul>
<li>更新成功</li>
<li>更新全部失败</li>
<li>介于两者之间，部分更新成功</li>
</ul>
<p>如果所有都按计划执行，将返回一个<code>UpdateSuccess</code>消息，表示更新成功。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">Replicator</span>.<span class="type">UpdateSuccess</span>(<span class="type">Key</span>, <span class="type">Some</span>(request: <span class="type">StoreOrderValidation</span>)) =&gt;</span><br><span class="line">  request.replyTo ! <span class="type">OrderValidationStored</span>(request.id, request.order)</span><br></pre></td></tr></table></figure>
<p>或者更新失败，返回得到一个<code>ModifyFailure</code>。</p>
<p>最后一种情况，“我们不确定是否成功，但它确实运行了”，这时包含有<code>UpdateTimeout</code>和<code>StoreFailure</code>。</p>
<p><code>UpdateTimeout</code>的出现，取决于事先定义的一致性等级。例如这里定义的是<code>Replicator.WriteMajority(5.seconds)</code>，表示主节点在5秒的时间内没有应答。这种情况出现，可能是其它几个节点处理消息非常慢、或者网络延迟等等因素。如何处理这种情况取决于真实的案例。</p>
<p><code>StoreFailure</code>，表示本地持久化存储出现了问题。这种问题出现之前，需先额外定义是否进行本地的持久化。</p>
<p>一个非常实用的操作是，我们可以监听分布式数据的改变。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicator ! <span class="type">Replicator</span>.<span class="type">Subscribe</span>(<span class="type">OrderStorage</span>.<span class="type">Key</span>, self)</span><br></pre></td></tr></table></figure>
<p>当发生改变时，会得到一个<code>Replicator.Changed</code>消息：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> change @ <span class="type">Replicator</span>.<span class="type">Changed</span>(<span class="type">OrderStorage</span>.<span class="type">Key</span>) =&gt;</span><br><span class="line">  <span class="keyword">val</span> allOrders: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">StoredOrder</span>] = change.get(<span class="type">OrderStorage</span>.<span class="type">Key</span>).entries</span><br><span class="line">  <span class="comment">// do something with the orders</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于<strong>Update</strong>，一致性等级大概有：</p>
<ul>
<li><code>WriteLocal</code> the value will immediately only be written to the local replica, and later disseminated with gossip</li>
<li><code>WriteTo(n)</code> the value will immediately be written to at least n replicas, including the local replica</li>
<li><code>WriteMajority</code> the value will immediately be written to a majority of replicas, i.e. at least N/2 + 1 replicas, where N is the number of nodes in the cluster (or cluster role group)</li>
<li><code>WriteAll</code> the value will immediately be written to all nodes in the cluster (or all nodes in the cluster role group)</li>
</ul>
<p>对于<strong>Get</strong>，一致性等级有：</p>
<ul>
<li><code>ReadLocal</code> the value will only be read from the local replica</li>
<li><code>ReadFrom(n)</code> the value will be read and merged from n replicas, including the local replica</li>
<li><code>ReadMajority</code> the value will be read and merged from a majority of replicas, i.e. at least N/2 + 1 replicas, where N is the number of nodes in the cluster (or cluster role group)</li>
<li><code>ReadAll</code> the value will be read and merged from all nodes in the cluster (or all nodes in the cluster role group)</li>
</ul>
</blockquote>
<p>前面说过，Value的实现是一个CvRDT，它的定义为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interface for implementing a state based convergent</span></span><br><span class="line"><span class="comment"> * replicated data type (CvRDT).</span></span><br><span class="line"><span class="comment"> * [...]</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ReplicatedData</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The type of the concrete implementation, e.g. `GSet[A]`.</span></span><br><span class="line"><span class="comment">   * To be specified by subclass.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">T</span> <span class="title">&lt;</span></span>: <span class="type">ReplicatedData</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Monotonic merge function.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(that: <span class="type">T</span>): <span class="type">T</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该数据结构要求有<code>merge</code>函数，用于合并其它副本传递过来的数据。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ORMapKey</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create</span></span>[<span class="type">A</span>, <span class="type">B</span> &lt;: <span class="type">ReplicatedData</span>](id: <span class="type">String</span>): <span class="type">Key</span>[<span class="type">ORMap</span>[<span class="type">A</span>, <span class="type">B</span>]] = <span class="type">ORMapKey</span>(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该CvRDT被定义为Data Type函数的上界，以实现存储功能。</p>
<p>你会发现，<code>merge</code>函数返回一个<code>T</code> ，不是<code>Option[T]</code>也不是<code>Try[T]</code>——它证明了**<code>merge</code>总是正常的**。你会发现，<code>merge</code>函数是一个单调函数，总是向一个方向增长。</p>
<p><img src="/img/akka/ddata/monotonicity.png" alt="单调变换"></p>
<p>Akka api提供了一些基础<a target="_blank" rel="noopener" href="https://doc.akka.io/docs/akka/current/distributed-data.html?language=scala#data-types">数据类型</a>，用于实现我们的分布式数据的存储。</p>
<p>对于上面的例子，可以直接操作数据，因为它本身就是个Key-Value，下面使用分布式方案实现基于内存的存储实现。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">Actor</span></span><br><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">ActorRef</span></span><br><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">Props</span></span><br><span class="line"><span class="keyword">import</span> akka.cluster.<span class="type">Cluster</span></span><br><span class="line"><span class="keyword">import</span> akka.cluster.ddata.<span class="type">DistributedData</span></span><br><span class="line"><span class="keyword">import</span> akka.cluster.ddata.<span class="type">LWWMap</span></span><br><span class="line"><span class="keyword">import</span> akka.cluster.ddata.<span class="type">LWWMapKey</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ReplicatedCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">props</span></span>: <span class="type">Props</span> = <span class="type">Props</span>[<span class="type">ReplicatedCache</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span>(<span class="params">key: <span class="type">String</span>, replyTo: <span class="type">ActorRef</span></span>)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PutInCache</span>(<span class="params">key: <span class="type">String</span>, value: <span class="type">Any</span></span>)</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">GetFromCache</span>(<span class="params">key: <span class="type">String</span></span>)</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Cached</span>(<span class="params">key: <span class="type">String</span>, value: <span class="type">Option</span>[<span class="type">Any</span>]</span>)</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Evict</span>(<span class="params">key: <span class="type">String</span></span>)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplicatedCache</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> akka.cluster.ddata.<span class="type">Replicator</span>._</span><br><span class="line">  <span class="keyword">import</span> <span class="type">ReplicatedCache</span>._</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> replicator = <span class="type">DistributedData</span>(context.system).replicator</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> cluster = <span class="type">Cluster</span>(context.system)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dataKey</span></span>(entryKey: <span class="type">String</span>): <span class="type">LWWMapKey</span>[<span class="type">String</span>, <span class="type">Any</span>] =</span><br><span class="line">    <span class="type">LWWMapKey</span>(<span class="string">&quot;cache-&quot;</span> + math.abs(entryKey.hashCode) % <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">PutInCache</span>(key, value) =&gt;</span><br><span class="line">      replicator ! <span class="type">Update</span>(dataKey(key), <span class="type">LWWMap</span>(), <span class="type">WriteLocal</span>)(_ + (key -&gt; value))</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Evict</span>(key) =&gt;</span><br><span class="line">      replicator ! <span class="type">Update</span>(dataKey(key), <span class="type">LWWMap</span>(), <span class="type">WriteLocal</span>)(_ - key)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">GetFromCache</span>(key) =&gt;</span><br><span class="line">      replicator ! <span class="type">Get</span>(dataKey(key), <span class="type">ReadLocal</span>, <span class="type">Some</span>(<span class="type">Request</span>(key, sender())))</span><br><span class="line">    <span class="keyword">case</span> g @ <span class="type">GetSuccess</span>(<span class="type">LWWMapKey</span>(_), <span class="type">Some</span>(<span class="type">Request</span>(key, replyTo))) =&gt;</span><br><span class="line">      g.dataValue <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> data: <span class="type">LWWMap</span>[_, _] =&gt; data.asInstanceOf[<span class="type">LWWMap</span>[<span class="type">String</span>, <span class="type">Any</span>]].get(key) <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">Some</span>(value) =&gt; replyTo ! <span class="type">Cached</span>(key, <span class="type">Some</span>(value))</span><br><span class="line">          <span class="keyword">case</span> <span class="type">None</span>        =&gt; replyTo ! <span class="type">Cached</span>(key, <span class="type">None</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">NotFound</span>(_, <span class="type">Some</span>(<span class="type">Request</span>(key, replyTo))) =&gt;</span><br><span class="line">      replyTo ! <span class="type">Cached</span>(key, <span class="type">None</span>)</span><br><span class="line">    <span class="keyword">case</span> _: <span class="type">UpdateResponse</span>[_] =&gt; <span class="comment">// ok</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TDD案例：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.concurrent.duration._</span><br><span class="line"><span class="keyword">import</span> akka.cluster.<span class="type">Cluster</span></span><br><span class="line"><span class="keyword">import</span> akka.cluster.ddata.<span class="type">DistributedData</span></span><br><span class="line"><span class="keyword">import</span> akka.cluster.ddata.<span class="type">Replicator</span>.<span class="type">GetReplicaCount</span></span><br><span class="line"><span class="keyword">import</span> akka.cluster.ddata.<span class="type">Replicator</span>.<span class="type">ReplicaCount</span></span><br><span class="line"><span class="keyword">import</span> akka.remote.testconductor.<span class="type">RoleName</span></span><br><span class="line"><span class="keyword">import</span> akka.remote.testkit.<span class="type">MultiNodeConfig</span></span><br><span class="line"><span class="keyword">import</span> akka.remote.testkit.<span class="type">MultiNodeSpec</span></span><br><span class="line"><span class="keyword">import</span> akka.testkit._</span><br><span class="line"><span class="keyword">import</span> com.typesafe.config.<span class="type">ConfigFactory</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ReplicatedCacheSpec</span> <span class="keyword">extends</span> <span class="title">MultiNodeConfig</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> node1 = role(<span class="string">&quot;node-1&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> node2 = role(<span class="string">&quot;node-2&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> node3 = role(<span class="string">&quot;node-3&quot;</span>)</span><br><span class="line"></span><br><span class="line">  commonConfig(<span class="type">ConfigFactory</span>.parseString(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    akka.loglevel = INFO</span></span><br><span class="line"><span class="string">    akka.actor.provider = &quot;cluster&quot;</span></span><br><span class="line"><span class="string">    akka.log-dead-letters-during-shutdown = off</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplicatedCacheSpecMultiJvmNode1</span> <span class="keyword">extends</span> <span class="title">ReplicatedCacheSpec</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplicatedCacheSpecMultiJvmNode2</span> <span class="keyword">extends</span> <span class="title">ReplicatedCacheSpec</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplicatedCacheSpecMultiJvmNode3</span> <span class="keyword">extends</span> <span class="title">ReplicatedCacheSpec</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplicatedCacheSpec</span> <span class="keyword">extends</span> <span class="title">MultiNodeSpec</span>(<span class="params"><span class="type">ReplicatedCacheSpec</span></span>) <span class="keyword">with</span> <span class="title">STMultiNodeSpec</span> <span class="keyword">with</span> <span class="title">ImplicitSender</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">ReplicatedCacheSpec</span>._</span><br><span class="line">  <span class="keyword">import</span> <span class="type">ReplicatedCache</span>._</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">initialParticipants</span> </span>= roles.size</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> cluster = <span class="type">Cluster</span>(system)</span><br><span class="line">  <span class="keyword">val</span> replicatedCache = system.actorOf(<span class="type">ReplicatedCache</span>.props)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>(from: <span class="type">RoleName</span>, to: <span class="type">RoleName</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    runOn(from) &#123;</span><br><span class="line">      cluster join node(to).address</span><br><span class="line">    &#125;</span><br><span class="line">    enterBarrier(from.name + <span class="string">&quot;-joined&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;Demo of a replicated cache&quot;</span> must &#123;</span><br><span class="line">    <span class="string">&quot;join cluster&quot;</span> in within(<span class="number">20.</span>seconds) &#123;</span><br><span class="line">      join(node1, node1)</span><br><span class="line">      join(node2, node1)</span><br><span class="line">      join(node3, node1)</span><br><span class="line"></span><br><span class="line">      awaitAssert &#123;</span><br><span class="line">        <span class="type">DistributedData</span>(system).replicator ! <span class="type">GetReplicaCount</span></span><br><span class="line">        expectMsg(<span class="type">ReplicaCount</span>(roles.size))</span><br><span class="line">      &#125;</span><br><span class="line">      enterBarrier(<span class="string">&quot;after-1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;replicate cached entry&quot;</span> in within(<span class="number">10.</span>seconds) &#123;</span><br><span class="line">      runOn(node1) &#123;</span><br><span class="line">        replicatedCache ! <span class="type">PutInCache</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      awaitAssert &#123;</span><br><span class="line">        <span class="keyword">val</span> probe = <span class="type">TestProbe</span>()</span><br><span class="line">        replicatedCache.tell(<span class="type">GetFromCache</span>(<span class="string">&quot;key1&quot;</span>), probe.ref)</span><br><span class="line">        probe.expectMsg(<span class="type">Cached</span>(<span class="string">&quot;key1&quot;</span>, <span class="type">Some</span>(<span class="string">&quot;A&quot;</span>)))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      enterBarrier(<span class="string">&quot;after-2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;replicate many cached entries&quot;</span> in within(<span class="number">10.</span>seconds) &#123;</span><br><span class="line">      runOn(node1) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i ← <span class="number">100</span> to <span class="number">200</span>)</span><br><span class="line">          replicatedCache ! <span class="type">PutInCache</span>(<span class="string">&quot;key&quot;</span> + i, i)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      awaitAssert &#123;</span><br><span class="line">        <span class="keyword">val</span> probe = <span class="type">TestProbe</span>()</span><br><span class="line">        <span class="keyword">for</span> (i ← <span class="number">100</span> to <span class="number">200</span>) &#123;</span><br><span class="line">          replicatedCache.tell(<span class="type">GetFromCache</span>(<span class="string">&quot;key&quot;</span> + i), probe.ref)</span><br><span class="line">          probe.expectMsg(<span class="type">Cached</span>(<span class="string">&quot;key&quot;</span> + i, <span class="type">Some</span>(i)))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      enterBarrier(<span class="string">&quot;after-3&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;replicate evicted entry&quot;</span> in within(<span class="number">15.</span>seconds) &#123;</span><br><span class="line">      runOn(node1) &#123;</span><br><span class="line">        replicatedCache ! <span class="type">PutInCache</span>(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      awaitAssert &#123;</span><br><span class="line">        <span class="keyword">val</span> probe = <span class="type">TestProbe</span>()</span><br><span class="line">        replicatedCache.tell(<span class="type">GetFromCache</span>(<span class="string">&quot;key2&quot;</span>), probe.ref)</span><br><span class="line">        probe.expectMsg(<span class="type">Cached</span>(<span class="string">&quot;key2&quot;</span>, <span class="type">Some</span>(<span class="string">&quot;B&quot;</span>)))</span><br><span class="line">      &#125;</span><br><span class="line">      enterBarrier(<span class="string">&quot;key2-replicated&quot;</span>)</span><br><span class="line"></span><br><span class="line">      runOn(node3) &#123;</span><br><span class="line">        replicatedCache ! <span class="type">Evict</span>(<span class="string">&quot;key2&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      awaitAssert &#123;</span><br><span class="line">        <span class="keyword">val</span> probe = <span class="type">TestProbe</span>()</span><br><span class="line">        replicatedCache.tell(<span class="type">GetFromCache</span>(<span class="string">&quot;key2&quot;</span>), probe.ref)</span><br><span class="line">        probe.expectMsg(<span class="type">Cached</span>(<span class="string">&quot;key2&quot;</span>, <span class="type">None</span>))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      enterBarrier(<span class="string">&quot;after-4&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;replicate updated cached entry&quot;</span> in within(<span class="number">10.</span>seconds) &#123;</span><br><span class="line">      runOn(node2) &#123;</span><br><span class="line">        replicatedCache ! <span class="type">PutInCache</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;A2&quot;</span>)</span><br><span class="line">        replicatedCache ! <span class="type">PutInCache</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;A3&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      awaitAssert &#123;</span><br><span class="line">        <span class="keyword">val</span> probe = <span class="type">TestProbe</span>()</span><br><span class="line">        replicatedCache.tell(<span class="type">GetFromCache</span>(<span class="string">&quot;key1&quot;</span>), probe.ref)</span><br><span class="line">        probe.expectMsg(<span class="type">Cached</span>(<span class="string">&quot;key1&quot;</span>, <span class="type">Some</span>(<span class="string">&quot;A3&quot;</span>)))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      enterBarrier(<span class="string">&quot;after-5&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能优化"><a class="header-anchor" href="#性能优化">¶</a>性能优化</h2>
<p>如果没有做性能优化，将会是萦绕我们夜晚的致命罪孽。在生产环境，我们需要做：</p>
<ul>
<li>自定义的Data Type需要实现序列化</li>
<li>实现<code>delta-CRDTs</code>避免更新发送<code>full state</code></li>
<li>删除完成的记录</li>
</ul>
<p>序列化是性能优化的关键，Java自身的序列方案并不是最优的。建议使用<code>kryo</code>或谷歌的<code>protobuf</code></p>
<p>delta-CRDT主要用于减少<code>full state Update</code>的发送，它表示以一定的顺序传播更新。</p>
<p>因为是冲突自由(Conflict Free)的，在使用诸如<code>ORMap</code>时，如果并发地添加和删除一个条目，添加会获胜。你不能删除一个不存在的条目。这会引入一个问题，例如某个节点删除订单的同时，另外一个节点添加订单，添加订单被执行。原来的订单没有删除，所以需要额外修剪未移除的已经“完成”的条目。</p>
<p>总结，在副本同步操作时，有些方面并不完全正确的：</p>
<ul>
<li>对于<code>OrderHandler</code>是没有副本机制的——如果某个节点故障，所有当前处理的<code>Update</code>消息将停留在地域边缘，客户端也不会有任何响应。</li>
<li>不要将东西持久化存储！现实中这是相当疯狂的事情！(设想副本在不断地写入、不断地更新同步)</li>
</ul>
<div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a target="_blank" rel="noopener" href="https://medium.com/@istanbul_techie/a-look-at-conflict-free-replicated-data-types-crdt-221a5f629e7e">https://medium.com/@istanbul_techie/a-look-at-conflict-free-replicated-data-types-crdt-221a5f629e7e</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a target="_blank" rel="noopener" href="https://hal.inria.fr/inria-00609399v1">https://hal.inria.fr/inria-00609399v1</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a target="_blank" rel="noopener" href="https://hal.inria.fr/inria-00609399v1/document">https://hal.inria.fr/inria-00609399v1/document</a><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><a target="_blank" rel="noopener" href="https://doc.akka.io/docs/akka/current/cluster-sharding.html?language=scala">https://doc.akka.io/docs/akka/current/cluster-sharding.html</a><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div></div></article><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2018/06/06/akka/ddata/Akka-Distributed-Data-Deep-Dive/';
var disqus_title = 'Akka Distributed Data Deep Dive';
var disqus_url = 'https://galudisu.info/2018/06/06/akka/ddata/Akka-Distributed-Data-Deep-Dive/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>