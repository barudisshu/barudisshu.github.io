<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>类，对象，接口</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">类，对象，接口</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2021-08-23</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/kotlin/">kotlin</a></p></div><div class="article-content"><h2 id="主要内容"><a class="header-anchor" href="#主要内容">¶</a>主要内容</h2>
<ol>
<li>类和接口</li>
<li>有用的属性和构造器</li>
<li>data class</li>
<li>类传递</li>
<li>使用<code>object</code>关键字</li>
</ol>
<h2 id="Defining-class-hierarchies"><a class="header-anchor" href="#Defining-class-hierarchies">¶</a>Defining class hierarchies</h2>
<p>本小节对比Java讨论Kotlin的类层级设计。并介绍新的修改器<code>sealed</code>。</p>
<h3 id="Interfaces-in-Kotlin"><a class="header-anchor" href="#Interfaces-in-Kotlin">¶</a>Interfaces in Kotlin</h3>
<p>Kotlin的接口类似Java8：包含抽象方法的定义，以及非抽象方法的定义(Java8中接口的<code>default</code>方法)，但不能包含任何状态。</p>
<p>Kotlin中的接口使用<code>interface</code>关键定义。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Clickable</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法声明部分为抽象方法，这为<code>click</code>。继承自接口的所有非抽象类都需要提供接口抽象方法的实现。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span>: <span class="type">Clickable</span> &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> = println(<span class="string">&quot;I was clicked&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; Button().click()</span><br><span class="line">I was clicked</span><br></pre></td></tr></table></figure>
<p>Kotlin使用冒号(:)后跟接口的方式来代替Java中<code>extends</code>和<code>implements</code>关键字的写法形式。Java中，接口可以多重实现(implements)，但类仅能<code>extends</code>一个父类，这是面向对象设计的多重继承的“菱形问题”，可以搜索Scala是如何解决“菱形问题”问题的。</p>
<p>Kotlin中对Java语法重写后，对于很多包含注解的部分，尽量变成了使用关键字代替，毕竟在当代编程语言中，“注解”被诟病太多。</p>
<p><code>override</code>修改器，对应于Java中的<code>@Override</code>注解，用于标注方法和属性重载于父类或接口。和Java不同的是，<code>using the override modifier is mandatory</code>，所以如果不写<code>override</code>关键字会导致编译器报错。</p>
<p>接口可以包含默认的实现。和Java8不同的是，接口的默认方法需要带<code>default</code>关键字，Kotlin不需要任何标注：仅需要提供一个方法体。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Clickable</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">showOff</span><span class="params">()</span></span> = println(<span class="string">&quot;I&#x27;m clickable!&quot;</span>)  <span class="comment">// 带默认实现的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果实现该接口，需要提供对<code>click</code>的实现即可， 或者重写<code>showOff</code>方法，或者保留默认不写。</p>
<p>假设现在有另一个接口定义了<code>showOff</code>方法的实现如下部分：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Focusable</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">setFocus</span><span class="params">(b: <span class="type">Boolean</span>)</span></span> = </span><br><span class="line">	println(<span class="string">&quot;I <span class="subst">$&#123;if (b) <span class="string">&quot;got&quot;</span> else <span class="string">&quot;lost&quot;</span>)&#125;</span> focus.&quot;</span>)</span><br><span class="line">	</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">showOff</span><span class="params">()</span></span> = println(<span class="string">&quot;I&#x27;m focusable!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要同时继承这两个接口会怎样？并且它们都包含了<code>default</code>实现；最终选哪个？最终谁都不选，实际上同时继承这两个接口会得到一个显式的编译错误：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The <span class="keyword">class</span> <span class="string">&#x27;Button&#x27;</span> must</span><br><span class="line"><span class="keyword">override</span> <span class="keyword">public</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">showOff</span><span class="params">()</span></span> because it inherits</span><br><span class="line">many implementations of it.</span><br></pre></td></tr></table></figure>
<p>Kotlin编译器会强制你对这种特定的方法要在具体类内实现，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span>: <span class="type">Clickable</span>, <span class="type">Fucusable</span> &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> = println(<span class="string">&quot;I was clicked&quot;</span>)</span><br><span class="line">  <span class="comment">// 当超过一个接口继承拥有相同的方法签名的`default`实现时，子类必须要显示声明默认实现</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">showOff</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Kotlin提供一种选择机制，提供`super&lt;&gt;`的形式来选择最终调用哪个接口方法</span></span><br><span class="line">	<span class="keyword">super</span>&lt;Clickable&gt;.showOff()</span><br><span class="line">	<span class="keyword">super</span>&lt;Focusable&gt;.showOff()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，你只需要调用其中一个继承的实现即可，写为：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">showOff</span><span class="params">()</span></span> = <span class="keyword">super</span>&lt;Clickable&gt;.showOff()</span><br></pre></td></tr></table></figure>
<p>下面是具体的main方法实现：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> button = Button()</span><br><span class="line">  button.showOff()</span><br><span class="line">  button.setFocus(<span class="literal">true</span>)</span><br><span class="line">  button.click()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>NOTE</strong>：相对于Scala的多重继承问题，Scala采用<code>with</code>关键字的深度优先的便利方法。也就是说，最后一个接口的方法将被采用。</p>
<p>Scala写法如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">Clickable</span> <span class="keyword">with</span> <span class="title">Fucusable</span></span></span><br></pre></td></tr></table></figure>
<p>根据深度遍历机制，最终只会调用<code>Fucusable</code> 特质的<code>showOff</code>方法。</p>
<p>Scala 3 的写法与Kotlin类似。</p>
</blockquote>
<blockquote>
<p><strong>Implementing interfaces with method bodies in Java</strong></p>
<p>Kotlin 1.0 开始被设计面向Java6，接口不支持<code>default</code>方法。因此，它融合了每个接口的<code>default</code>方法和常规接口方法，以及一个类包含方法体的静态方法。基于此，如果你需要在Java类实现这样一个接口，你必须定义对应于Kotlin方法体内的所有方法实现。</p>
</blockquote>
<p>下面看看如何重载基础类内定义成员。</p>
<h3 id="Open-final-and-abstract-modifiers-final-by-default"><a class="header-anchor" href="#Open-final-and-abstract-modifiers-final-by-default">¶</a>Open, final, and abstract modifiers: final by default</h3>
<p>如你所认知，Java允许你创建任何类的子类，以及重载任何方法，除非它被显式标记了<code>final</code>关键字。通常这很实用，也是问题所在。</p>
<p>所谓的 <strong>脆弱基类(fragile base class)</strong> 问题发生在：一个基类的修改会引起子类不正确的行为，因为基类的代表改变后不在适配子类的设定。如果子类不提供额外的规则(譬如重载方法)，子类的方法重载会给基类的实现带来风险。因为编写基类的作者不可能分析所有的子类，基类的“脆弱(fragile)”由此而来。</p>
<p>为了规避这类问题，Java编程的著名书籍 <strong>Effective Java</strong> 的作者Joshua Boch(Addison-Wesley, 2008)，推荐你“design and document for inheritance or else prohibit it.” 大意就是所有类和方法没有指定要从基类进行重载的，都应该显式地标记上<code>final</code>。</p>
<p>Kotlin遵循同样的哲学(philosophy)。然而Java的类或方法默认是<code>open</code>的，Kotlin默认则是<code>final</code>。</p>
<p>如果你希望子类的创建，你需要用<code>open</code>修改器标记。额外地，你需要给需要被重载的属性或方法添加<code>open</code>修改器。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">RichButton</span>: <span class="type">Clickable</span> &#123;  <span class="comment">// 此类是open的：可以继承</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">disable</span><span class="params">()</span></span> &#123;&#125;  <span class="comment">// 函数是final的：不可以在子类重载</span></span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">animate</span><span class="params">()</span></span> &#123;&#125;  <span class="comment">// 函数是open的：可以在子类进行重载</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> &#123;&#125;  <span class="comment">// 该函数重载了一个open函数，并且自身保持open</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果你重载了基类或接口的成员，重载的成员默认变为了<code>open</code>。所以，如果你想要子类的override实现不被修改，需要显式地标记上<code>final</code>。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">RichButton</span>: <span class="type">Clickable</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> &#123;&#125;  <span class="comment">// final在这里不是多余的，因为默认override的成员为open</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Open classes and smart casts</strong></p>
<p>类默认为<code>final</code>的重大益处在于在大多数情况下可以智能转换。前面的章节描述到只有变量能够智能转换，因为它的类型不会改变。但对于一个类，以为着智能转换仅可被用于一个类属性(property)作为一个<code>val</code>不包含自定义accessor的情况。这种要求意味着属性必须是<code>final</code>的，否则子类可以重载它的属性并自定义accessor，打破了智能转换的关键要求。因为属性是默认<code>final</code>修饰的，你可以对大部分属性进行智能转换。</p>
</blockquote>
<p>在Kotlin中，和Java一样可以声明一个类为<code>abstract</code>的，该类不能被实例化。以及一个抽象类通常包含抽象成员，必须由子类重载。抽象成员总是open的，所以不需要显式地指定<code>open</code>修改器。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animated</span> &#123;  <span class="comment">// 该类是abstract的：不能创建它的一个实例</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">animate</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">stopAnimating</span><span class="params">()</span></span> &#123;&#125;  <span class="comment">// 抽象类中的抽象函数默认仍是`final`的，如有必要需要使用</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">animateTwice</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下表列出了Kotlin的访问 <em>修改器(access modifiers)</em>。接口总是<code>open</code>的，所以接口不会用到<code>final</code>、<code>open</code>或<code>abstract</code>这些关键字。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Modifier</th>
<th style="text-align:left">Corresponding member</th>
<th style="text-align:left">Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>final</code></td>
<td style="text-align:left">Can’t be overridden</td>
<td style="text-align:left">Used by default for class members</td>
</tr>
<tr>
<td style="text-align:left"><code>open</code></td>
<td style="text-align:left">Can be overridden</td>
<td style="text-align:left">Should be specified explicitly</td>
</tr>
<tr>
<td style="text-align:left"><code>abstract</code></td>
<td style="text-align:left">Must be overridden</td>
<td style="text-align:left">Can be used only in abstract classes; abstract members can’t have an implementation</td>
</tr>
<tr>
<td style="text-align:left"><code>override</code></td>
<td style="text-align:left">Overrides a member in a superclass or interface</td>
<td style="text-align:left">Overridden member is open by default, if not marked <code>final</code></td>
</tr>
</tbody>
</table>
<h3 id="Visibility-modifiers-public-by-default"><a class="header-anchor" href="#Visibility-modifiers-public-by-default">¶</a>Visibility modifiers: public by default</h3>
<p>可见性修改器控制了声明的访问。严格控制一个类的实现的可见性，可以确保对其的修改不会打破其它类的依赖风险。</p>
<p>基本上，Kotlin的可见性修改器类似于Java。包含有<code>public</code>、<code>protected</code>和<code>private</code>。但默认的修改器不同：如果省略可见性修改器，Kotlin默认是<code>public</code>的。</p>
<p>Java的默认可见性是<code>package-private</code>的，这个在Kotlin中不存在。Kotlin的包的作用仅仅用于组织代码的命名空间；所以不用它做可见性控制。</p>
<p>作为替代，Kotlin提供了一个新的可见性修改器，<code>internal</code>，表示“visible inside a module”。<strong>module</strong> 的概念指Kotlin编译文件的集合。它可能是一个IntelliJ IDEA模块，一个Eclipse工程，Maven或Gradle工程，或一系列Ant调用的编译任务。</p>
<p><code>internal</code>可见性的优势在于提供了对模块的真实实现的封装。对于Java，模块的封装是很容易被打破的，因为外部的类只需要使用一个同名的包通过继承的方式就可以修改<code>package-private</code>的声明了。</p>
<p>Kotlin可见性的另外一点不同在于，对于top-level的声明总是<code>private</code>的，不管是类、函数还是属性。这种声明的可见性作用于它所在的文件。这种方式可以用于隐藏实现细节。下面是可见性修改器列表。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Modifier</th>
<th style="text-align:left">Class member</th>
<th style="text-align:left">Top-level declaration</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>public(default)</code></td>
<td style="text-align:left">Visible everywhere</td>
<td style="text-align:left">Visible everywhere</td>
</tr>
<tr>
<td style="text-align:left"><code>internal</code></td>
<td style="text-align:left">Visible in a module</td>
<td style="text-align:left">Visible in a module</td>
</tr>
<tr>
<td style="text-align:left"><code>protected</code></td>
<td style="text-align:left">Visible in subclasses</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>private</code></td>
<td style="text-align:left">Visible in a class</td>
<td style="text-align:left">Visible in a file</td>
</tr>
</tbody>
</table>
<p>下面例子中。函数<code>giveSpeech</code>函数的每行都尝试违反可见性规则。会导致编译错误：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">TalkativeButton</span>: <span class="type">Focusable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">yell</span><span class="params">()</span></span> = println(<span class="string">&quot;Hey!&quot;</span>)</span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">whisper</span><span class="params">()</span></span> = println(<span class="string">&quot;Let&#x27;s talk!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> TalkativeButton.<span class="title">giveSpeech</span><span class="params">()</span></span> &#123; <span class="comment">// Error: &quot;public&quot; member exposes its &quot;internal&quot; receiver type TalkativeButton</span></span><br><span class="line">  yell()  <span class="comment">// Error: cannot access &quot;yell&quot;: it is &quot;private&quot; in &quot;TalkativeButton&quot;</span></span><br><span class="line">  whisper()  <span class="comment">// Error: cannot access &quot;whisper&quot;: it is &quot;protected&quot; in &quot;TalkativeButton&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kotlin禁止你引用less-visible类型<code>TalkativeButton</code>。因为<code>internal</code>是模块可见的，只能在模块内访问，以及内部成员的声明不可见；要解决这类问题，要么将扩展函数(extension function)修改问<code>internal</code>的，要么去掉<code>internal open</code>使其是<code>public</code>的。</p>
<p>值得注意的是，Kotlin的<code>protected</code>行为和Java有些许差别。在Java中，你可以在同一个包访问<code>protected</code>声明，但Kotlin不允许这样。在Kotlin中，<code>protected</code>的声明仅仅在自身或子类可见。所以一个类的扩展函数无法访问<code>private</code>或<code>protected</code>的声明成员。</p>
<blockquote>
<p><strong>Kotlin’s visibility modifiers and Java</strong></p>
<p>Kotlin中的关键字<code>public</code>、<code>protected</code>和<code>private</code>是编译为Java字节码的保留字。你可以使用这些Kotlin声明为Java对应的可见性实现。唯一例外的是<code>private</code>类：在底层它会被编译为<code>package-private</code>的声明(因为Java没有<code>private</code>类这种用法)。</p>
<p>但对于<code>internal</code>修改器呢？Java中并没有与之对应的。包私有可见性是一个完全不同的东西：Kotlin中的模块通常包含好几个包，不同模块又包含同一个包的声明。这样一个<code>internal</code>实际上对应了字节码的<code>public</code>。</p>
<p>实际上，编译后的<code>internal</code>的成员在类中是被损坏的(mangled)。技术层面上，你可以在Java中调用Kotlin的<code>internal</code>成员，但代码看起来非常丑陋。</p>
</blockquote>
<p>另外一个不同之处在于Kotlin的外部类看不到它内部(或者说内嵌)类的成员。</p>
<h3 id="Inner-and-nested-classes-nested-by-default"><a class="header-anchor" href="#Inner-and-nested-classes-nested-by-default">¶</a>Inner and nested classes: nested by default</h3>
<p>和Java一样，在Kotlin中你可以在一个类内声明另外一个类。这样做通常用于封装helper型对的类或放置无关紧要的代码在更容易找到的地方。但不同的是Kotlin的内嵌类不能被外部类实例访问，除非你指定要这样做。下面是一个例子。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">State</span>: <span class="type">Serializable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">View</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getCurrentState</span><span class="params">()</span></span>: State</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">restoreState</span><span class="params">(state: <span class="type">State</span>)</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应Java版的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Button</span> <span class="keyword">implements</span> <span class="title class_">View</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> State <span class="title function_">getCurrentState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ButtonState</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreState</span><span class="params">(State state)</span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ButtonState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的问题在于，你会得到一个<code>java.io.NotSerializableException: Button</code>。Button不能被序列化：<code>Button</code>没有序列化，但它对<code>ButtonState</code>的引用会打破序列化。</p>
<p>为了修复该问题，你需要声明<code>ButtonState</code>为<code>static</code>的。但在Kotlin中，这种行为是正向的。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span>: <span class="type">View</span> &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCurrentState</span><span class="params">()</span></span>: State = ButtonState()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">restoreState</span><span class="params">(state: <span class="type">State</span>)</span></span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ButtonState</span>: <span class="type">State</span> &#123;&#125; <span class="comment">// 该类是Java静态内嵌类的复刻版</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于Kotlin中不再包含有<code>static</code>和<code>new</code>这类关键字，不需要显式声明为<code>static</code>内嵌类。如果需要允许外部类引用它的内嵌类，需要显式使用<code>inner</code>修改器指定。</p>
<p>下表描述了Java和Kotlin内嵌类的不同之处。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Class A declared within another class B</th>
<th style="text-align:left">in Java</th>
<th style="text-align:left">in Kotlin</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Nested class (does’t store a reference to an outer class)</td>
<td style="text-align:left">static class A</td>
<td style="text-align:left">class A</td>
</tr>
<tr>
<td style="text-align:left">inner class (stores a reference to an outer class)</td>
<td style="text-align:left">class A</td>
<td style="text-align:left">inner class A</td>
</tr>
</tbody>
</table>
<p><img src="/img/kotlin-in-action/chapter04/Figure_04_01.png" alt="Figure 4.1"></p>
<p>内嵌类(inner class)引用外部类(outer class)的方式也与Java不同。你需要通过<code>this@Outer</code>来访问<code>Outer</code>类。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">  <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getOuterReference</span><span class="params">()</span></span>: Outer = <span class="keyword">this</span><span class="symbol">@Outer</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Sealed-classes-defining-restricted-class-hierarchies"><a class="header-anchor" href="#Sealed-classes-defining-restricted-class-hierarchies">¶</a>Sealed classes: defining restricted class hierarchies</h3>
<p>沿用前面的例子：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Expr</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Num</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>): Expr</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sum</span>(<span class="keyword">val</span> left: Expr, <span class="keyword">val</span> right: Expr): Expr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> = </span><br><span class="line">  <span class="keyword">when</span> (e) &#123;</span><br><span class="line">    <span class="keyword">is</span> Num -&gt; e.value</span><br><span class="line">	<span class="keyword">is</span> Sum -&gt; eval(e.right) + eval(e.left)</span><br><span class="line">	<span class="keyword">else</span> -&gt;  <span class="comment">// You have to check the &quot;else&quot; branch.</span></span><br><span class="line">	  <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Unknown expression&quot;</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>当你使用<code>when</code>结构，Kotlin编译器强制你检查默认值。</p>
<p>总是要处理默认分支并不算方便。另外，当你添加新的子类时，编译器并不能探测到改变。如果你往家添加新的分支，默认分支会被选择，这可能会导致难以捉摸的bug。</p>
<p>Kotlin提供了一种解决方案：<code>sealed</code>类。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Expr</span> &#123;  <span class="comment">// Mark a base class as sealed...</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Num</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>): Expr()</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Sum</span>(<span class="keyword">val</span> left: Expr, <span class="keyword">val</span> right: Expr): Expr()  <span class="comment">// ...and list all the possible subclasses as nested classes.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> = </span><br><span class="line">  <span class="keyword">when</span> (e) &#123; The <span class="string">&quot;when&quot;</span> expression covers all possible cases, so no <span class="string">&quot;else&quot;</span> branch <span class="keyword">is</span> needed.</span><br><span class="line">    <span class="keyword">is</span> Expr.Num -&gt; e.value</span><br><span class="line">	<span class="keyword">is</span> Expr.Sum -&gt; eval(e.right) + eval(e.left)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>当你使用<code>when</code>表达式处理<code>sealed</code>类内的所有子类时，你不需要提供默认分支。注意到<code>sealed</code>修改了暗含了类是<code>open</code>的；你不需要再显式添加。</p>
<p><code>sealed</code>类的行为如下图：</p>
<p><img src="/img/kotlin-in-action/chapter04/Figure_04_02.png" alt="Figure 4.2"></p>
<p>当你在<code>sealed</code>类中使用<code>when</code>并添加一个新的子类时，<code>when</code>表达式会返回一个值错误，表示代码必须更改。</p>
<p>在底层，<code>Expr</code>类有一个<code>private</code>构造器，它仅能在类内部调用。你不能声明一个<code>sealed</code>接口，为什么？如果可以，Kotlin编译器不能保证接口在Java代码的实现。</p>
<p>对于接口的继承使用冒号的形式：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Num</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>): Expr()</span><br></pre></td></tr></table></figure>
<h2 id="Declaring-a-class-with-nontrivial-constructors-or-properties"><a class="header-anchor" href="#Declaring-a-class-with-nontrivial-constructors-or-properties">¶</a>Declaring a class with nontrivial constructors or properties</h2>
<p>Ktolin 对于构造器和属性的初始化使用了一种<code>initializer</code>块的形式。</p>
<h3 id="Initializing-classes-primary-constructor-and-initializer-blocks"><a class="header-anchor" href="#Initializing-classes-primary-constructor-and-initializer-blocks">¶</a>Initializing classes: primary constructor and initializer blocks</h3>
<p>一般地，带参数的类声明部分称为 <strong>第一构造器(primary constructor)</strong>。它有两个作用：指定构造器的参数并初始化定义参数属性。让我们解包看看它的显式代码写的是什么：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">constructor</span>(_nickname: String) &#123;  <span class="comment">// 带参数的第一构造器</span></span><br><span class="line">  <span class="keyword">val</span> nickname: String</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">init</span> &#123;  <span class="comment">// initializer block</span></span><br><span class="line">    nickname = _nickname</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的例子有两个Kotlin关键字：<code>constructor</code>和<code>init</code>。<code>constructo</code>关键字开始于第一构造器或第二构造器。<code>init</code>关键字引入了<code>initializer</code>块。该块内的代码会在类被创建后执行初始化，并被确定为第一构造器一起使用。因为第一构造器包含约束语法，它自己不包含代码的初始化；如有必要，你可以在同一个类声明几个初始化块。</p>
<p>构造器参数<code>_nickname</code>的下划线部分是用于区分属性名和构造器参数名。你可以使用<code>this</code>关键字来规避使用下划线，和Java的写法类似：<code>this.nickname = nickname</code>。</p>
<p>实际上，构造器<code>constructor</code>关键字开始可以省略的，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(_nickname: String) &#123;  <span class="comment">// Primary constructor with one parameter</span></span><br><span class="line">  <span class="keyword">val</span> nickname = _nickname  <span class="comment">// The property is initialized with the parameter.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最直接的方式是使用<code>val</code>关键字来声明属性定义：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> nickname: String)  <span class="comment">// &quot;val&quot; means the corresponding proerty is generated for the constructor parameter.</span></span><br></pre></td></tr></table></figure>
<p>你可以定义默认的构造参数属性值：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> nickname: String, <span class="keyword">val</span> isSubscribed: <span class="built_in">Boolean</span> = <span class="literal">true</span>)  <span class="comment">// Provides a default value for the constructor parameter</span></span><br></pre></td></tr></table></figure>
<p>如果子类需要继承，子类需要显式初始化父类构造器参数：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> nickname: String) &#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TwitterUser</span>(nickname: String): User(nickname) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>如果不声明任何构造器，会生成一个默认构造器：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Button</span>  // <span class="title">The</span> <span class="title">default</span> <span class="keyword">constructor</span> <span class="title">without</span> <span class="title">arguments</span> <span class="title">is</span> <span class="title">generated</span>.</span><br></pre></td></tr></table></figure>
<p>带有默认构造器的子类需要显式调用，即使它没有任何构造器参数：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RadioButton</span>: <span class="type">Button</span>()</span><br></pre></td></tr></table></figure>
<p>如果你希望子类不要作任何初始化，使用声明为<code>private</code>的。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Secretive</span> <span class="keyword">private</span> <span class="keyword">constructor</span>() &#123;&#125;  <span class="comment">// 该类有一个private constructor.</span></span><br></pre></td></tr></table></figure>
<h3 id="Secondary-constructors-initializing-the-superclass-in-different-ways"><a class="header-anchor" href="#Secondary-constructors-initializing-the-superclass-in-different-ways">¶</a>Secondary constructors: initializing the superclass in different ways</h3>
<p>通常Kotlin中不会有多个构造器的惯例。相比Java来说构造器的重载在Kotlin中用默认参数代替了。但仍然会有多个构造器的需求。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">View</span> &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(ctx: Context) &#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constructor</span>(ctx: Context, attr: AttributeSet) &#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该类没有声明第一构造器，而是声明了两个 <strong>第二构造器(secondary constructor)</strong>。第二构造器的引入使用<code>constructor</code>关键字。</p>
<p>如果需要扩展该类，你需要声明同样的构造器：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyButton</span>: <span class="type">View</span> &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(ctx: Context): <span class="keyword">super</span>(ctx) &#123; ... &#125;</span><br><span class="line">  <span class="keyword">constructor</span>(ctx: Context, attr: AttributeSet): <span class="keyword">super</span>(ctx, attr) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图是子类构造器的传递性。</p>
<p><img src="/img/kotlin-in-action/chapter04/Figure_04_03.png" alt="Figure 4.3"></p>
<p>和Java一样，你也可以在自己的类中调用其它构造器，使用<code>this()</code>关键字。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyButton</span>: <span class="type">View</span> &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(ctx: Context): <span class="keyword">this</span>(ctx,MY_STYLE) &#123; ... &#125;</span><br><span class="line">  <span class="keyword">constructor</span>(ctx: Context, attr: AttributeSet): <span class="keyword">super</span>(ctx, attr) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>this()</code>调用的是本类，<code>super()</code>调用的是父类。</p>
<p><img src="/img/kotlin-in-action/chapter04/Figure_04_04.png" alt="Figure 4.4"></p>
<h3 id="Implementing-properties-declared-in-interfaces"><a class="header-anchor" href="#Implementing-properties-declared-in-interfaces">¶</a>Implementing properties declared in interfaces</h3>
<p>在Kotlin中，接口可以包含有抽象户型的定义。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">val</span> nickname: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着该接口的子类需要包含有<code>nickname</code>的属性定义。以及接口只包含定义不包含值，不会存储任何属性值。</p>
<p>下面是实现接口属性，和自定义getter的对比。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrivateUser</span>(<span class="keyword">override</span> <span class="keyword">val</span> nickname: String): User <span class="comment">// primary constructor property</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubscribingUser</span>(<span class="keyword">val</span> email: String): User &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> nickname: String</span><br><span class="line">    <span class="keyword">get</span>() = email.substringBefore(<span class="string">&#x27;@&#x27;</span>) )  <span class="comment">// Custom getter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FacebookUser</span>(<span class="keyword">val</span> accountId: <span class="built_in">Int</span>): User &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> nickname = getFacebookName(accountId)  <span class="comment">// Property initializer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(PrivateUser(<span class="string">&quot;test@kotlinlang.org&quot;</span>).nickname)</span><br><span class="line"><span class="symbol">test@</span>kotlinlang.org</span><br><span class="line">&gt;&gt;&gt; println(SubscribingUser(<span class="string">&quot;test@kotlinlang.org&quot;</span>).nickname)</span><br><span class="line">test</span><br></pre></td></tr></table></figure>
<h3 id="Accessing-a-backing-field-from-a-getter-or-setter"><a class="header-anchor" href="#Accessing-a-backing-field-from-a-getter-or-setter">¶</a>Accessing a backing field from a getter or setter</h3>
<p>目前有两类属性：存值属性、访问器属性。下面例子将两种属性组合起来使用，将一个属性存储为值，访问或修改是添加额外计算逻辑。</p>
<p>下面定义一个可变属性并在setter access部分执行额外的代码。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">  <span class="keyword">var</span> address: String = <span class="string">&quot;unspecified&quot;</span></span><br><span class="line">    <span class="keyword">set</span>(value: String) &#123;</span><br><span class="line">	  println(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	     Address was changed for <span class="variable">$name</span>:</span></span><br><span class="line"><span class="string">		 &quot;<span class="variable">$field</span>&quot; -&gt; &quot;<span class="variable">$value</span>&quot;.&quot;&quot;&quot;</span>.trimIndent())  <span class="comment">// Reads the backing field value</span></span><br><span class="line">	  field = value  <span class="comment">// Updates the backing field value</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> user = User(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; user.address = <span class="string">&quot;Elsenheimerstrasse 47, 80687 Muenchen&quot;</span></span><br><span class="line">Address was changed <span class="keyword">for</span> Alice:</span><br><span class="line"><span class="string">&quot;unspecified&quot;</span> -&gt; <span class="string">&quot;Elsenheimerstrasse 47, 80687 Muenchen&quot;</span>.</span><br></pre></td></tr></table></figure>
<p>你可以通过底层的setter由表达式<code>user.address = &quot;new value&quot;</code>修改属性。这里的setter被重新定义了，额外的逻辑将被执行。</p>
<p>在setter的body部分，你使用了特定的标识符 <code>field</code> 来访问它的字段。在一个getter中，仅可以读；而在setter中，即可以读也可以写。</p>
<p>注意，你仅能重定义可变属性的一个accessor。示例中的getter是琐碎的、它是个read only字段值，不需要redefine。</p>
<p>默认地，属性的getter和setter部分由编译器生成，不需要显式定义。如果提供自定义的accessor，必须使用<code>field</code>关键修饰才生效。</p>
<h3 id="Changing-accessor-visibility"><a class="header-anchor" href="#Changing-accessor-visibility">¶</a>Changing accessor visibility</h3>
<p>accessor的可见性默认等同于property所定义的可见性。但可以修改。只需要在<code>get</code>或<code>set</code>关键字前面使用可见性修改器(visibility modifier)修饰即可。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LengthCounter</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> counter: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">set</span>  <span class="comment">// You can&#x27;t change this proerty outside of the class.</span></span><br><span class="line">	</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">addWord</span><span class="params">(word: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    counter += word.length</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>属性部分的修改器为<code>public</code>。为了不要其它类修改属性值<code>counter</code>，将其更改为<code>private</code>。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> lengthCounter= LengthCounter()</span><br><span class="line">&gt;&gt;&gt; lengthCounter.addWord(<span class="string">&quot;Hi!&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; println(lengthCounter.counter)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>More about properties later</strong></p>
<ul>
<li><code>lateinit</code> 作用于一个non-null property，表示该属性在constructor调用后才被初始化。</li>
<li><code>Lazy initialized properties</code></li>
<li><code>@JvmField</code> 注解</li>
<li><code>const</code></li>
</ul>
</blockquote>
<h2 id="Compiler-generated-methods-data-classes-and-class-delegation"><a class="header-anchor" href="#Compiler-generated-methods-data-classes-and-class-delegation">¶</a>Compiler-generated methods: data classes and class delegation</h2>
<h3 id="Universal-object-methods"><a class="header-anchor" href="#Universal-object-methods">¶</a>Universal object methods</h3>
<p>Universal object methods 指的是<code>toString</code>、<code>equals</code> 和 <code>hashCode</code>。通常用于debug。下面是重写的示例：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> postalCode: <span class="built_in">Int</span>) &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;  <span class="comment">// &quot;Any&quot; is the analogue of java.lang.Object: a superclass of all classes in Kotlin. The nullable type &quot;Any?&quot; means &quot;ther&quot; can be null.</span></span><br><span class="line">    <span class="keyword">if</span> (other == <span class="literal">null</span> || other !<span class="keyword">is</span> Client)  <span class="comment">// Checks whether &quot;other&quot; is a Client</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> name == other.name &amp;&amp; postalCode == other.postalCode  <span class="comment">// Checks whether the corresponding properties are equal</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="string">&quot;Client(name=<span class="variable">$name</span>, postalCode=<span class="variable">$postalCode</span>)&quot;</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span>: <span class="built_in">Int</span> = name.hashCode() * <span class="number">31</span> + postalCode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>== for equality</strong></p>
<p>在Java中，你可以使用<code>==</code>来比较原生类型和引用类型。当作用于原生类型时，Java的<code>==</code>比较值；当作用于引用类型时则比较引用类型。所以在Java中需要特别关注一下<code>equals</code>的实现。</p>
<p>在kotlin中，<code>==</code>为比较对象的默认方式：<code>equals</code>重写的类的实例；比较引用类型。</p>
</blockquote>
<h3 id="Data-classes-autogenerated-implementations-of-universal-methods"><a class="header-anchor" href="#Data-classes-autogenerated-implementations-of-universal-methods">¶</a>Data classes: autogenerated implementations of universal methods</h3>
<p>如果希望类可以方便地保持数据，你需要override这些方法：<code>toString</code>、<code>equals</code>和<code>hashCode</code>。Kotlin 提供了<code>data</code> modifier来自动生成这些方法。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Client</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> postalCode: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>
<p>该类会重写所有的Java Object类的方法：</p>
<ul>
<li><code>equals</code> 用于实例比较</li>
<li><code>hashCode</code> hash-based 容器的keys</li>
<li><code>toString</code> 字符串表述</li>
</ul>
<p><code>equals</code> 和 <code>hashCode</code> 会计算所有在第一构造函数中声明的属性。<code>equals</code>会检测所有属性的equality；类似地，<code>hashCode</code>会整合所有属性的hash codes。</p>
<p><strong>DATA CLASSES AND IMMUTABILITY: THE COPY() METHOD</strong></p>
<p>当使用<code>data class</code>时，推荐声明实例为<code>immutable</code>的，因为它更多是作为read-only属性的一种存储手段。另外，编译<code>data class</code>时会额外生成一个<code>copy</code>方法，用于对其实例的修改操作。因此，<code>data class</code>实际上等效于如下的写法：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> postalCode: <span class="built_in">Int</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(name: <span class="type">String</span> = this.name, postalCode: <span class="type">Int</span> = this.postalCode)</span></span> =</span><br><span class="line">    Client(name, postalCode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> bob = Client(<span class="string">&quot;Bob&quot;</span>, <span class="number">973293</span>)</span><br><span class="line">&gt;&gt;&gt; println(bob.copy(postalCode = <span class="number">382555</span>))</span><br><span class="line">Client(name=Bob, postalCode=<span class="number">382555</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Class-delegation-using-the-“by”-keyword"><a class="header-anchor" href="#Class-delegation-using-the-“by”-keyword">¶</a>Class delegation: using the “by” keyword</h3>
<p>传递的Java类要实现Class delegation 有一个著名的设计模式 <em>Decorator</em> 。这种模式的本质就是设计一个新的类，旧的类作为该类的成员变量进行访问，从而达到不需要修改原有类来扩展新的方法实现。最常见的就是代理模式。</p>
<p>这种模式被广泛应用于一些框架如Spring中。这会产生很多样本代码。譬如如下代码实例：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DelegatingCollection</span>&lt;<span class="type">T</span>&gt; : <span class="type">Collection</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> innerList = arrayListOf&lt;T&gt;()</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> size: <span class="built_in">Int</span> <span class="keyword">get</span>() = innerList.size</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> = innerList.contains(element)</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">containsAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Boolean</span> = innerList.containsAll(elements)</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isEmpty</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = innerList.isEmpty()</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt; = innerList.iterator()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kotlin 支持first-class 的委派形式，上述代码可以重写为：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DelegatingCollection</span>&lt;<span class="type">T</span>&gt;(innerList: Collection&lt;T&gt; = ArrayList()) : Collection&lt;T&gt; <span class="keyword">by</span> innerList </span><br></pre></td></tr></table></figure>
<p>编译器会帮你自动生成 <em>delegating</em> 的代码，你需要做的，就是对你感兴趣的方法进行override即可。譬如实现自定义的集合：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CountingSet</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">private</span> <span class="keyword">val</span> innerSet: MutableCollection&lt;T&gt; = HashSet()) :</span><br><span class="line">  MutableCollection&lt;T&gt; <span class="keyword">by</span> innerSet &#123; <span class="comment">// Delegates the MutableCollection implementation to innerSet</span></span><br><span class="line">  <span class="keyword">var</span> objectsAdded = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;  <span class="comment">// no delegate</span></span><br><span class="line">    objectsAdded++</span><br><span class="line">    <span class="keyword">return</span> innerSet.add(element)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;  <span class="comment">// no delegate</span></span><br><span class="line">    objectsAdded += elements.size</span><br><span class="line">    <span class="keyword">return</span> innerSet.addAll(elements)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> cset = CountingSet&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">&gt;&gt;&gt; cset.addAll(listOf(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&gt;&gt;&gt; println(<span class="string">&quot;<span class="subst">$&#123;cset.objectsAdded&#125;</span> objects were added, <span class="subst">$&#123;cset.size&#125;</span> remain&quot;</span>)</span><br><span class="line"><span class="number">3</span> objects were added, <span class="number">2</span> remain</span><br></pre></td></tr></table></figure>
<h2 id="The-“object”-keyword-declaring-a-class-and-creating-an-instance-combined"><a class="header-anchor" href="#The-“object”-keyword-declaring-a-class-and-creating-an-instance-combined">¶</a>The “object” keyword: declaring a class and creating an instance, combined</h2>
<p>Kotlin提供了<code>object</code>关键字，有不同的使用场景：</p>
<ul>
<li><code>Object declaration</code> ，作为单例定义。</li>
<li><code>Companion objects</code> ，伴生对象。包含该类的工厂方法和其它方法。这些方法不需要创建实例也可以被调用。通过类名访问。</li>
<li><code>Object expression</code> ，相当于Java的匿名类， 一般用于第一构造函数的初始化。</li>
</ul>
<h3 id="Object-declarations-singetons-made-easy"><a class="header-anchor" href="#Object-declarations-singetons-made-easy">¶</a>Object declarations: singetons made easy</h3>
<p>单例直接用<code>object</code>修饰，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Payroll &#123;</span><br><span class="line">  <span class="keyword">val</span> allEmployees = arrayListOf&lt;Person&gt;()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">calculateSalary</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (person <span class="keyword">in</span> allEmployees) &#123;</span><br><span class="line">	  ...</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>object的声明可以继承类和接口实现。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> CaseInsensitiveFileComparator : Comparator&lt;File&gt; &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compare</span><span class="params">(o1: <span class="type">File</span>, o2: <span class="type">File</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> o1.path.compareTo(o2.path, ignoreCase = <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Companion-objects-a-place-for-factory-methods-and-static-members"><a class="header-anchor" href="#Companion-objects-a-place-for-factory-methods-and-static-members">¶</a>Companion objects: a place for factory methods and static members</h3>
<p>伴生对象在类内使用<code>companion object</code>声明，基本语法如下：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">	  println(<span class="string">&quot;Companion object called&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt; A.bar()</span><br><span class="line">Companion <span class="keyword">object</span> called</span><br></pre></td></tr></table></figure>
<p>伴生对象可以访问该类的所有<code>private</code>成员，包括<code>private</code> 构造器，是典型的Factory pattern。</p>
<p>下面是半生对象声明工厂方法的一个示例：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Individual</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">val</span> nickname: String</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constructor</span>(email: String) &#123;  <span class="comment">// Secondary constructors</span></span><br><span class="line">    nickname = email.substringBefore(<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constructor</span>(fackbookAccountId: <span class="built_in">Int</span>) &#123;  <span class="comment">// Secondary constructors</span></span><br><span class="line">    nickname = getFacebookName(fackbookAccountId)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Secondary constructor可以被替换为companion object作为工厂方法实现：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Individual</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="keyword">val</span> nickname: String) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">newSubscribingUser</span><span class="params">(email: <span class="type">String</span>)</span></span> = Individual(email.substringBefore(<span class="string">&#x27;@&#x27;</span>))</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">newFacebookUser</span><span class="params">(accountId: <span class="type">Int</span>)</span></span> = Individual(getFacebookName(accountId))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Companion-objects-as-regular-objects"><a class="header-anchor" href="#Companion-objects-as-regular-objects">¶</a>Companion objects as regular objects</h3>
<p>半生对象跟类名不同名是将作为常规对象，实际上会被编译为Java的静态对象的一个实例。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> Loader &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fromJSON</span><span class="params">(jsonText: <span class="type">String</span>)</span></span>: Person = ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; person = Person.Loader.fromJSON(<span class="string">&quot;&#123;name: &#x27;Dmitry&#x27;&#125;&quot;</span>)  <span class="comment">// You can use both ways to call fromJSON.</span></span><br><span class="line">&gt;&gt;&gt; person.name</span><br><span class="line">Dmitry</span><br><span class="line">&gt;&gt;&gt; person2 = Person.fromJSON(<span class="string">&quot;&#123;name: &#x27;Brent&#x27;&#125;&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; person2.name</span><br><span class="line">Brent</span><br></pre></td></tr></table></figure>
<p>也可以实现接口类型的伴生对象。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">JSONFactory</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">fromJSON</span><span class="params">(jsonText: <span class="type">String</span>)</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span>: JSONFactory&lt;Person&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fromJSON</span><span class="params">(jsonText: <span class="type">String</span>)</span></span>: Person = ... <span class="comment">// Companion object implementing an interface</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>COMPANION-OBJECT EXTENSIONS</strong></p>
<p>伴生对象也可以实现扩展方法(极度不推荐这样做！！)，语法和扩展类、扩展属性一致。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// business logic module</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> firstName: String, <span class="keyword">val</span> lastName: String) &#123;</span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> &#123;  <span class="comment">// Declares an empty companion object</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client/server communication module</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Person.Companion.<span class="title">fromJSON</span><span class="params">(json: <span class="type">String</span>)</span></span>: Person &#123;  <span class="comment">// Declares an extension function</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> p = Person.fromJSON(json)</span><br></pre></td></tr></table></figure>
<h3 id="Object-expressions-anonymous-inner-classes-rephrased"><a class="header-anchor" href="#Object-expressions-anonymous-inner-classes-rephrased">¶</a>Object expressions: anonymous inner classes rephrased</h3>
<p>匿名对象实际上向导那个要Java内匿名类的实例而已。写法如下：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.addMouseListener(</span><br><span class="line">  <span class="keyword">object</span>: MouseAdapter() &#123;  <span class="comment">// Declares an anonymous object extending MouseAdapter</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">	  <span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseEntered</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">	  <span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这种语法和对象的声明一样，处理省略了对象名。该对象表达式声明一个类被创建该类的一个实例，但不指派类或实例的名字。典型地，它是不需要的，因为仅在方法调用中作为参数。当然，你可以把它提取出来：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listener = <span class="keyword">object</span>: MouseAdapter() &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123; ... &#125;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseEntered</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>不同的是，Java的匿名类仅可以继承一个类或接口；Kotlin可以实现继承多个接口或不需要接口。</p>
<p>NOTE：和对象声明不同，匿名对象不是单例的。每次一个对象表达式被执行，相应地创建该实例对象。</p>
<p>因为匿名对象的创建属于表达式，因此可以修改外部对象实例。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countClicks</span><span class="params">(window: <span class="type">Window</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> clickCount = <span class="number">0</span>  <span class="comment">// Declares a local variable</span></span><br><span class="line">  </span><br><span class="line">  window.addMouseListener(<span class="keyword">object</span>: MouseAdapter() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">	  clickCount++  <span class="comment">// Updates the value of the variable</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ... </span></span><br></pre></td></tr></table></figure>
<h2 id="Summary"><a class="header-anchor" href="#Summary">¶</a>Summary</h2>
<ul>
<li>Kotlin的接口和Java类似，但可以包含默认的实现和属性。</li>
<li>默认，所有的声明都是<code>final</code>的、<code>public</code>的。</li>
<li>要令一个声明non-<code>final</code>，标记为<code>open</code>。</li>
<li><code>internal</code>为module可见的。</li>
<li>内嵌类(Nested classes)默认不是内部类。使用关键字<code>inner</code>来存储它的外部类的引用。</li>
<li><code>sealed</code>类的子类仅内嵌在它声明的地方(同一个文件)。</li>
<li>initializer blocks 和 secondary constructors 为类实例的创建提供了灵活性。</li>
<li>可以使用<code>field</code>标识引用accessor 体内的属性字段。</li>
<li><code>data class</code>提供了编译的<code>equals</code>、<code>hashCode</code>、<code>toString</code>、<code>copy</code>和其它方法。</li>
<li>类的委派避免了类似委派方法的样板代码。</li>
<li>kotlin中类的声明作为单例。</li>
<li>companion objects代替了Java的static块中的字段定义。</li>
<li>companion objects可以实现接口，也可以包含扩展函数和属性。</li>
<li>kotlin中的对象表达式可以代替Java的匿名内部类，并且可以实现多个接口、修改声明所在地方的变量，因为它属于表达式，每次执行将创建新的实例。</li>
</ul>
</div></article><nav class="article-nav"><div class="article-nav-prev">🔙<a href="/2021/12/01/concurrency/fibers-beyond-coroutine/">Fibers beyond coroutine beyond goroutine</a></div><div class="article-nav-next">🔜<a href="/2021/07/29/kotlin/02_defining_and_calling_functions/">Kotlin 函数</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2021/08/23/kotlin/03_classes_objects_and_interfaces/';
var disqus_title = '类，对象，接口';
var disqus_url = 'https://galudisu.info/2021/08/23/kotlin/03_classes_objects_and_interfaces/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>