<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>Kotlin 的类型系统</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">Kotlin 的类型系统</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2021-12-10</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/kotlin/">kotlin</a></p></div><div class="article-content"><h2 id="主要内容"><a class="header-anchor" href="#主要内容">¶</a>主要内容</h2>
<ol>
<li>空值处理</li>
<li>原生类型和对应的Java类型</li>
<li>Kotlin的集合以及与Java的关系</li>
</ol>
<p>Kotlin对空值类型的处理，并不是使用ADT。诸如<code>Option</code>、<code>Either</code>，而是使用符号记法<code>?</code>。对于类型转换，不使用协变逆协变，而是使用<code>as</code>和<code>Any?</code>这种语法。</p>
<span id="more"></span>
<h2 id="Nullability"><a class="header-anchor" href="#Nullability">¶</a>Nullability</h2>
<p>Nullability 在kotlin的type system是作为feature般的存在，用了避免<code>NullPointerException</code>错误。所以kotlin并不是要解决编译期或运行期的NPE问题，而是提供兼容手段，减少该异常在运行期出现的可能性。</p>
<p>因此，kotlin中需要讨论空值类型：kotlin通过标记值类型以允许可以为<code>null</code>，并提供空值类型的工具。</p>
<h3 id="Nullable-types"><a class="header-anchor" href="#Nullable-types">¶</a>Nullable types</h3>
<p>首先也是最重要的不同在于，Kotlin和Java类型系统上，kotlin是显式支持 <em>nullable types</em> 。什么意思？它提供了指定变量或属性允许为<code>null</code>的一种方式。如果一个变量为<code>null</code>，对其的方法调用是不安全的，因为它会导致<code>NullPointerException</code>。kotlin不允许这种调用以避免许多可能的异常。且看如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strLen</span><span class="params">(String s)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数是不安全的，传入的参数如果为<code>null</code>将会抛出<code>NullPointerException</code>。你可能需要根据需求在方法体内进行<code>null</code>检测。</p>
<p>下面是重写为kotlin的写法，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">strLen</span><span class="params">(s: <span class="type">String</span>)</span></span> = s.length</span><br></pre></td></tr></table></figure>
<p>如果传入<code>null</code>参数，会直接触发编译错误检查：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; strLen(<span class="literal">null</span>)</span><br><span class="line">ERROR: Null can not be a value of a non-<span class="literal">null</span> type String</span><br></pre></td></tr></table></figure>
<p>该参数被声明为<code>String</code>类型，在Kotlin中意味着它必须总是包含一个<code>String</code>实例。这是编译器强制性的，你不能传递一个<code>null</code>的参数。保证了函数<code>strLen</code>永远不会在运行时抛出<code>NullPointerException</code>。</p>
<p>如果你希望允许传入<code>null</code>参数，可以写为：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">strLenSafe</span><span class="params">(s: <span class="type">String</span>?)</span></span> = ...</span><br></pre></td></tr></table></figure>
<p>将问号置于类型签名之后。譬如：<code>String?</code>、<code>Int?</code>、<code>MyCustomType?</code>，等等。</p>
<p><img src="/img/kotlin-in-action/chapter06/Figure_06_01.png" alt="Figure 6.1"></p>
<p>再次重申，没有用<code>?</code>标记的变量是不能存储<code>null</code>引用的。意味着所有常规类型默认都是非空的(non-null)，除非显式指定可以为空。</p>
<p>一旦声明了一个nullable type类型， 一系列的操作将变得严格。例如，不能对其调用方法：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="function"><span class="keyword">fun</span> <span class="title">strLenSafe</span><span class="params">(s: <span class="type">String</span>?)</span></span> = s.length()</span><br><span class="line">ERROR: only safe (?.) or non-<span class="literal">null</span> asserted (!!.) calls are allowed on a nullable receiver of type kotlin.String?</span><br></pre></td></tr></table></figure>
<p>不可以将其分配给一个非空类型：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> x: String? = <span class="literal">null</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">var</span> y: String = x</span><br><span class="line">ERROR: Type mismatch: inferred type <span class="keyword">is</span> String? but String was expected</span><br></pre></td></tr></table></figure>
<p>也不可以传给非空参数方法，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; strLen(x)</span><br><span class="line">ERROR: Type mismatch: inferred type <span class="keyword">is</span> String? but String was expected</span><br></pre></td></tr></table></figure>
<p>你需要对其空值的可能性进行处理，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">strLenSafe</span><span class="params">(s: <span class="type">String</span>?)</span></span>: <span class="built_in">Int</span> = <span class="keyword">if</span> (s != <span class="literal">null</span>) s.length <span class="keyword">else</span> <span class="number">0</span> <span class="comment">// By adding the check for null, the code now compiles.</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> x: String? = <span class="literal">null</span></span><br><span class="line">&gt;&gt;&gt; println(strLenSafe(x))</span><br><span class="line"><span class="number">0</span></span><br><span class="line">&gt;&gt;&gt; println(strLenSafe(<span class="string">&quot;abc&quot;</span>))</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>这种写法有点啰嗦，后面会讲到kotlin的更简洁的写法。</p>
<h3 id="The-meaning-of-types"><a class="header-anchor" href="#The-meaning-of-types">¶</a>The meaning of types</h3>
<p>kotlin的类型系统上，对于<code>null</code>的处理本质和Java8之后的<code>Optional</code>一致，在编译期进行包装和检查，以确保在运行期不会过度的重复检查。</p>
<p>Java的API也相应提供了基于运行期的注解<code>@Nullable</code>和<code>@NotNull</code>等，在标准库定义，但不在标准库实现，运行期的检查实现可能在诸如Hibernate或Guava这些类库中。</p>
<h3 id="Safe-call-operator-“-”"><a class="header-anchor" href="#Safe-call-operator-“-”">¶</a>Safe call operator: “?.”</h3>
<p>Kotlin其中最有用的军械库是：<code>safe-call</code> —— <code>?.</code>。一分为二操作，允许同时对空值类型检查和后续非空值处理。例如，表达式<code>s?.toUpperCase()</code>实际上等价于<code>if (s != null) s.toUpperCase() else null</code>。</p>
<p>换句话就是，如果值不为空，则正常执行方法调用；如果为<code>null</code>，跳过调用，<code>null</code>直接作为结果。</p>
<p><img src="/img/kotlin-in-action/chapter06/Figure_06_02.png" alt="Figure 6.2"></p>
<p><em>safe-call</em> 的写法也可以用在属性访问上，如下：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> manager: Employee?)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">managerName</span><span class="params">(employee: <span class="type">Employee</span>)</span></span>: String? = employee.manager?.name</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> ceo = Employee(<span class="string">&quot;Da Boss&quot;</span>, <span class="literal">null</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> developer = Employee(<span class="string">&quot;Bob Smith&quot;</span>, ceo)</span><br><span class="line">&gt;&gt;&gt; println(managerName(developer))</span><br><span class="line">Da Boss</span><br><span class="line">&gt;&gt;&gt; println(managerName(ceo))</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p><em>safe-null</em> 可以进行链式调用，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>(<span class="keyword">val</span> streetAddress: String, <span class="keyword">val</span> zipCode: <span class="built_in">Int</span>, <span class="keyword">val</span> city: String, <span class="keyword">val</span> country: String)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> address: Address?)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> company: Company?)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Person.<span class="title">countryName</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">  <span class="keyword">val</span> country = <span class="keyword">this</span>.company?.address?.country  <span class="comment">// Several safe-call operators can be in a chain.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">if</span> (country != <span class="literal">null</span>) country <span class="keyword">else</span> <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> person = Person(<span class="string">&quot;Dmitry&quot;</span>, <span class="literal">null</span>)</span><br><span class="line">&gt;&gt;&gt; println(person.countryName())</span><br><span class="line">Unknown</span><br></pre></td></tr></table></figure>
<h3 id="Elvis-operator-“-”"><a class="header-anchor" href="#Elvis-operator-“-”">¶</a>Elvis operator: “?:”</h3>
<p>带默认值的空值处理操作符 <code>?:</code> 称作 <em>Elvis operator</em> 。写法如下，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(s: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> t: String = s ?: <span class="string">&quot;&quot;</span> <span class="comment">// If &quot;s&quot; is null, the result is an empty string.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似于Java的三元运算。逻辑如下，</p>
<p><img src="/img/kotlin-in-action/chapter06/Figure_06_03.png" alt="Figure 6.3"></p>
<p>通常和 <em>safe-call</em> 操作一起使用，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">strLenSafe</span><span class="params">(s: <span class="type">String</span>?)</span></span>: <span class="built_in">Int</span> = s?.length ?: <span class="number">0</span></span><br><span class="line">&gt;&gt;&gt; println(strLenSafe(<span class="string">&quot;abc&quot;</span>))</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt; println(strLenSafe(<span class="literal">null</span>))</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><code>countryName</code>函数也可以改为，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Person.<span class="title">countryName</span><span class="params">()</span></span> =</span><br><span class="line">  company?.address?.country ?: <span class="string">&quot;Unknown&quot;</span></span><br></pre></td></tr></table></figure>
<p>有些时候，希望直接抛出异常，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>(<span class="keyword">val</span> streetAddress: String, <span class="keyword">val</span> zipCode: <span class="built_in">Int</span>, <span class="keyword">val</span> city: String, <span class="keyword">val</span> country: String)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> address: Address?)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> company: Company?)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printShippingLabel</span><span class="params">(person: <span class="type">Person</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> address = person.company?.address?:<span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;No address&quot;</span>) <span class="comment">// Throws an exception if the address is absent</span></span><br><span class="line">  with(address) &#123;  <span class="comment">// &quot;address&quot; is non-null.</span></span><br><span class="line">    println(streetAddress)</span><br><span class="line">	println(<span class="string">&quot;<span class="variable">$zipCode</span> <span class="variable">$city</span>, <span class="variable">$country</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> address = Address(<span class="string">&quot;Elsestr. 47&quot;</span>, <span class="number">80687</span>, <span class="string">&quot;Munich&quot;</span>, <span class="string">&quot;Germany&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> jetbrains = Company(<span class="string">&quot;JetBrains&quot;</span>, address)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> person = Person(<span class="string">&quot;Dmitry&quot;</span>, jetbrains)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; printlnShippingLabel(person)</span><br><span class="line">Elsestr. <span class="number">47</span></span><br><span class="line"><span class="number">80687</span> Munish, Germany</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; printShippingLabel(Person(<span class="string">&quot;Alexey&quot;</span>, <span class="literal">null</span>))</span><br><span class="line">java.lang.IllegalArgumentException: No address</span><br></pre></td></tr></table></figure>
<h3 id="Safe-casts-“as-”"><a class="header-anchor" href="#Safe-casts-“as-”">¶</a>Safe casts: “as?”</h3>
<p>kotlin的 <em>safe cast</em> 也总是和 <em>safe call</em> 和 <em>elvis operator</em> 一起使用。类似地，作为feature用于处理<code>ClassCastException</code>的兼容性问题。</p>
<p><img src="/img/kotlin-in-action/chapter06/Figure_06_04.png" alt="Figure 6.4"></p>
<p><code>as?</code> 操作会尝试转换值的类型，如果不匹配将返回<code>null</code>。它常和 <em>Elvis operator</em> 一起使用。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> firstName: String, <span class="keyword">val</span> lastName: String) &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(o: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> otherPerson = o <span class="keyword">as</span>? Person ?: <span class="keyword">return</span> <span class="literal">false</span>  <span class="comment">// Checks the type and returns false if no match</span></span><br><span class="line">	<span class="keyword">return</span> otherPerson.firstName == firstName &amp;&amp; otherPerson.lastName == lastName <span class="comment">// After the safe cast, the variable otherPerson is smart-cast to the Person type.</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span>: <span class="built_in">Int</span> = firstName.hashCode() * <span class="number">37</span> + lastName.hashCode()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> p1 = Person(<span class="string">&quot;Dmitry&quot;</span>, <span class="string">&quot;Jemerov&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> p2 = Person(<span class="string">&quot;Dmitry&quot;</span>, <span class="string">&quot;Jemerov&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; println(p1 == p2)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt;&gt;&gt; println(p1.equals(<span class="number">42</span>))</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="Not-null-assertions-“-”"><a class="header-anchor" href="#Not-null-assertions-“-”">¶</a>Not-null assertions: “!!”</h3>
<p><em>not-null assertion</em> 非空断言操作符<code>!!</code>会在值为<code>null</code>的时候，直接抛出<code>NullPointerException</code>，逻辑如下，</p>
<p><img src="/img/kotlin-in-action/chapter06/Figure_06_05.png" alt="Figure 6.5"></p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ignoreNlls</span><span class="params">(s: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> sNotNull: String = s!!  <span class="comment">// The exception points to this line.</span></span><br><span class="line">  println(sNotNUll.length)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; jgnoreNulls(<span class="literal">null</span>)</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> kotlin.KotlinNullPointerException at &lt;...&gt;.ignoreNulls(...</span><br></pre></td></tr></table></figure>
<p>出现空值时，在运行时直接抛出<code>NullPointerException</code>。这种需要断言的情况大多数出现在类似swing ui这些框架中，譬如，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CopyRowAction</span>(<span class="keyword">val</span> list: JList&lt;String&gt;): AbstractAction() &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isEnabled</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = list.selectedValue != <span class="literal">null</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">actionPerformed</span><span class="params">(e: <span class="type">ActionEvent</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> value = list.selectedValue!!  <span class="comment">// actionPerformed is called only if isEnabled returns &quot;true&quot;</span></span><br><span class="line">	<span class="comment">// copy value to clipboard</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果不希望使用<code>!!</code>，你需要自定义返回，<code>val value = list.selectedValue ?: return</code>；否则一个空的<code>list.selectedValue</code>会被返回。并且需要记住的是，<code>!!</code>会触发异常，所以下面写法最好不要这样做：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.company!!.address!!.country  <span class="comment">// Don&#x27;t write code like this!</span></span><br></pre></td></tr></table></figure>
<p>这种写法，无法知道到底是<code>person</code>返回了null，还是<code>company</code>返回了null，除非你不关系。</p>
<h3 id="The-“let”-function"><a class="header-anchor" href="#The-“let”-function">¶</a>The “let” function</h3>
<p>Kotlin的内联函数<code>let</code>用于处理nullable表达式。和 <em>safe-call</em> 一起使用，属于一种 <strong>evaluate</strong> 操作，“假如… 就…”。</p>
<p>常见于对方法签名的参数处理，如下，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sendEmailTo</span><span class="params">(email: <span class="type">String</span>)</span></span> &#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure>
<p>你不能传递空值类型，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> email: String? = ...</span><br><span class="line">&gt;&gt;&gt; sendEmailTo(email)</span><br><span class="line">ERROR: Type mismatch: inferred type <span class="keyword">is</span> String? but String was expected</span><br></pre></td></tr></table></figure>
<p>这是你需要显式检查传入的值是否为<code>null</code>:</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (email != <span class="literal">null</span>) sendEmailTo(email)</span><br></pre></td></tr></table></figure>
<p>Kotlin中的<code>let</code>的逻辑如下，</p>
<p><img src="/img/kotlin-in-action/chapter06/Figure_06_06.png" alt="Figure 6.6"></p>
<p>因此，使用<code>let</code>结合lambda有更简洁的写法：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">email?.let &#123; email -&gt; sendEmailTo(email) &#125;</span><br></pre></td></tr></table></figure>
<p>或者用<code>it</code>替换，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">email?.let &#123;sendEmailTo(it) &#125;</span><br></pre></td></tr></table></figure>
<p>如果为null，lambda的表达式永远不会执行。</p>
<h3 id="Late-initialized-properties"><a class="header-anchor" href="#Late-initialized-properties">¶</a>Late-initialized properties</h3>
<p>某些框架对于一些变量或属性的声明是必须要延迟执行的，譬如JUnit这类。这时候就需要预先使用<code>?</code> 这类 nullable type替代。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">performAction</span><span class="params">()</span></span>: String = <span class="string">&quot;foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> myService: MyService? = <span class="literal">null</span>  <span class="comment">// Declares a property of a nullable type to initialize it with null</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Before</span> <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myService = MyService()  <span class="comment">// Provides a real initializer in the setUp method</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Test</span> <span class="function"><span class="keyword">fun</span> <span class="title">testAction</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;foo&quot;</span>, myService!!.performAction())  <span class="comment">// You have to take care of nullability: use !! or ?.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这看起来很丑，特别是如果要访问属性很多次时。为了解决这个问题，你可以将<code>myService</code>属性声明为 <em>late-initialized</em> 。你需要用到<code>lateinit</code>修改器，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">performAction</span><span class="params">()</span></span>: String = <span class="string">&quot;foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> myService: MyService  <span class="comment">// Declares a property of a non-null type without an initializer</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Before</span> <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myService = MyService()  <span class="comment">// Initializes the property in the setUp method as before</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Test</span> <span class="function"><span class="keyword">fun</span> <span class="title">testAction</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;foo&quot;</span>, myService.performAction())  <span class="comment">// Accesses the proerty without extra null checks</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有late-initialized的属性都是 <code>var</code>的，因为你需要在构造器外部更改它的值，以及<code>val</code>属性则被编译为final的，必须在构造器内初始化。<code>lateinit</code>更多被用于DI(dependency injection)之类的框架中，譬如spring等。</p>
<h3 id="Extensions-for-nullable-types"><a class="header-anchor" href="#Extensions-for-nullable-types">¶</a>Extensions for nullable types</h3>
<p>空值类型在Kotlin中属于类型系统部分，当然也有extension function，写法上没有差别，只不过接收类型(receiver type)是带有<code>?</code>标记的，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String?.<span class="title">isNullOrBlank</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = <span class="comment">// Extension for a nullable String</span></span><br><span class="line">  <span class="keyword">this</span> == <span class="literal">null</span> || <span class="keyword">this</span>.isBlank()  <span class="comment">// A smart cast is applied to the second &quot;this&quot;.</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，之前介绍的内联函数<code>let</code>也是带有接收类型，但它不做<code>null</code>的检查。所以如果在lambda调用空值类型而不使用safe-call 操作符，lambda内的参数也可能是空值类型的，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> person: Person? = ...</span><br><span class="line">&gt;&gt;&gt; person.let &#123; sendEmailTo(it) &#125;  <span class="comment">// No safe call, so &quot;it&quot; has a nullable type.</span></span><br><span class="line">ERROR: Type mismatch: inferred type <span class="keyword">is</span> Person? but Person was expectd</span><br></pre></td></tr></table></figure>
<p>所以你必须尽早处理空值，<code>person?.let &#123; sendEmailTo(it) &#125;</code>。</p>
<h3 id="Nullability-of-type-parameters"><a class="header-anchor" href="#Nullability-of-type-parameters">¶</a>Nullability of type parameters</h3>
<p>默认地，Kotlin中所有函数的参数类型都是可空的。任何类型，包括空值类型，都可以被替代为参数类型；因此，类型的参数声明是运行为<code>null</code>，即使参数类型<code>T</code>没有以<code>?</code>结尾。考虑如下代码。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">printHashCode</span><span class="params">(t: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">  println(t?.hashCode9))  <span class="comment">// You have to use a safe call because &quot;t&quot; might be null.</span></span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt; printHashCode(<span class="literal">null</span>)  <span class="comment">// &quot;T&quot; is inferred as &quot;Any?&quot;.</span></span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，类型参数<code>T</code>被推断为<code>Any?</code>。因此，<code>t</code>是运行为<code>null</code>的，即使没有带<code>?</code>。</p>
<p>若要使其类型参数不为<code>null</code>，需要指定一个非空类型边界，如下，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Any&gt;</span> <span class="title">printHashCode</span><span class="params">(t: <span class="type">T</span>)</span></span> &#123;  <span class="comment">// Now &quot;T&quot; can&#x27;t be nullable.</span></span><br><span class="line">  println(t.hashCode())</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt; printHashCode(<span class="literal">null</span>)  <span class="comment">// This code doesn&#x27;t compile: you can&#x27;t pass null because a non-null value is expected.</span></span><br><span class="line">Error: Type parameter bound <span class="keyword">for</span> `T` <span class="keyword">is</span> not satisfied</span><br><span class="line">&gt;&gt;&gt; printHashCode(<span class="number">42</span>)</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure>
<h2 id="Primitive-and-other-basic-types"><a class="header-anchor" href="#Primitive-and-other-basic-types">¶</a>Primitive and other basic types</h2>
<p>Kotlin不区分原生类型和封装类型。</p>
<h3 id="Primitive-types-Int-Boolean-and-more"><a class="header-anchor" href="#Primitive-types-Int-Boolean-and-more">¶</a>Primitive types: Int, Boolean, and more</h3>
<ul>
<li>对于变量、属性、参数以及返回值，Kotlin的<code>Int</code>类型编译为Java的原生类型<code>int</code>。</li>
<li>对于泛型类，Kotlin的<code>Int</code>则编译为Java的包装类型。如集合类。</li>
</ul>
<p>下面对应于Java的原生类型列表：</p>
<ul>
<li><em>Integer Types</em> : <code>Byte</code>、<code>Short</code>、<code>Int</code>、<code>Long</code></li>
<li><em>Floating-point number types</em> : <code>Float</code>、<code>Double</code></li>
<li><em>Character type</em> : <code>Char</code></li>
<li><em>Boolean type</em> : <code>Boolean</code></li>
</ul>
<h3 id="Nullable-primitive-types-Int-Boolean-and-more"><a class="header-anchor" href="#Nullable-primitive-types-Int-Boolean-and-more">¶</a>Nullable primitive types: Int?, Boolean?, and more</h3>
<p>Kotlin中的可空原生类型并不能表述为Java的原生类型，因为<code>null</code>在Java中仅存储为变量的引用。意味着无论kotlin中用的是哪种可空的原生类型，只能编译为Java的包装类型。</p>
<p>以下面例子开始，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>? = <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">isOlderThan</span><span class="params">(other: <span class="type">Person</span>)</span></span>: <span class="built_in">Boolean</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> (age == <span class="literal">null</span> || other.age == <span class="literal">null</span>)</span><br><span class="line">	  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">	<span class="keyword">return</span> age &gt; other.age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(Person(<span class="string">&quot;Sam&quot;</span>, <span class="number">35</span>).isOlderThan(Person(<span class="string">&quot;Amy&quot;</span>, <span class="number">42</span>)))</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&gt;&gt;&gt; println(Person(<span class="string">&quot;Sam&quot;</span>, <span class="number">35</span>).isOlderThan(Person(<span class="string">&quot;Jane&quot;</span>)))</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>这里并不能比较两个<code>Int?</code>类型，因为其中一个有可能为<code>null</code>。相反，你必须两个值都做<code>null</code>检查。之后再比较它们的真实值。</p>
<p>另外，对于泛型类型，kotlin会使用它的装箱类型替代，如下</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listOfInts = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>会创建一个<code>Integer</code>的集合变量。</p>
<p>这是因为，泛型的实现是有JVM所控制的。JVM并不支持原生类型作为泛型参数，所以泛型类(不论是Java还是Kotlin)都必须使用装箱类型表述。</p>
<h3 id="Number-conversions"><a class="header-anchor" href="#Number-conversions">¶</a>Number conversions</h3>
<p>Kotlin和Java的一个重要区分是对数字的转换处理。Kotlin并不自动将数字类型由一种类型，转换为另一种，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> l: <span class="built_in">Long</span> = i  <span class="comment">// Error: type mismatch</span></span><br></pre></td></tr></table></figure>
<p>相反，你需要显式转换，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> l: <span class="built_in">Long</span> = i.toLong()</span><br></pre></td></tr></table></figure>
<p>每个原生类型都定义了相应的转换函数(处理<code>Boolean</code>)：<code>toByte()</code>、<code>toShort()</code>、<code>toChar()</code>等等。函数支持两个方向的转换：小类型到大类型，如<code>Int.toLong()</code>，大类型到小类型，<code>Long.toInt()</code>。</p>
<p>Kotlin需要显式进行转换是为了避免出现意外，特别是比较封装类型时。<code>equals</code>方法会检测封装类型和值。因为，在Java中，<code>new Integer(42).equals(new Long(42))</code>是返回<code>false</code>的。</p>
<p>假如Kotlin支持隐式转换，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">1</span>  <span class="comment">// Int variable</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>)  <span class="comment">// List of Long values</span></span><br><span class="line">x <span class="keyword">in</span> list  <span class="comment">// False if Kotlin supported implicit conversions</span></span><br></pre></td></tr></table></figure>
<p>这会触发编译错误，kotlin要求你显式地转换指定的类型进行比较，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> x= <span class="number">1</span></span><br><span class="line">&gt;&gt;&gt; println(x.toLong() <span class="keyword">in</span> listOf(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>))</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Primitive type literals</strong></p>
<p>Kotlin支持下面几种形式的数字字面量写法：</p>
<ul>
<li><code>Long</code>类型使用<code>L</code>作为后缀：<code>123L</code>。</li>
<li><code>Double</code>类型使用标准浮点数的写法：<code>0.12</code>、<code>2.0</code>、<code>2e10</code>、<code>1.2e-10</code>。</li>
<li><code>Float</code>使用<code>f</code>或<code>F</code>作为后缀：<code>123.4f</code>、<code>.456F</code>、<code>1e3f</code>。</li>
<li>十六进制字面量使用<code>0x</code>或<code>0X</code>前缀：<code>0xCAFEBABE</code>或<code>0xbcdL</code>。</li>
<li>二进制字面量使用<code>0b</code>或<code>0B</code>前缀：<code>0b000000101</code>。</li>
</ul>
<p>注意，下划线的表述写法仅从Kotlin 1.1 开始支持。</p>
<p>对于字符字面量，和Java写法一样。使用单引号：<code>1</code>、<code>\t</code>、<code>\u0009</code>。</p>
</blockquote>
<p>注意，对于演算操作来说是不需要显式指定类型的。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(l: <span class="type">Long</span>)</span></span> = println(l)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> b: <span class="built_in">Byte</span> = <span class="number">1</span>  <span class="comment">// Constant value gets the correct type</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> l = b + <span class="number">1L</span>  <span class="comment">// works with Byte and Long arguments.</span></span><br><span class="line">&gt;&gt;&gt; foo(<span class="number">42</span>)  <span class="comment">// The compiler interprets 42 as a Long value.</span></span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure>
<h3 id="“Any”-and-“Any-”-the-root-types"><a class="header-anchor" href="#“Any”-and-“Any-”-the-root-types">¶</a>“Any” and “Any?”: the root types</h3>
<p>Kotlin的<code>Any</code>对应于Java的<code>Object</code>。不同的是，Java中的<code>Object</code>是所有类型的超类，但不包括原生类型。Kotlin中，<code>Any</code>则是所有类型的超类，包括原生类型诸如<code>Int</code>。</p>
<p>和Java一样，分配原生类型给变量类型为<code>Any</code>时会自动装箱，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> answer: Any = <span class="number">42</span> <span class="comment">// The value 42 is boxed, because Any is a reference type.</span></span><br></pre></td></tr></table></figure>
<p><code>Any</code>是不可为空类型，包含三个方法：<code>toString</code>、<code>equals</code>和<code>hashCode</code>。其它方法诸如<code>wait</code>和<code>notify</code>并不可用，除非显式转换为<code>java.lang.Object</code>。</p>
<h3 id="The-Unit-type-Kotlin’s-“void”"><a class="header-anchor" href="#The-Unit-type-Kotlin’s-“void”">¶</a>The Unit type: Kotlin’s “void”</h3>
<p><code>Unit</code>类型是Java中<code>void</code>的完全实现。它可以作为一个函数的返回类型：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span>: <span class="built_in">Unit</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>语法层面上就是一个没有返回类型的语句块，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>基本上它和Java的void没有任何区别，唯一区分的是它被作为类型参数使用了。因为在语句块中它不需要返回任何值，<code>return</code>语句也可以省略。</p>
<h3 id="The-Nothing-type-“This-function-never-returns”"><a class="header-anchor" href="#The-Nothing-type-“This-function-never-returns”">¶</a>The Nothing type: “This function never returns”</h3>
<p>为了阐述那种“没有执行完整”的逻辑，譬如无限循环语句、中间抛出异常的语句。Kotlin引入了这种特殊类型<code>Nothing</code>。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fail</span><span class="params">(message: <span class="type">String</span>)</span></span>: <span class="built_in">Nothing</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> IllegalStateException(message)</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt; fail(<span class="string">&quot;Error occurred&quot;</span>)</span><br><span class="line">java.lang.IllegalStateException: Error occurred</span><br></pre></td></tr></table></figure>
<p>同样，<code>Nothing</code>类型没有任何值，仅作为函数的返回类型或类型参数使用。这种返回类型为<code>Nothing</code>的函数，可以用在 _elvis operator_的表达式上，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> address= company.address ?: fail(<span class="string">&quot;No address&quot;</span>)</span><br><span class="line">println(address.city)</span><br></pre></td></tr></table></figure>
<h2 id="Collections-and-arrays"><a class="header-anchor" href="#Collections-and-arrays">¶</a>Collections and arrays</h2>
<p>Kotlin在Java内建集合的基础上，增加了extension的feature。注意，是作为一种feature实现。</p>
<h3 id="Nullability-and-collections"><a class="header-anchor" href="#Nullability-and-collections">¶</a>Nullability and collections</h3>
<p>集合类型对于空值类型参数，需要严格区分<code>List&lt;Int?&gt;</code>还是<code>List&lt;Int&gt;?</code>还是<code>List&lt;Int?&gt;?</code>。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readNumbers</span><span class="params">(reader: <span class="type">BufferedReader</span>)</span></span>: List&lt;<span class="built_in">Int</span>?&gt; &#123;</span><br><span class="line">  <span class="keyword">val</span> result = ArrayList&lt;<span class="built_in">Int</span>?&gt;()  <span class="comment">// Creates a list of nullable Int values</span></span><br><span class="line">  <span class="keyword">for</span> (line <span class="keyword">in</span> reader.lineSequence()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> number = line.toInt()</span><br><span class="line">      result.add(number)  <span class="comment">// Adds an integer(a non-null value) to the list</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: NumberFormatException) &#123;</span><br><span class="line">      result.add(<span class="literal">null</span>)  <span class="comment">// Adds null to the list, because the current line can&#x27;t be parsed to an integer</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/kotlin-in-action/chapter06/Figure_06_10.png" alt="Figure 6.10"></p>
<h3 id="Read-only-and-mutable-collections"><a class="header-anchor" href="#Read-only-and-mutable-collections">¶</a>Read-only and mutable collections</h3>
<p>Kotlin中将对集合数据的访问和修改分离为不同的两个接口实现了。</p>
<p><img src="/img/kotlin-in-action/chapter06/Figure_06_11.png" alt="Figure 6.11"></p>
<p>大多数情况下， 我们只会用的只读的接口api。如果需要更新集合实例，可能需要创建一份copy新的实例。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">copyElements</span><span class="params">(source: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;, target: <span class="type">MutableCollection</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (item <span class="keyword">in</span> source) &#123;  <span class="comment">// Loops over all items in the source collection</span></span><br><span class="line">    target.add(item)  <span class="comment">// Adds items to the mutable target collection</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> source: Collection&lt;<span class="built_in">Int</span>&gt; = arrayListOf(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> target: MutableCollection&lt;<span class="built_in">Int</span>&gt; = arrayListOf(<span class="number">1</span>)</span><br><span class="line">&gt;&gt;&gt; copyElement(source, target)</span><br><span class="line">&gt;&gt;&gt; println(target)</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p>** read-only collections aren’t necessarily immutable **.</p>
<p>对于只读集合是不能被修改的，这样设计可以保证在多线程环境下获取数据的一致性(强一致)。</p>
<p><img src="/img/kotlin-in-action/chapter06/Figure_06_12.png" alt="Figure 6.12"></p>
<h3 id="Kotlin-collections-and-Java"><a class="header-anchor" href="#Kotlin-collections-and-Java">¶</a>Kotlin collections and Java</h3>
<p>无可否有，Kotlin的集合都有一个与之唯一对应的Java集合接口。集合中的数据不需要转换或封装类型。因为Kotlin中的集合更多是作为feature存在。</p>
<p><img src="/img/kotlin-in-action/chapter06/Figure_06_13.png" alt="Figure 6.13"></p>
<p>下面是常见的集合类型的扩展函数，</p>
<table>
<thead>
<tr>
<th style="text-align:center">collection type</th>
<th style="text-align:center">Read-only</th>
<th style="text-align:center">Mutable</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">List</td>
<td style="text-align:center"><code>listOf</code></td>
<td style="text-align:center"><code>mutableListOf</code> <code>arrayListOf</code></td>
</tr>
<tr>
<td style="text-align:center">Set</td>
<td style="text-align:center"><code>setOf</code></td>
<td style="text-align:center"><code>mutableSetOf</code> <code>hashSetOf</code> <code>linkedSetOf</code> <code>sortedSetOf</code></td>
</tr>
<tr>
<td style="text-align:center">Map</td>
<td style="text-align:center"><code>mapOf</code></td>
<td style="text-align:center"><code>mutableMapOf</code> <code>hashMapOf</code> <code>linkedMapOf</code> <code>sortedMapOf</code></td>
</tr>
</tbody>
</table>
<p>注意，<code>setOf()</code>和<code>mapOf()</code>返回Java标准库的类实例(Kotlin 1.0)。Kotlin将来的版本会重新设计实现。</p>
<p>由于接口层实现一致，Java和Kotlin的集合可以混用，不需要关心编译问题。</p>
<h3 id="Collections-as-platform-types"><a class="header-anchor" href="#Collections-as-platform-types">¶</a>Collections as platform types</h3>
<h3 id="Arrays-of-objects-and-primitive-types"><a class="header-anchor" href="#Arrays-of-objects-and-primitive-types">¶</a>Arrays of objects and primitive types</h3>
<p>而对于对象数组类型，提供了<code>Array</code>类封装，如下，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> args.indices) &#123;  <span class="comment">// Uses the array.indices extension property to iterate over the range of indices</span></span><br><span class="line">    println(<span class="string">&quot;Argument <span class="variable">$i</span> is: <span class="subst">$&#123;args[i]&#125;</span>&quot;</span>) <span class="comment">// Accesses elements by index with array[index]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问方式依然通过数组下标访问<code>array[index]</code>。</p>
<p>要在Kotlin中创建一个数组，有下面几种形式：</p>
<ul>
<li><code>arrayOf</code>函数创建，</li>
<li><code>arryOfNulls</code>函数创建，包含<code>null</code>元素。当然，也仅能用于创建可能为空的元素。</li>
<li><code>Array</code>构造函数创建，参数为元素个数+lambda表达式，如下</li>
</ul>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> letters = Array&lt;String&gt;(<span class="number">26</span>) &#123; i -&gt; (<span class="string">&#x27;a&#x27;</span> + i).toString() &#125;</span><br><span class="line">&gt;&gt;&gt; println(letters.joinToString(<span class="string">&quot;&quot;</span>))</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br></pre></td></tr></table></figure>
<p>其中，类型参数可以省略，编译期可以自动推断真实的数组类型。</p>
<p>为了表示Java的原生数据类型，Kotlin提供了对其的包装类型，譬如<code>IntArray</code>、<code>ByteArray</code>、<code>CharArray</code>、<code>BooleanArray</code>等等。对应于Java的<code>int[]</code>、<code>byte[]</code>、<code>char[]</code>。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> fiveZeros = IntArray(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> fiveZerosToo = intArrayOf(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>类似地，也可以调用构造函数创建，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> squares = IntArray(<span class="number">5</span>) &#123; i -&gt; (i + <span class="number">1</span>) * (i + <span class="number">1</span>) &#125;</span><br><span class="line">&gt;&gt;&gt; println(squares.joinToString())</span><br><span class="line"><span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span></span><br></pre></td></tr></table></figure>
<p>相应的，Kotlin也提供了内联函数<code>toIntArray</code>实现对原生数据类型到封装数据类型的转换。</p>
<h2 id="Summary"><a class="header-anchor" href="#Summary">¶</a>Summary</h2>
<ul>
<li>Kotlin支持运行时的空值类型的探测可能 <code>NullPointerException</code>错误。</li>
<li>Kotlin提供工具诸如 <code>?.</code> ( <em>safe call</em> )、<code>?:</code> ( <em>elvis operator</em> )、<code>!!</code> ( <em>not-null assertions</em> ) 以及<code>let</code>函数等简化空值的处理。</li>
<li><code>as?</code>提供简单的类型转换。</li>
<li>Kotlin提供对Java原生类型和封装类型的编译规则。</li>
<li>空值原生类型在Kotlin中对应于<code>Int?</code>，编译为Java的包装类型<code>java.lang.Integer</code>。</li>
<li><code>Any</code>类是所有类的超类，但<code>wait</code>和<code>notify</code>方法是不可用的；<code>Unit</code>对应于<code>void</code>的逻辑实现。</li>
<li><code>Nothing</code>类作为一种返回类型，表示函数没用正常结束的情况。</li>
<li>Kotlin中的集合实际上是对Java集合的增强。因此可以进行混用，无需关系集合的数据类型。</li>
<li>Kotlin要求区分可变集合、可空(nullability)集合，以避免多线程数据不一致等问题。</li>
<li>Kotlin中的<code>Array</code>类看起来是普通的类，但实际上是编译为Java的数组。</li>
<li>原生类型的数组，在Kotlin中有对应的包装类型代替，譬如<code>IntArray</code>对应于<code>int[]</code>，以及提供了相应的内联函数进行转换，譬如<code>toIntArray</code>。</li>
</ul>
</div></article><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2021/12/10/kotlin/05_the_kotlin_type_system/';
var disqus_title = 'Kotlin 的类型系统';
var disqus_url = 'https://galudisu.info/2021/12/10/kotlin/05_the_kotlin_type_system/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>