<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>Operator overloading and other conventions</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/maths/">Maths</a></li><li class="menu-item"><a class="menu-link" href="/projects/">Projects</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/maths/">Maths</a></li><li class="menu-item"><a class="menu-link" href="/projects/">Projects</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">Operator overloading and other conventions</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2021-12-17</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/kotlin/">kotlin</a></p></div><div class="article-content"><h2 id="主要内容"><a class="header-anchor" href="#主要内容">¶</a>主要内容</h2>
<ol>
<li>操作符重载</li>
<li>指名(special-named)函数：convension的一种实现</li>
<li>属性委派</li>
</ol>
<p>类似于Java语言有好几样特性一样，譬如对象实现了<code>java.lang.Iterable</code>接口的可以使用<code>for</code>循环，实现了<code>java.lang.AutoCloseable</code>接口的可以使用try-with-resources语句(Java 8 之后)。Kotlin提供了一种 <em>convertions</em> 技术，实现对操作符的重载。</p>
<span id="more"></span>
<h2 id="Overloading-arithmetic-operators"><a class="header-anchor" href="#Overloading-arithmetic-operators">¶</a>Overloading arithmetic operators</h2>
<p>Kotlin中最直接的公约是算术运算符。在Java中，算术运算符仅可以用于原生类型，额外地<code>+</code>号可以用于连结<code>String</code>类型。但对于其它类如<code>BigInteger</code>，使用<code>+</code>比起使用<code>add</code>方法会更加直观。</p>
<h3 id="Overloading-binary-arithmetic-operations"><a class="header-anchor" href="#Overloading-binary-arithmetic-operations">¶</a>Overloading binary arithmetic operations</h3>
<p>Kotlin的公约提供了操作符重载，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Point</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>) &#123;</span><br><span class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(other: <span class="type">Point</span>)</span></span>: Point &#123;  <span class="comment">// Defines an operator function named &quot;plus&quot;</span></span><br><span class="line">    <span class="keyword">return</span> Point(x + other.x, y + other.y)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> p1 = Point(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> p2 = Point(<span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line">&gt;&gt;&gt; println(p1 + p2)  <span class="comment">// Calls the &quot;plus&quot; function using the + sign</span></span><br><span class="line">Point(x=<span class="number">40</span>, y=<span class="number">60</span>)</span><br></pre></td></tr></table></figure>
<p>这里用到<code>operator</code>关键字来声明<code>plus</code>函数。所有需要重载运算符都需要使用该关键字。表示显式地实现相应的约定。</p>
<p><img src="/img/kotlin-in-action/chapter07/Figure_07_01.png" alt="Figure 7.1"></p>
<p>另外一种写法是结合扩展函数定义，因为很多情况下你并不希望或不能修改原有的类。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">plus</span><span class="params">(other: <span class="type">Point</span>)</span></span>: Point &#123;</span><br><span class="line">  <span class="keyword">return</span> Point(x + other.x, y + other.y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下标罗列的约定的所有算术符号对应的函数名，</p>
<table>
<thead>
<tr>
<th style="text-align:center">Expression</th>
<th style="text-align:center">Function name</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>a * b</code></td>
<td style="text-align:center"><code>times</code></td>
</tr>
<tr>
<td style="text-align:center"><code>a / b</code></td>
<td style="text-align:center"><code>div</code></td>
</tr>
<tr>
<td style="text-align:center"><code>a % b</code></td>
<td style="text-align:center"><code>mod</code></td>
</tr>
<tr>
<td style="text-align:center"><code>a + b</code></td>
<td style="text-align:center"><code>plus</code></td>
</tr>
<tr>
<td style="text-align:center"><code>a - b</code></td>
<td style="text-align:center"><code>minus</code></td>
</tr>
</tbody>
</table>
<p>运算符的定义并没有严格要求两个对象的类型必须一致，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">times</span><span class="params">(scale: <span class="type">Double</span>)</span></span>: Point &#123;</span><br><span class="line">  <span class="keyword">return</span> Point((x * scale).toInt(), (y * scale).toInt())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> p = Point(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">&gt;&gt;&gt; println(p * <span class="number">1.5</span>)</span><br><span class="line">Point(x=<span class="number">15</span>, y=<span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<p>但是Kotlin的operator不支持交换律 <em>commutativity</em> 。所以你需要重新再定义以满足交换律。<code>operator fun Double.times(p: Point): Point</code>。</p>
<p>返回类型也可以自定义，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="built_in">Char</span>.<span class="title">times</span><span class="params">(count: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">  <span class="keyword">return</span> toString().repeat(count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(<span class="string">&#x27;a&#x27;</span> * <span class="number">3</span>)</span><br><span class="line">aaa</span><br></pre></td></tr></table></figure>
<blockquote>
<p>** No special operators for bitwise operations**</p>
<p>Kotlin并没有定义位运算符。相反，位运算被定义为常规的中缀调用语法(infix call syntax)。如，</p>
<ul>
<li><code>shl</code>，左移</li>
<li><code>shr</code>，右移</li>
<li><code>ushr</code>，无符号右移</li>
<li><code>and</code>，按位与</li>
<li><code>or</code>，按位或</li>
<li><code>xor</code>，按位异或</li>
<li><code>inv</code>，按位反</li>
</ul>
<p>譬如，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; println(<span class="number">0x0F</span> and <span class="number">0xF0</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line">&gt;&gt;&gt; println(<span class="number">0x0F</span> or <span class="number">0xF0</span>)</span><br><span class="line"><span class="number">255</span></span><br><span class="line">&gt;&gt;&gt; println(<span class="number">0x1</span> shl <span class="number">4</span>)</span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Overloading-compound-assignment-operators"><a class="header-anchor" href="#Overloading-compound-assignment-operators">¶</a>Overloading compound assignment operators</h3>
<p>复合赋值操作符( <em>compound assignment operator</em> )，跟算术操作符一样，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">var</span> point = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt; point += Point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&gt;&gt;&gt; println(point)</span><br><span class="line">Point(x=<span class="number">4</span>, y=<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>对于可变集合来说，<code>+=</code> 操作相当于添加新的元素，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> numbers = ArrayList&lt;int&gt;()</span><br><span class="line">&gt;&gt;&gt; numbers += <span class="number">42</span></span><br><span class="line">&gt;&gt;&gt; println(numbers[<span class="number">0</span>])</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure>
<p>对于可变集合，Kotlin标准库中定义了<code>plusAssign</code>函数公约，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> MutableCollection<span class="type">&lt;T&gt;</span>.<span class="title">plusAssign</span><span class="params">(element: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.add(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中如果用到<code>+=</code>，理论上会调用到<code>plus</code>和<code>plusAssign</code>函数，</p>
<p><img src="/img/kotlin-in-action/chapter07/Figure_07_02.png" alt="Figure 7.2"></p>
<p>如果定义的类是不可变的，相应定义返回新值的函数<code>plus</code>；如果是可变的，则定义返回可变实例的<code>plusAssign</code>函数。但请尽量不要同时都定义这两个函数。</p>
<p>而操作符<code>+</code>和<code>-</code>的集合运算总是返回新的集合，其中，对于可变集合，直接修改其值；对于不可变集合，返回新的集合copy实例。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> list = arrayListOf(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt; list += <span class="number">3</span>  <span class="comment">// += changes &quot;list&quot;.</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> newList = list + listOf(<span class="number">4</span>, <span class="number">5</span>)  <span class="comment">// + returns a new list containing all the elements.</span></span><br><span class="line">&gt;&gt;&gt; println(list)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt; println(newList)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<h3 id="Overloading-unary-operators"><a class="header-anchor" href="#Overloading-unary-operators">¶</a>Overloading unary operators</h3>
<p>Kotlin中支持一元操作( <em>unary</em> )。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">unaryMinus</span><span class="params">()</span></span>: Point &#123;</span><br><span class="line">  <span class="keyword">return</span> Point(-x, -y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> p = Point(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">&gt;&gt;&gt; println(-p)</span><br><span class="line">Point(x=-<span class="number">10</span>, y=-<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p>一元操作函数重载不需要任何参数，</p>
<p><img src="/img/kotlin-in-action/chapter07/Figure_07_03.png" alt="Figure 7.3"></p>
<p>列表如下，</p>
<table>
<thead>
<tr>
<th style="text-align:center">Expression</th>
<th style="text-align:center">Function name</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>+a</code></td>
<td style="text-align:center"><code>unaryPlus</code></td>
</tr>
<tr>
<td style="text-align:center"><code>-a</code></td>
<td style="text-align:center"><code>unaryMinus</code></td>
</tr>
<tr>
<td style="text-align:center"><code>!a</code></td>
<td style="text-align:center"><code>not</code></td>
</tr>
<tr>
<td style="text-align:center"><code>++a</code> <code>a++</code></td>
<td style="text-align:center"><code>inc</code></td>
</tr>
<tr>
<td style="text-align:center"><code>--a</code> <code>a--</code></td>
<td style="text-align:center"><code>dec</code></td>
</tr>
</tbody>
</table>
<p>对于自增<code>inc</code>或自减<code>dec</code>函数来说，编译器会自动支持前置或后置的语义识别，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> BigDecimal.<span class="title">inc</span><span class="params">()</span></span> = <span class="keyword">this</span> + BigDecimal.ONE</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">var</span> bd = BigDecimal.ZERO</span><br><span class="line">&gt;&gt;&gt; println(bd++)  <span class="comment">// Increments after the first println statement executes</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">&gt;&gt;&gt; println(++bd)  <span class="comment">// Increments before the second println statement executes</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="Overloading-comparison-operators"><a class="header-anchor" href="#Overloading-comparison-operators">¶</a>Overloading comparison operators</h2>
<p>Kotlin约定函数中也相应定义了比较操作符(<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>等)。</p>
<h3 id="Equality-operators-“equals”"><a class="header-anchor" href="#Equality-operators-“equals”">¶</a>Equality operators: “equals”</h3>
<p><code>==</code> 操作在Kotlin中真正被调用为<code>equals</code>方法。<code>!=</code>实际上也是被翻译为<code>equlas</code>的调用，只不过为相反方式。不同的是<code>==</code>和<code>!=</code>可以用于对<code>null</code>的比较，因为它底层可以检测<code>null</code>值。</p>
<p><img src="/img/kotlin-in-action/chapter07/Figure_07_04.png" alt="Figure 7.4"></p>
<h3 id="Ordering-operators-compareTo"><a class="header-anchor" href="#Ordering-operators-compareTo">¶</a>Ordering operators: compareTo</h3>
<p><code>compareTo</code>方法被定义在<code>Comparable</code>接口中。但是Java中只有原生类型采用使用比较操作符<code>&gt;</code>、<code>&lt;</code>；其它类型只能显式地使用<code>element1.compareTo(element2)</code>来比较两个对象。</p>
<p>Kotlin支持同样的<code>Comparable</code>接口。但是<code>compareTo</code>方法定义的接口在Kotlin中无法进行重载，因为它底层被翻译为<code>compareTo</code>的调用，</p>
<p><img src="/img/kotlin-in-action/chapter07/Figure_07_05.png" alt="Figure 7.5"></p>
<p>和<code>equlas</code>一样，你需要继承<code>Comparable</code>接口对其方法进行重载，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> firstName: String, <span class="keyword">val</span> lastName: String): Comparable&lt;Person&gt; &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">Person</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> compareValuesBy(<span class="keyword">this</span>, other, Person::lastName, Person::firstName)  <span class="comment">// Evaluates the given callbacks in order, and compares values</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> p1 = Person(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Smith&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> p2 = Person(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Johnson&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; println(p1 &lt; p2)</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><code>compareValuesBy</code>为Kotlin的内联函数，该函数接收一系列回调并比较返回值。</p>
<h2 id="Conventions-used-for-collections-and-ranges"><a class="header-anchor" href="#Conventions-used-for-collections-and-ranges">¶</a>Conventions used for collections and ranges</h2>
<h3 id="Accessing-elements-by-index-“get”-and-“set”"><a class="header-anchor" href="#Accessing-elements-by-index-“get”-and-“set”">¶</a>Accessing elements by index: “get” and “set”</h3>
<p>Kotlin约定支持 <em>index operator</em> 下标操作符，语法和Java的数组访问类似，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> value = map[key]</span><br></pre></td></tr></table></figure>
<p>你也可以直接对其进行赋值操作，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mutableMap[key] = newValue</span><br></pre></td></tr></table></figure>
<p>Kotlin中的下标操作符，对于读取调用了<code>get</code>方法，对于写操作调用了<code>set</code>。该方法在<code>Map</code>和<code>MutableMap</code>接口早已定义。你可以在自定义类中实现，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;  <span class="comment">// Defines an operator function named &quot;get&quot;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">when</span>(index) &#123;</span><br><span class="line">    <span class="number">0</span> -&gt; x</span><br><span class="line">	<span class="number">1</span> -&gt; y</span><br><span class="line">	<span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IndexOutOfBoundsException(<span class="string">&quot;Invalid coordinate <span class="variable">$index</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> p = Point(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">&gt;&gt;&gt; println(p[<span class="number">1</span>])</span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>当调用<code>p[1]</code>时，将被翻译为<code>get</code>方法的调用。</p>
<p>需要注意的是，<code>get</code>方法的参数可以任意，例如你可以实现一个二维数组的下标读<code>operator fun get(rowIndex: Int, colIndex: Int)</code>，然后通过<code>matrix[row, col]</code>。</p>
<p><img src="/img/kotlin-in-action/chapter07/Figure_07_06.png" alt="Figure 7.6"></p>
<p>类似地，下标的写操作要求对象可变的，因此你需要声明可变的对象属性，否则更改是无意义的，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">MutablePoint</span>(<span class="keyword">var</span> x: <span class="built_in">Int</span>, <span class="keyword">var</span> y: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> MutablePoint.<span class="title">set</span><span class="params">(index: <span class="type">int</span>, value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">when</span>(index) &#123;</span><br><span class="line">    <span class="number">0</span> -&gt; x = value</span><br><span class="line">	<span class="number">1</span> -&gt; y = value</span><br><span class="line">	<span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IndexOutOfBoundsException(<span class="string">&quot;Invalid coordinate <span class="variable">$index</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> p = MutablePoint(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">&gt;&gt;&gt; p[<span class="number">1</span>] = <span class="number">42</span></span><br><span class="line">&gt;&gt;&gt; println(p)</span><br><span class="line">MutablePoint(x=<span class="number">10</span>, y=<span class="number">42</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/kotlin-in-action/chapter07/Figure_07_07.png" alt="Figure 7.7"></p>
<h3 id="The-“in”-convention"><a class="header-anchor" href="#The-“in”-convention">¶</a>The “in” convention</h3>
<p>Kotlin集合中另一个支持的操作符为<code>in</code>，用于检测对象是否被包含在集合中。对应被调用的函数是<code>contains</code>。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span>(<span class="keyword">val</span> upperLeft: Point, <span class="keyword">val</span> lowerRight: Point)</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Rectangle.<span class="title">contains</span><span class="params">(p: <span class="type">Point</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.x <span class="keyword">in</span> upperLeft.x until lowerRight.x &amp;&amp; p.y <span class="keyword">in</span> upperLeft.y until lowerRight.y  <span class="comment">// Builds range, and checks that coordinate &quot;x&quot; belongs to this range</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> rect = Rectangle(Point(<span class="number">10</span>, <span class="number">20</span>), Point(<span class="number">50</span>, <span class="number">50</span>))</span><br><span class="line">&gt;&gt;&gt; println(Point(<span class="number">20</span>, <span class="number">30</span>) <span class="keyword">in</span> rect)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt;&gt;&gt; println(Point(<span class="number">5</span>, <span class="number">5</span>) <span class="keyword">in</span> rect)</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/kotlin-in-action/chapter07/Figure_07_08.png" alt="Figure 7.8"></p>
<h3 id="The-rangeTo-convention"><a class="header-anchor" href="#The-rangeTo-convention">¶</a>The rangeTo convention</h3>
<p><code>..</code>操作符对应于<code>rangeTo</code>函数的调用，用于常见<code>Range</code>对象的实例，</p>
<p><img src="/img/kotlin-in-action/chapter07/Figure_07_09.png" alt="Figure 7.9"></p>
<p>你可以为自定义类扩展该公约。但如果你的函数继承了<code>Comparable</code>，则不需要了：因为标准库为任意的<code>Comparable</code>实例定义了Range的方法。标准库中定义的<code>rangeTo</code>函数带有泛型参数，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Comparable&lt;T&gt;</span>&gt; T.<span class="title">rangeTo</span><span class="params">(that: <span class="type">T</span>)</span></span>: ClosedRange&lt;T&gt;</span><br></pre></td></tr></table></figure>
<p>我们以<code>LocalDate</code>类为例，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> now = LocalDate.now()</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> vacation = now..now.plusDays(<span class="number">10</span>)  <span class="comment">// Creates a 10-day range starting from now</span></span><br><span class="line">&gt;&gt;&gt; println(now.plusWeeks(<span class="number">1</span>) <span class="keyword">in</span> vacation)  <span class="comment">// Checks whether a specific date belongs to range</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>表达式<code>now..now.plusDays(10)</code>被编译器翻译为<code>now.rangeTo(now.plusDays(10))</code>。<code>rangeTo</code>函数并不是<code>LocalDate</code>的成员，但是<code>Comparable</code>的扩展函数。</p>
<p>在算术操作符中，<code>rangeTo</code>操作符的优先级最低，所以最好用括号括起来以避免歧义：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> n = <span class="number">9</span></span><br><span class="line">&gt;&gt;&gt; println(<span class="number">0</span> ..(n + <span class="number">1</span>))  <span class="comment">// You can write 0..n + 1, but parentheses make it clearer.</span></span><br><span class="line"><span class="number">0.</span><span class="number">.10</span></span><br></pre></td></tr></table></figure>
<p>注意表达式<code>0..n.forEach &#123;&#125;</code>不会被编译成功，因为你必须用括号括起来才能作为表达式：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; (<span class="number">0.</span>.n).forEach &#123; print(it) &#125;  <span class="comment">// Put a range in parentheses to call a method on it.</span></span><br><span class="line">0123456789</span><br></pre></td></tr></table></figure>
<h3 id="The-“iterator”-convention-for-the-“for”-loop"><a class="header-anchor" href="#The-“iterator”-convention-for-the-“for”-loop">¶</a>The “iterator” convention for the “for” loop</h3>
<p>迭代表达式<code>for (x in list) &#123; ... &#125;</code>编译时被翻译为<code>list.iterator()</code>，和Java一样，不停地重复调用<code>hasNext</code>和<code>next</code>方法。</p>
<p>在Kotlin中它被作为convention约定，意味着<code>iterator</code>方法可以扩展定义。其中，标准库中就有对字符串的iterator的扩展定义，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> CharSequence.<span class="title">iterator</span><span class="params">()</span></span>: CharIterator</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="string">&quot;abc&quot;</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>你可以在自己的类定义<code>iterator</code>方法，例如，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> ClosedRange<span class="type">&lt;LocalDate&gt;</span>.<span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;LocalDate&gt; = <span class="keyword">object</span> : Iterator&lt;LocalDate&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> current = start</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = current &lt;= endInclusive</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span>: LocalDate = current.apply &#123; current = plusDays(<span class="number">1</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> newYear = LocalDate.ofYearDay(<span class="number">2017</span>, <span class="number">1</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> daysOff = newYear.munusDays(<span class="number">1</span>)..newYear</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> (dayOff <span class="keyword">in</span> daysOff) &#123; println(dayOff) &#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">12</span>-<span class="number">31</span></span><br><span class="line"><span class="number">2017</span>-<span class="number">01</span>-<span class="number">01</span></span><br></pre></td></tr></table></figure>
<h2 id="Destructuring-declarations-and-component-functions"><a class="header-anchor" href="#Destructuring-declarations-and-component-functions">¶</a>Destructuring declarations and component functions</h2>
<p><em>destructuring declaractions</em> ，Kotlin的声明解构作为feature实现。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> p = Point(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> (x, y) = p  <span class="comment">// Declares variables x and y, initialized with components of p</span></span><br><span class="line">&gt;&gt;&gt; println(x)</span><br><span class="line"><span class="number">10</span></span><br><span class="line">&gt;&gt;&gt; println(y)</span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>声明解构在Kotlin中也是作为convension约定，它的底层原理如下，</p>
<p><img src="/img/kotlin-in-action/chapter07/Figure_07_10.png" alt="Figure 7.10"></p>
<p>对于<code>data class</code>而言，编译器会为每个属性在primary constructor声明的属性创建相应的<code>componentN</code>函数。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>) &#123;</span><br><span class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component1</span><span class="params">()</span></span> = x</span><br><span class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component2</span><span class="params">()</span></span> = y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明解构的一个好处在于可以从一个函数中返回多个值。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">NameComponents</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> extension: String) <span class="comment">// Declares a data class to hold the values</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">splitFilename</span><span class="params">(fullName: <span class="type">String</span>)</span></span>: NameCompoents &#123;</span><br><span class="line">  <span class="keyword">val</span> result = fullName.split(<span class="string">&#x27;.&#x27;</span>, limit = <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">return</span> NameComponents(result[<span class="number">0</span>], result[<span class="number">1</span>])  <span class="comment">// Returns an instance of the data class from the function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> (name, ext) = splitFilename(<span class="string">&quot;example.kt&quot;</span>)  <span class="comment">// Uses the destructuring declaration syntax to unpack the class</span></span><br><span class="line">&gt;&gt;&gt; println(name)</span><br><span class="line">example</span><br><span class="line">&gt;&gt;&gt; println(ext)</span><br><span class="line">kt</span><br></pre></td></tr></table></figure>
<h3 id="Destructuring-declarations-and-loops"><a class="header-anchor" href="#Destructuring-declarations-and-loops">¶</a>Destructuring declarations and loops</h3>
<p>声明解构常常用于map的迭代，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printEntries</span><span class="params">(map: <span class="type">Map</span>&lt;<span class="type">String</span>, String&gt;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> ((key, value) <span class="keyword">in</span> map) &#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$key</span> -&gt; <span class="variable">$value</span>&quot;</span>)  <span class="comment">// Destructuring declaration in a loop</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> map = mapOf(<span class="string">&quot;Oracle&quot;</span> to <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JetBrains&quot;</span> to <span class="string">&quot;Kotlin&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; printEntries(map)</span><br><span class="line">Oracle -&gt; Java</span><br><span class="line">JetBrains -&gt; Kotlin</span><br></pre></td></tr></table></figure>
<h2 id="Resuing-property-accessor-logic-delegated-properties"><a class="header-anchor" href="#Resuing-property-accessor-logic-delegated-properties">¶</a>Resuing property accessor logic: delegated properties</h2>
<p>delegated properties仅属于Kotlin中的独特的强大的特性。该特性让你以最简单的方式实现属性，让其原本以更复杂的方式存储，但不会重复实现逻辑。例如，属性可以存储在数据库表、浏览器session、map中等。</p>
<p>该特性的基础是委派( <em>delegation</em> )：一种设计模式。</p>
<h3 id="Delegated-properties-the-basics"><a class="header-anchor" href="#Delegated-properties-the-basics">¶</a>Delegated properties: the basics</h3>
<p>常规的委派属性语法如下：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> p: Type <span class="keyword">by</span> Delegate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>语法格式为 <code>val /var &lt;property name&gt;: &lt;Type&gt; by &lt;expression&gt;</code>。<code>by</code>之后的表达式是一个委派，因为属性对应的<code>get()</code>和<code>set()</code>会通过约定委派给它的<code>getValue()</code>和<code>setValue()</code>方法。属性委派不需要实现接口，但需要提供<code>getValue()</code>函数(和<code>setValue()</code> 如果是<code>var</code>可变属性)。</p>
<p>例如，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> delegate = Delegate()</span><br><span class="line">  <span class="keyword">var</span> p: Type  <span class="comment">// Generated accessors of the &quot;p&quot; property call the getValue and setValue methods on &quot;delegate&quot;.</span></span><br><span class="line">    <span class="keyword">set</span>(value: Type) = delegate.setValue(..., value)</span><br><span class="line">	<span class="keyword">get</span>() = delegate.getValue(...)</span><br></pre></td></tr></table></figure>
<p>按照约定，<code>Delegate</code>类必须要有<code>getValue</code>和<code>setValue</code>方法(<code>setValue</code>仅为可变属性时被要求)。通常它们可以是成员或扩展。为了简化解析，我们省略它们的参数，<code>Delegate</code>类看起来会像，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Delegate</span> &#123;</span><br><span class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(...)</span></span> &#123; ... &#125;  <span class="comment">// The getValue method contains the logic for implementing a getter.</span></span><br><span class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(..., value: <span class="type">Type</span>)</span></span> &#123; ... &#125;  <span class="comment">// The setValue method contains the logic for implementing a setter.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> p: Type <span class="keyword">by</span> Delegate()  <span class="comment">// The &quot;by&quot; keyword asociates a property with a delegate object.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> foo = Foo()</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> oldValue = foo.p  <span class="comment">// Accessing a property foo.p calls delegate.getValue(...) under the hood.</span></span><br><span class="line">&gt;&gt;&gt; foo.p = newValue  <span class="comment">// Changing a property value calls delegate.setValue(..., newValue).</span></span><br></pre></td></tr></table></figure>
<p><code>foo.p</code>被作为常规属性使用，但底层调用了帮助类<code>Delegate</code>的方法调用。Kotlin标准库针对不同的委派模式提供了工厂方法调用。官方之为Standard delegates，包含两部分，lazy properties和observable properties。</p>
<h3 id="Using-delegated-properties-lazy-initialization-and-“by-lazy-”"><a class="header-anchor" href="#Using-delegated-properties-lazy-initialization-and-“by-lazy-”">¶</a>Using delegated properties: lazy initialization and “by lazy()”</h3>
<p><em>Lazy initialization</em> 仅在对象第一次访问时才被初始化。</p>
<p>例如，假设有一个类<code>Person</code>允许你访问他的邮箱列表。其中邮箱被存储在数据库中需要花费一段时间才能访问。你希望数据库的访问操作仅一次也第一次属性访问时才触发。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Email</span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">loadEmails</span><span class="params">(person: <span class="type">Person</span>)</span></span>: List&lt;Email&gt; &#123;</span><br><span class="line">  println(<span class="string">&quot;Load emails for <span class="subst">$&#123;person.name&#125;</span>&quot;</span>&#125;</span><br><span class="line">  <span class="keyword">return</span> listOf(<span class="comment">/*...*/</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面通过额外属性<code>_emails</code>存储<code>null</code>方式实现lazy加载的目的，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _emails List&lt;Email&gt;? = <span class="literal">null</span>  <span class="comment">// &quot;_emails&quot; property that stores the data and to which &quot;emails&quot; delegates</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">val</span> emails: List&lt;Email&gt;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">	  <span class="keyword">if</span> (_emails == <span class="literal">null</span>) &#123;</span><br><span class="line">	    _emails = loadEmails(<span class="keyword">this</span>)  <span class="comment">// Loads the data no access</span></span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">return</span> _emails!!  <span class="comment">// If the data was loaded before, returns it</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> p = Person(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; p.emails  <span class="comment">// Emails are loaded on first access.</span></span><br><span class="line">Load emails <span class="keyword">for</span> Alice</span><br><span class="line">&gt;&gt;&gt; p.emails</span><br></pre></td></tr></table></figure>
<p>但这种写法有点啰嗦，如果有好几个lazy properties需要实现会显得繁琐。另外，上述代码也不是线程安全的。</p>
<p>Kotlin标准库提供了<code>by lazy</code>的函数调用，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">  <span class="keyword">val</span> emails <span class="keyword">by</span> lazy &#123; loadEmails(<span class="keyword">this</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>lazy</code>函数返回包含<code>getValue</code>方法签名的一个对象，因此你可以结合<code>by</code>关键一起创建委派属性。这里的<code>lazy</code>的入参是一个lambda用于初始化。<code>lazy</code>函数默认是线程安全的。</p>
<h3 id="Implementing-delegated-properties"><a class="header-anchor" href="#Implementing-delegated-properties">¶</a>Implementing delegated properties</h3>
<p>下面以示例方式，阐述委派属性是如何实现的。我们希望实现最常见的事件通知类，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">PropertyChangeAware</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">val</span> changeSupport = PropertyChangeSupport(<span class="keyword">this</span>)</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">addPropertyChangeListener</span><span class="params">(listener: <span class="type">PropertyChangeListener</span>)</span></span> &#123;</span><br><span class="line">    changeSupport.addPropertyChangeListener(listener)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">removePropertyChangeListener</span><span class="params">(listener: <span class="type">PropertyChangeListener</span>)</span></span> &#123;</span><br><span class="line">    changeSupport.removePropertyChangeListener(listener)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写<code>Person</code>类，希望属性在发生变更时触发listener，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, age: <span class="built_in">Int</span>, salary: <span class="built_in">Int</span>): PropertyChangeAware() &#123;</span><br><span class="line">  <span class="keyword">var</span> age: <span class="built_in">Int</span> = age</span><br><span class="line">    <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">      <span class="keyword">val</span> oldValue = field  <span class="comment">// The &quot;field&quot; identifier lets you access the property backing field.</span></span><br><span class="line">      field = newValue</span><br><span class="line">      changeSupport.firePropertyChange(<span class="string">&quot;age&quot;</span>, oldValue, newValue)  <span class="comment">// Notifies listeners about the property change</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> salary: <span class="built_in">Int</span> = salary</span><br><span class="line">    <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">      <span class="keyword">val</span> oldValue = field</span><br><span class="line">      field = newValue</span><br><span class="line">      changeSupport.firePropertyChange(<span class="string">&quot;salary&quot;</span>, oldValue, newValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> p = Person(<span class="string">&quot;Dmitry&quot;</span>, <span class="number">34</span>, <span class="number">2000</span>)</span><br><span class="line">&gt;&gt;&gt; p.addPropertyChangeListener(</span><br><span class="line">...  PropertyChangeListener &#123; event -&gt;  <span class="comment">// Attaches a property change listener</span></span><br><span class="line">...    println(<span class="string">&quot;Property <span class="subst">$&#123;event.propertyName&#125;</span> changed &quot;</span> + <span class="string">&quot;from <span class="subst">$&#123;event.oldValue&#125;</span> to <span class="subst">$&#123;event.newValue&#125;</span>&quot;</span>)</span><br><span class="line">...  &#125;</span><br><span class="line">... )</span><br><span class="line">&gt;&gt;&gt; p.age = <span class="number">35</span></span><br><span class="line">Property age changed from <span class="number">34</span> to <span class="number">35</span></span><br><span class="line">&gt;&gt;&gt; p.salary = <span class="number">2100</span></span><br><span class="line">Property salary changed from <span class="number">2000</span> to <span class="number">2100</span></span><br></pre></td></tr></table></figure>
<p>这里的setter部分代码有许多重复的地方。我们通过委派方式将其分离出单独一个类，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObservableProperty</span>(<span class="keyword">val</span> propName: String, <span class="keyword">var</span> propValue: <span class="built_in">Int</span>, <span class="keyword">val</span> changeSupport: PropertyChangeSupport) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">()</span></span>: <span class="built_in">Int</span> = propValue</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(newValue: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> oldValue = propValue</span><br><span class="line">	propValue = newValue</span><br><span class="line">	changeSupport.firePropertyChange(propName, oldValue, newValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, age: <span class="built_in">Int</span>, salary: <span class="built_in">Int</span>) : PropertyChangeAware() &#123;</span><br><span class="line">  <span class="keyword">val</span> _age = ObservableProperty(<span class="string">&quot;age&quot;</span>, age, changeSupport)</span><br><span class="line">  <span class="keyword">var</span> age: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = _age.getValue()</span><br><span class="line">    <span class="keyword">set</span>(value) &#123; _age.setValue(value) &#125;</span><br><span class="line">  <span class="keyword">val</span> _salary = ObservableProperty(<span class="string">&quot;salary&quot;</span>, salary, changeSupport)</span><br><span class="line">  <span class="keyword">var</span> salary: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = _salary.getValue()</span><br><span class="line">    <span class="keyword">set</span>(value) &#123; _salary.setValue(value) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在已经接近理解kotlin的委派属性是如何工作的了。但仍然有少许的样板代码，kotlin的委派属性的特性让你可以移除掉这部分样板代码(boilerplate)。在此之前，你需要按照约定，更改<code>ObservableProperty</code>相关方法的签名。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObservableProperty</span>(<span class="keyword">var</span> porpValue: <span class="built_in">Int</span>, <span class="keyword">val</span> changeSupport: PropertyChangeSupport) &#123;</span><br><span class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(p: <span class="type">Person</span>, prop: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: <span class="built_in">Int</span> = propValue</span><br><span class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(p: <span class="type">Person</span>, prop: <span class="type">KProperty</span>&lt;*&gt;, newValue: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> oldValue = propValue</span><br><span class="line">	propValue = newValue</span><br><span class="line">	changeSupport.firePropertyChange(prop.name, oldValue, newValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比上一个版本，有如下改变，</p>
<ul>
<li><code>getValue</code>和<code>setValue</code>函数标记有<code>operator</code>，按照约定要求。</li>
<li>这些函数有两个参数：一个是该属性的实例对象，另一个是属性自身。该属性用<code>KProperty</code>的一个对象表示。你可以通过<code>KProperty.name</code>访问属性名。</li>
<li><code>name</code>属性从第一构造函数(primary constructor)移除掉了，因为你可以从<code>KProperty</code>直接访问。</li>
</ul>
<p>最终的委派属性的使用将变得非常简短，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, age: <span class="built_in">Int</span>, salary: <span class="built_in">Int</span>): PropertyChangeAware() &#123;</span><br><span class="line">  <span class="keyword">var</span> age: <span class="built_in">Int</span> <span class="keyword">by</span> ObservableProperty(age, changeSupport)</span><br><span class="line">  <span class="keyword">var</span> salary: <span class="built_in">Int</span> <span class="keyword">by</span> ObservableProperty(salary, changeSupport)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>by</code>关键字，kotlin编译器自动地做了前面版本本应手动要做的部分。对比前面的<code>Person</code>类：编译器生成的代码非常相似。<code>by</code>右边的对象被称为 <em>delegate</em> 。kotlin将委派存储在一个隐藏属性，通过委派上的<code>getValue</code>和<code>setValue</code>的调用来修改或访问原来的属性。</p>
<p>如其手写这个<code>ObservableProperty</code>类，不妨使用Kotlin的标准库，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> (<span class="keyword">val</span> name: String, age: <span class="built_in">Int</span>, salary: <span class="built_in">Int</span>): PropertyChangeAware() &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> observer = &#123;</span><br><span class="line">    prop: KProperty&lt;*&gt;, oldValue: <span class="built_in">Int</span>, newValue: <span class="built_in">Int</span> -&gt; </span><br><span class="line">	changeSupport.firePropertyChange(prop.name, oldValue, newValue)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> age: <span class="built_in">Int</span> <span class="keyword">by</span> Delegates.observable(age, observer)</span><br><span class="line">  <span class="keyword">var</span> salary: <span class="built_in">Int</span> <span class="keyword">by</span> Delegates.observable(salary, observer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>by</code>右边的表达式不需要创建新的实例。可以是一个函数调用。只要该表达式的值对象是能被编译器调用<code>getValue</code>和<code>setValue</code>即可。</p>
<h3 id="Delegated-property-translation-rules"><a class="header-anchor" href="#Delegated-property-translation-rules">¶</a>Delegated-property translation rules</h3>
<p>让我们总结下委派属性是如何工作的。假设你的类包含如下委派属性：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> prop: Type <span class="keyword">by</span> MyDelegate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> c = C()</span><br></pre></td></tr></table></figure>
<p><code>MyDelegate()</code>的实例将被存储在一个隐藏属性，我们将其作为 <code>&lt;delegate&gt;</code>引用。编译器将使用一个<code>KProperty</code>类型的对象来表示该属性。我们将其作为 <code>&lt;property&gt;</code>引用。</p>
<p>编译器会生成如下代码，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> &lt;delegate&gt; = MyDelegate()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> prop: Type</span><br><span class="line">    <span class="keyword">get</span>() = &lt;delegate&gt;.getValue(<span class="keyword">this</span>, &lt;property&gt;)</span><br><span class="line">	<span class="keyword">set</span>(value: Type) = &lt;delegate&gt;.setValue(<span class="keyword">this</span>, &lt;property&gt;, value)</span><br></pre></td></tr></table></figure>
<p>因此，每个属性访问器(property accessor)内部，编译器生成相应的<code>getValue</code>和<code>setValue</code>方法进行调用，结构如下，</p>
<p><img src="/img/kotlin-in-action/chapter07/Figure_07_11.png" alt="Figure 7.11"></p>
<h3 id="Storing-property-values-in-a-map"><a class="header-anchor" href="#Storing-property-values-in-a-map">¶</a>Storing property values in a map</h3>
<p>委派属性带来的另外一个常见模式是，对象拥有了动态定义的属性。这类对象有时被称为 <em>expando objects</em> 。例如，假设有一个联系人管理系统存储了联系人的任意信息。系统中的每个人仅包含一少部分属性，也包含有一少部分额外的属性(attribute)(例如，孩提期生日)。</p>
<p>实现该系统的一种方式是将联系人的所有attribute都存储在一个map，并提供访问该信息的对应属性(property)。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> _attributes = hashMapOf&lt;String, String&gt;()</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">setAttribute</span><span class="params">(attrName: <span class="type">String</span>, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    _attributes[attrName] = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> name: String</span><br><span class="line">    <span class="keyword">get</span>() = _attributes[<span class="string">&quot;name&quot;</span>]!!  <span class="comment">// Retrieves the attribute from the map manually</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> p = Person()</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> <span class="keyword">data</span> = mapOf(<span class="string">&quot;name&quot;</span> to <span class="string">&quot;Dmitry&quot;</span>, <span class="string">&quot;company&quot;</span> to <span class="string">&quot;JetBrains&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> ((attrName, value) <span class="keyword">in</span> <span class="keyword">data</span>)</span><br><span class="line">...   p.setAttribute(attrName, value)</span><br><span class="line">&gt;&gt;&gt; println(p.name)</span><br><span class="line">Dmitry</span><br></pre></td></tr></table></figure>
<p>简化代码的实现，使用<code>by</code>关键字委派属性，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> _attributes = hashMapOf&lt;String, String&gt;()</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">setAttribute</span><span class="params">(attrName: <span class="type">String</span>, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    _attributes[attrName] = value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> name: String <span class="keyword">by</span> _attributes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是可以工作的，因为标准库为<code>Map</code>和<code>MutableMap</code>接口提供了<code>getValue</code>和<code>setValue</code>的扩展函数。</p>
<h3 id="Delegated-properties-in-frameworks"><a class="header-anchor" href="#Delegated-properties-in-frameworks">¶</a>Delegated properties in frameworks</h3>
<p>对于一个object内部的property修改也极其简单。假设数据库表<code>Users</code>包含两列：字符串类型<code>name</code>、整型<code>age</code>。Kotlin<br>
的定义如下，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.jetbrains.exposed.dao.IntEntity</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.exposed.dao.id.EntityID</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.exposed.dao.id.IntIdTable</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> Users : IntIdTable() &#123;  <span class="comment">// The object corresponds to a table in the database.</span></span><br><span class="line">  <span class="keyword">val</span> name = varchar(<span class="string">&quot;name&quot;</span>, length = <span class="number">50</span>).index()  <span class="comment">// Properties correspond to columns in this table.</span></span><br><span class="line">  <span class="keyword">val</span> age = integer(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(id: EntityID&lt;<span class="built_in">Int</span>&gt;) : IntEntity(id) &#123;  <span class="comment">// Each instance of User corresponds to a specific entity in the table.</span></span><br><span class="line">  <span class="keyword">var</span> name: String <span class="keyword">by</span> Users.name  <span class="comment">// The value of &quot;name&quot; is the value stored in the database for that user.</span></span><br><span class="line">  <span class="keyword">var</span> age: <span class="built_in">Int</span> <span class="keyword">by</span> Users.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>框架exposed对于实体类属性(attribute)实现了委派属性，使用了列对象(<code>Users.name, Users.age</code>)进行委派：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(id: EntityID): IntEntity(id) &#123;</span><br><span class="line">  <span class="keyword">var</span> name: String <span class="keyword">by</span> Users.name  <span class="comment">// Users.name is a delegate for the &quot;name&quot; property.</span></span><br><span class="line">  <span class="keyword">var</span> age: <span class="built_in">Int</span> <span class="keyword">by</span> Users.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而对于现实指定的数据库列对象，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Users : IntIdTable() &#123;</span><br><span class="line">  <span class="keyword">val</span> name = varchar(<span class="string">&quot;name&quot;</span>, length = <span class="number">50</span>).index()</span><br><span class="line">  <span class="keyword">val</span> age = integer(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>框架底层定义了convention进行委派，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Column<span class="type">&lt;T&gt;</span>.<span class="title">getValue</span><span class="params">(o: <span class="type">Entity</span>, desc: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">  <span class="comment">// retrieve the value from the database</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Column<span class="type">&lt;T&gt;</span>.<span class="title">setValue</span><span class="params">(o: <span class="type">Entity</span>, desc: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// update the value in the database</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以使用<code>Column</code>属性(<code>Users.name</code>)作为被委派的属性(<code>name</code>)。</p>
<h2 id="Summary"><a class="header-anchor" href="#Summary">¶</a>Summary</h2>
<ul>
<li>Kotlin的约定(convention)定义了一些标准函数，可以让你对其进行重载以实现自定义类的operations。</li>
<li>comparison operator对应会调用到<code>equals</code>和<code>compareTo</code>方法。</li>
<li>通过定义<code>get</code>、<code>set</code>和<code>contains</code>函数，你可以在自定义的类进行类似于集合的<code>[]</code>和<code>in</code>的操作。</li>
<li>Kotlin的约定(convention)也支持集合Range的迭代语法。</li>
<li>声明解构(destructuring declarations)可以让你初始化多个值，它的底层也是一种约定，对应调用了代码编译器生成的<code>componentN</code>函数。</li>
<li>委派属性(delegated property)允许属性部分逻辑的重用，譬如存储、初始化、访问、修改等。</li>
<li><code>lazy</code>标准库函数提供了属性的lazily initialized。</li>
<li><code>Delegates.observalbe</code>函数定义在标准库中，实现了观察者模式。</li>
</ul>
</div></article><nav class="article-nav"><div class="article-nav-prev"><a href="/2021/12/27/kotlin/07_higher-order_functions~lambdas_as_parameters_and_return_values/">高阶函数：lambda作为参数和返回</a></div><div class="article-nav-next"><a href="/2021/12/10/kotlin/05_the_kotlin_type_system/">Kotlin 的类型系统</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2021/12/17/kotlin/06_operator_overloading_and_other_convertions/';
var disqus_title = 'Operator overloading and other conventions';
var disqus_url = 'https://galudisu.info/2021/12/17/kotlin/06_operator_overloading_and_other_convertions/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>