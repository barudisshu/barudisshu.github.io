<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>高阶函数：lambda作为参数和返回</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">高阶函数：lambda作为参数和返回</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2021-12-27</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/kotlin/">kotlin</a></p></div><div class="article-content"><h2 id="主要内容"><a class="header-anchor" href="#主要内容">¶</a>主要内容</h2>
<ol>
<li>函数类型</li>
<li>高阶函数以及其结构化代码</li>
<li>内联函数</li>
<li>非本地返回以及标签</li>
<li>匿名函数</li>
</ol>
<p><em>higher-order functions</em> ， 高阶函数，指函数包含lambda入参或lambda作为返回值的函数。</p>
<span id="more"></span>
<h2 id="Declaring-higher-order-functions"><a class="header-anchor" href="#Declaring-higher-order-functions">¶</a>Declaring higher-order functions</h2>
<p>Kotlin中，函数可以被表述为lambda或函数的值的引用。因此，一个高阶函数可以是任何函数，它包含lambda表达式或函数。譬如，标准库中的<code>filter</code>定义为高阶函数：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.filter &#123; x &gt; <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure>
<p>前面已经介绍过了Kotlin标准库常见的几个高阶类型：<code>map</code>、<code>with</code>等。要声明自定义高阶函数，首先必须引入 <em>函数类型(function types)</em> 。</p>
<h3 id="Function-types"><a class="header-anchor" href="#Function-types">¶</a>Function types</h3>
<p>为了声明一个函数的入参为lambda，你需要知道如何声明对应的参数类型。它的显式声明格式如下：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123; x, y -&gt; x + y &#125;  <span class="comment">// Function that takes two Int parameters and returns an Int value</span></span><br><span class="line"><span class="keyword">val</span> action: () -&gt; <span class="built_in">Unit</span> = &#123; println(<span class="number">42</span>) &#125;  <span class="comment">// Function that takes no arguments and doesn&#x27;t return a value</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/kotlin-in-action/chapter08/Figure_08_01.png" alt="Figure 8.1"></p>
<p>因为函数类型中已经指定了参数，所以lambda中的声明部分可以省略入参类型。</p>
<p>和其它函数一样，一个函数类型的返回类型可以被标识为可空的(nullable)：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canReturnNull: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span>? = &#123; <span class="literal">null</span> &#125;</span><br></pre></td></tr></table></figure>
<p>又或者标识为可空的函数类型，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funOrNull: ((<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span>)? = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<h3 id="Calling-functions-passed-as-arguments"><a class="header-anchor" href="#Calling-functions-passed-as-arguments">¶</a>Calling functions passed as arguments</h3>
<p>高阶函数的声明形式如下，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">twoAndThree</span><span class="params">(operation: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>)</span></span> &#123;  <span class="comment">// Declares a parameter of a function type</span></span><br><span class="line">  <span class="keyword">val</span> result = operation(<span class="number">2</span>, <span class="number">3</span>)  <span class="comment">// Calls the parameter of a function type</span></span><br><span class="line">  println(<span class="string">&quot;The result is <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; twoAndThree &#123; a, b -&gt; a + b &#125;</span><br><span class="line">The result <span class="keyword">is</span> <span class="number">5</span></span><br><span class="line">&gt;&gt;&gt; twoAndThree &#123; a, b -&gt; a * b &#125;</span><br><span class="line">The result <span class="keyword">is</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>函数作为入参的语法如下，</p>
<p><img src="/img/kotlin-in-action/chapter08/Figure_08_02.png" alt="Figure 8.2"></p>
<p><code>filter</code>函数接收一个predicate作为入参。<code>predicate</code>的类型是一个函数，接收字符串并返回一个<code>boolean</code>结果。</p>
<p>下面是它的完整实现，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">filter</span><span class="params">(predicate: (<span class="type">Char</span>) -&gt; <span class="type">Boolean</span>)</span></span>: String &#123;</span><br><span class="line">  <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">  <span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">0</span> until length) &#123;</span><br><span class="line">    <span class="keyword">val</span> element = <span class="keyword">get</span>(index)</span><br><span class="line">	<span class="keyword">if</span> (predicate(element)) sb.append(element)  <span class="comment">// Calls the function passed as the argument for the &quot;predicate&quot; parameter</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sb.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(<span class="string">&quot;ab1c&quot;</span>.filter &#123; it <span class="keyword">in</span> <span class="string">&#x27;a&#x27;</span>..<span class="string">&#x27;z&#x27;</span> &#125;)  <span class="comment">// Passes a lambda as anargument for &quot;predicate&quot;</span></span><br><span class="line">abc</span><br></pre></td></tr></table></figure>
<h3 id="Default-and-null-values-for-parameters-with-function-types"><a class="header-anchor" href="#Default-and-null-values-for-parameters-with-function-types">¶</a>Default and null values for parameters with function types</h3>
<p>声明函数类型参数时，可以指定一个默认值。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Collection<span class="type">&lt;T&gt;</span>.<span class="title">joinToString</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  separator: <span class="type">String</span> = <span class="string">&quot;, &quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  prefix: <span class="type">String</span> = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  postfix: <span class="type">String</span> = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  transform: (<span class="type">T</span>) -&gt; <span class="type">String</span> = &#123; it.toString()</span></span> &#125;  <span class="comment">// Declares a parameter of a function type with a lambda as a default value</span></span><br><span class="line">): String &#123;</span><br><span class="line">  <span class="keyword">val</span> result = StringBuilder(prefix)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> ((index, element) <span class="keyword">in</span> <span class="keyword">this</span>.withIndex()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">0</span>) result.append(separator)</span><br><span class="line">	result.append(transform(element))  <span class="comment">// Calls the function passed as an argument for the &quot;transform&quot; parameter</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  result.append(postfix)</span><br><span class="line">  <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> letters = listOf(<span class="string">&quot;Alpha&quot;</span>, <span class="string">&quot;Beta&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; println(letters.joinToString())  <span class="comment">// Uses the default conversion function</span></span><br><span class="line">Alpha, Beta</span><br><span class="line">&gt;&gt;&gt; println(letters.joinToString &#123; it.toLowerCase() &#125;)  <span class="comment">// Passes a lambda as an argument</span></span><br><span class="line">Alpha, beta</span><br><span class="line">&gt;&gt;&gt; println(letters.joinToString(separator = <span class="string">&quot;! &quot;</span>, postfix = <span class="string">&quot;! &quot;</span>,</span><br><span class="line">...		transform = &#123; it.toUpperCase() &#125;))  <span class="comment">// Uses the named argument syntax for passing several arguments including a lambda</span></span><br><span class="line">ALPHA! BETA!</span><br></pre></td></tr></table></figure>
<p>这里的函数包含泛型：类型参数<code>T</code>，<code>transform</code>接收该泛型参数。函数类型参数默认值的写法和普通参数默认值的语法一直，在等号后面声明。</p>
<p>另外，入参部分也可以为可空的，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(callback: (() -&gt; <span class="type">Unit</span>)?)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (callback != <span class="literal">null</span>) &#123;</span><br><span class="line">    callback()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个更简单的版本是，函数类型是包含接口<code>invoke</code>方法的一个实现。作为常规方法，可以通过<code>callback?.invoke()</code>的形式调用。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Collection<span class="type">&lt;T&gt;</span>.<span class="title">joinToString</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	separator: <span class="type">String</span> = <span class="string">&quot;, &quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	prefix: <span class="type">String</span> = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	postfix: <span class="type">String</span> = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	transform: ((<span class="type">T</span>) -&gt; <span class="type">String</span>)? = <span class="literal">null</span>  <span class="comment">// Declares a nullable parameter of a function type</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: String &#123;</span><br><span class="line">  <span class="keyword">val</span> result = StringBuilder(prefix)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> ((index, element) <span class="keyword">in</span> <span class="keyword">this</span>.withIndex()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">0</span>) result.append(separator)</span><br><span class="line">	<span class="keyword">val</span> str = transform?.invoke(element) ?: element.toString()  <span class="comment">// safe-call syntax to call the function</span></span><br><span class="line">	result.append(str)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  result.append(postfix)</span><br><span class="line">  <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Returning-functions-from-functions"><a class="header-anchor" href="#Returning-functions-from-functions">¶</a>Returning functions from functions</h3>
<p>一个函数返回另外一个函数的场景并不常见，但某些需要实时计算的场景很有用。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Delivery</span> &#123; STANDARD, EXPEDITED &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>(<span class="keyword">val</span> itemCount: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getShippingCostCalculator</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	delivery: <span class="type">Delivery</span>)</span></span>: (Order) -&gt; <span class="built_in">Double</span> &#123;  <span class="comment">// Declares a function that returns a function</span></span><br><span class="line">  <span class="keyword">if</span> (delivery == Delivery.EXPEDITED) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; order -&gt; <span class="number">6</span> + <span class="number">2.1</span> * order.itemCount &#125;  <span class="comment">// Returns lambdas from the function</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123; order -&gt; <span class="number">1.2</span> * order.itemCount &#125;  <span class="comment">// Returns lambdas</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> calculator = getShippingCostCalculator(Delivery.EXPEDITED)  <span class="comment">// Stores the returned function in a variable</span></span><br><span class="line">&gt;&gt;&gt; println(<span class="string">&quot;Shipping costs <span class="subst">$&#123;calculator(Order(<span class="number">3</span>))&#125;</span>&quot;</span>)  <span class="comment">// Invokes the returned function</span></span><br><span class="line">Shipping costs <span class="number">12.3</span></span><br></pre></td></tr></table></figure>
<p>函数作为返回，使用<code>return</code>关键字带上一个lambda、函数类型的成员引用、或函数类型的表达式(譬如本地变量)。</p>
<p>下面是另外一个例子。假设你有一个GUI联系人应用，你需要决定哪些联系人应该在UI上显式。UI界面允许你输入字符串进行过滤；也允许你隐藏不包含某些字段的联系人。你的对象数据如下：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ContactListFilters</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> prefix: String = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="keyword">var</span> onlyWithPhoneNumber: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当用户在界面上敲入<code>D</code>，<code>prefix</code>的值被更新。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(</span><br><span class="line">	<span class="keyword">val</span> firstName: String,</span><br><span class="line">	<span class="keyword">val</span> lastName: String,</span><br><span class="line">	<span class="keyword">val</span> phoneNumber: String?</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContactListFilters</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> prefix: String = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="keyword">var</span> onlyWithPhoneNumber: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getPredicate</span><span class="params">()</span></span>: (Person) -&gt; <span class="built_in">Boolean</span> &#123;  <span class="comment">// Declares a function that returns a function</span></span><br><span class="line">    <span class="keyword">val</span> startsWithPrefix = &#123; p: Person -&gt;</span><br><span class="line">	  p.firstName.startsWith(prefix) || p.lastName.startsWith(prefix)</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span> (!onlyWithPhoneNumber) &#123;</span><br><span class="line">	  <span class="keyword">return</span> startsWithPrefix  <span class="comment">// 返回函数类型的一个变量</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> &#123; startsWithPrefix(it)</span><br><span class="line">				&amp;&amp; it.phoneNumber != <span class="literal">null</span> &#125;  <span class="comment">// 返回lambda表达式</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> contacts = listOf(Person(<span class="string">&quot;Dmitry&quot;</span>, <span class="string">&quot;Jemerov&quot;</span>, <span class="string">&quot;123-4567&quot;</span>),</span><br><span class="line">						Person(<span class="string">&quot;Svetlana&quot;</span>, <span class="string">&quot;Isakova&quot;</span>, <span class="literal">null</span>))</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> contactListFilters = ContactLIstFilters()</span><br><span class="line">&gt;&gt;&gt; with (contactListFilters) &#123;</span><br><span class="line">&gt;&gt;&gt;   prefix = <span class="string">&quot;Dm&quot;</span></span><br><span class="line">&gt;&gt;&gt;   onlyWithPhoneNumber = <span class="literal">true</span></span><br><span class="line">&gt;&gt;&gt; &#125;</span><br><span class="line">&gt;&gt;&gt; println(contacts.filter(</span><br><span class="line">...		contactListFilters.getPredicate()))  <span class="comment">// 函数作为参数形式传递</span></span><br><span class="line">[Person(firstName=Dmitry, lastName=Jemerov, phoneNumber=<span class="number">123</span>-<span class="number">4567</span>)]</span><br></pre></td></tr></table></figure>
<p><code>getPredicate</code>方法返回一个函数值，并作为参数传递给<code>filter</code>函数。</p>
<h3 id="Removing-duplication-through-lambdas"><a class="header-anchor" href="#Removing-duplication-through-lambdas">¶</a>Removing duplication through lambdas</h3>
<p>(误，原文思想错误，重复代码并不是通过lambda解决的，代码重构和clean code才是；kotlin的lambda并不能带来clean code的作用)</p>
<h2 id="Inline-functions-removing-the-overhead-of-lambdas"><a class="header-anchor" href="#Inline-functions-removing-the-overhead-of-lambdas">¶</a>Inline functions: removing the overhead of lambdas</h2>
<h3 id="How-inlining-works"><a class="header-anchor" href="#How-inlining-works">¶</a>How inlining works</h3>
<p>当声明一个函数为<code>inline</code>，它的body部分是内联的——换句话说，内联函数的语句体会在它真正被调用的地方直接替代。</p>
<p>譬如我们要确保多线程并发时资源不共享。函数使用<code>Lock</code>对象，执行代码块后，最后释放锁。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">synchronized</span><span class="params">(lock: <span class="type">Lock</span>, action: () -&gt; <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">  lock.lock()</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> action()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> l = Lock()</span><br><span class="line">synchronized(l) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于你声明的<code>synchronized</code>函数作为<code>inline</code>，编译生成的代码等价于Java的<code>synchronized</code>语句，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(l: <span class="type">Lock</span>)</span></span> &#123;</span><br><span class="line">  println(<span class="string">&quot;Before sync&quot;</span>)</span><br><span class="line">  synchronized(l) &#123;</span><br><span class="line">    println(<span class="string">&quot;Action&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  println(<span class="string">&quot;After sync&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译的字节码等价于，</p>
<p><img src="/img/kotlin-in-action/chapter08/Figure_08_03.png" alt="Figure 8.3"></p>
<p>内联函数也可以作为参数传递，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockOwner</span>(<span class="keyword">val</span> lock: Lock) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">runUnderLock</span><span class="params">(body: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    synchronized(lock, body)  <span class="comment">// A variable of a function type is passed as an argument, not a lambda.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的lambda表达式并不可用，因此它不是内联的。只有<code>synchronized</code>函数体才是内联的；lambda表达式还是常规的调用形式。<code>runUnderLock</code>函数编译对应的字节码形式如下，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockOwner</span>(<span class="keyword">val</span> lock: Lock) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">__runUnderLock__</span><span class="params">(body: () -&gt; <span class="type">Unit</span>)</span></span> &#123;  <span class="comment">// This function is similar to the bytecode the real runUnderLOck is compiled to.</span></span><br><span class="line">    lock.lock()</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	  body()  <span class="comment">// The body isn&#x27;t inlined, because there&#x27;s no lambda at the invocation.</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">	  lock.unlock()</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果包含有两个内联函数放置在不同的lambda表达式，每个内联函数的调用仍然是独立的。内联函数的语句体代码会被拷贝到相应的lambda位置中。</p>
<h3 id="Restrictions-on-inline-functions"><a class="header-anchor" href="#Restrictions-on-inline-functions">¶</a>Restrictions on inline functions</h3>
<p>基于内联函数的执行方式，不是所有用到lambda的函数都可以内联。如果函数是内联的，lambda表达式的语句体将被作为参数直接替换到返回代码中。这种约束可能用于函数对应的传参上。如果该参数被调用，函数代码就可以轻松实现内联。但如果该参数被存储在其它地方，lambda表达式部分的代码就不能被内联，因为必须在函数内部要有一个对象容纳这些代码。</p>
<p>通常地，参数可以被内联的条件是它被直接调用或以参数的形式传递给另外一个<code>inline</code>函数。否则，编译器将阻止参数的内联并抛出错误信息&quot;Illegal usage of inline-parameter.&quot;。</p>
<p>例如，<code>Sequence.map</code>函数如下定义，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> Sequence<span class="type">&lt;T&gt;</span>.<span class="title">map</span><span class="params">(transform: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: Sequence&lt;R&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> TransformingSequence(<span class="keyword">this</span>, transform)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>map</code>函数并没有直接调用到入参函数<code>transform</code>。相反，它将它传递给了构造函数，并存储为属性。为了实现标准库的<code>map</code>方法，应该标明让编译器不对其进行内联，你可以使用<code>noinline</code>修改器进行修饰，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(inlined: () -&gt; <span class="type">Unit</span>, <span class="keyword">noinline</span> notInlined: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意编译器完全支持内联实现，可以跨module、跨函数定义、跨第三方库。也可以在Java中调用内联函数；不过改调用不会被内联，而是被编译成常规函数调用。</p>
<h3 id="Inlining-collection-operations"><a class="header-anchor" href="#Inlining-collection-operations">¶</a>Inlining collection operations</h3>
<p>Kotlin标准库中的集合相关函数都是实现了<code>inline</code>，目的是为了更好的性能。</p>
<h3 id="Deciding-when-to-declare-functions-as-inline"><a class="header-anchor" href="#Deciding-when-to-declare-functions-as-inline">¶</a>Deciding when to declare functions as inline</h3>
<h3 id="Using-inlined-lambdas-for-resource-management"><a class="header-anchor" href="#Using-inlined-lambdas-for-resource-management">¶</a>Using inlined lambdas for resource management</h3>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readFirstLineFromFile</span><span class="params">(path: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">  BufferedReader(FileReader(path)).use &#123; br -&gt;</span><br><span class="line">    <span class="keyword">return</span> br.readLine()  <span class="comment">// Returns the line from the function</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Control-flow-in-higher-rder-functions"><a class="header-anchor" href="#Control-flow-in-higher-rder-functions">¶</a>Control flow in higher-rder functions</h2>
<h3 id="Return-statements-in-lambdas-return-from-an-enclosing-function"><a class="header-anchor" href="#Return-statements-in-lambdas-return-from-an-enclosing-function">¶</a>Return statements in lambdas: return from an enclosing function</h3>
<p>高级函数可以返回闭包语句，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> people = listOf(Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">29</span>), Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">31</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lookForAlice</span><span class="params">(people: <span class="type">List</span>&lt;<span class="type">Person</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (person <span class="keyword">in</span> people) &#123;</span><br><span class="line">    <span class="keyword">if</span> (person.name == <span class="string">&quot;Alice&quot;</span>) &#123;</span><br><span class="line">	  println(<span class="string">&quot;Found!&quot;</span>)</span><br><span class="line">	  <span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  println(<span class="string">&quot;Alice is not found&quot;</span>)  <span class="comment">// This line is printed if there&#x27;s no Alice among &quot;people&quot;.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; lookForAlice(people)</span><br><span class="line">Found!</span><br></pre></td></tr></table></figure>
<p><code>forEach</code>部分可以进行重写，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lookForAlice</span><span class="params">(people: <span class="type">List</span>&lt;<span class="type">Person</span>&gt;)</span></span> &#123;</span><br><span class="line">  people.forEach &#123;</span><br><span class="line">    <span class="keyword">if</span> (it.name == <span class="string">&quot;Alice&quot;</span>) &#123;</span><br><span class="line">	  println(<span class="string">&quot;Found!&quot;</span>)</span><br><span class="line">	  <span class="keyword">return</span>  <span class="comment">// Returns from a function</span></span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  println(<span class="string">&quot;Alice is not found&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你在一个lambda中使用<code>return</code>关键字，<em>returns from the function in which you called the lambda</em> 返回的是函数签名部分，而不是lambda自身。这种<code>return</code>语句被称为 <em>非本地返回(non-local return)</em> 。</p>
<h3 id="Returning-from-lambdas-return-with-a-label"><a class="header-anchor" href="#Returning-from-lambdas-return-with-a-label">¶</a>Returning from lambdas: return with a label</h3>
<p>如果要另上述代码实现 <em>本地返回(local return)</em> 语义，你需要使用<code>label</code>关键字，也就是标签，语法上在<code>return</code>关键字之后。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lookForAlice</span><span class="params">(people: <span class="type">List</span>&lt;<span class="type">Person</span>&gt;)</span></span> &#123;</span><br><span class="line">  people.forEach <span class="symbol">label@</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (it.name == <span class="string">&quot;Alice&quot;</span>) <span class="keyword">return</span><span class="symbol">@label</span>  <span class="comment">// return@label refers to this label.</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(<span class="string">&quot;Alice might be somewhere&quot;</span>)  <span class="comment">// This line is always printed.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; lookForAlice(people)</span><br><span class="line">Alice might be somewhere</span><br></pre></td></tr></table></figure>
<p>为了label一个lambda表达式，将标签名(可以是任意唯一标识)，跟随在<code>@</code>字符之后，在lambda开括号之前。然后要在lambda表达式内返回，<code>return</code>关键字之后带上<code>@</code>字符+标签标识。如下图：</p>
<p><img src="/img/kotlin-in-action/chapter08/Figure_08_04.png" alt="Figure 8.4"></p>
<p>非传统方式，你可以直接使用接收lambda参数的函数名，作为本地标签使用，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lookForAlice</span><span class="params">(people: <span class="type">List</span>&lt;<span class="type">Person</span>&gt;)</span></span> &#123;</span><br><span class="line">  people.forEach &#123;</span><br><span class="line">    <span class="keyword">if</span> (it.name == <span class="string">&quot;Alice&quot;</span>) <span class="keyword">return</span><span class="symbol">@forEach</span>  <span class="comment">// return@forEach returns from the lambda expression.</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(<span class="string">&quot;Alice might be somewhere&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，一个函数表达式里面最多只能使用一个标签；如果显式指定了label标签名，就必须使用<code>return@label</code>的形式。</p>
<blockquote>
<p><strong>Labeled “this” expression</strong></p>
<p><code>this</code>表达式也可加标签。如果lambda表达式指定了<code>this</code>的receiver，通过<code>this@label</code>表达式实际访问了它的隐式receiver：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; println(StringBuilder().apply <span class="symbol">sb@</span> &#123;  <span class="comment">// This lambda&#x27;s implicit receiver is accessed by this@sb.</span></span><br><span class="line">...  listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).apply &#123;  <span class="comment">// &quot;this&quot; refers to the closest implici receiver in the scope.</span></span><br><span class="line">...    <span class="keyword">this</span><span class="symbol">@sb</span>.append(<span class="keyword">this</span>.toString())  <span class="comment">// All implicit receivers can be accessed, the outer ones via explicit labels.</span></span><br><span class="line">...   &#125;</span><br><span class="line">... &#125;)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>你可以指定lambda表达式的label，或者使用函数名代替。</p>
</blockquote>
<p>non-local return的语法有点啰嗦，如果一个lambda表达式又有多个return表达式的话。为了解决这个问题，kotlin引入了匿名函数(anonymous functions)。</p>
<h3 id="Anonymous-functions-local-returns-by-default"><a class="header-anchor" href="#Anonymous-functions-local-returns-by-default">¶</a>Anonymous functions: local returns by default</h3>
<p>匿名函数默认之后local return。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lookForAlice</span><span class="params">(people: <span class="type">List</span>&lt;<span class="type">Person</span>&gt;)</span></span> &#123;</span><br><span class="line">  people.forEach(<span class="function"><span class="title">fun</span> <span class="params">(person)</span></span> &#123;  <span class="comment">// Uses an anonymous function instead of a lambda expression</span></span><br><span class="line">    <span class="keyword">if</span> (person.name == <span class="string">&quot;Alice&quot;</span>) <span class="keyword">return</span></span><br><span class="line">	println(<span class="string">&quot;<span class="subst">$&#123;person.name&#125;</span> is not Alice&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; lookForAlice(people)</span><br><span class="line">Bob <span class="keyword">is</span> not Alice</span><br></pre></td></tr></table></figure>
<p>匿名函数和普通函数没什么两样，不过它的函数名和参数类型可以省略。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">people.filter(<span class="function"><span class="title">fun</span> <span class="params">(person)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> person.age &lt; <span class="number">30</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>作为表达式语句体时，匿名函数的返回类型可以直接省略，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.filter(<span class="function"><span class="title">fun</span> <span class="params">(person)</span></span> = person.age &lt; <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>匿名函数和lambda表达式的区别如下，</p>
<p><img src="/img/kotlin-in-aciton/chapter08/Figure_08_05.png" alt="Figure 8.5"></p>
<p>非常明显，lambda表达式没有<code>fun</code>关键字，所以它<code>return</code>到外部函数。</p>
<h2 id="Summary"><a class="header-anchor" href="#Summary">¶</a>Summary</h2>
<ul>
<li>函数类型允许声明的变量、参数、函数返回是一个函数应用。</li>
<li>高阶函数就是指函数接收的参数或返回值也为函数的函数。</li>
<li>当一个内联函数被编译，编译后的字节码将被直接替换在它所真正被调用的地方。</li>
<li>内联函数可以使用 <em>non-local return</em> ——非本地返回，返回内部lambda表达式中的返回。</li>
<li>匿名函数只有 <em>local return</em> 。因此它有多个退出点。</li>
</ul>
</div></article><nav class="article-nav"><div class="article-nav-prev"><a href="/2022/01/07/kotlin/08_generics/">泛型</a></div><div class="article-nav-next"><a href="/2021/12/17/kotlin/06_operator_overloading_and_other_convertions/">Operator overloading and other conventions</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2021/12/27/kotlin/07_higher-order_functions~lambdas_as_parameters_and_return_values/';
var disqus_title = '高阶函数：lambda作为参数和返回';
var disqus_url = 'https://galudisu.info/2021/12/27/kotlin/07_higher-order_functions~lambdas_as_parameters_and_return_values/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>