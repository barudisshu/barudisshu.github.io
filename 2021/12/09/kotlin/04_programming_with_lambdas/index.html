<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>lambdas编程</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">lambdas编程</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2021-12-09</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/kotlin/">kotlin</a></p></div><div class="article-content"><h2 id="主要内容"><a class="header-anchor" href="#主要内容">¶</a>主要内容</h2>
<ol>
<li>lambda表达式和成员引用</li>
<li>函数式风格的集合使用</li>
<li>Sequences: 集合的惰性处理</li>
<li>Kotlin中使用Java函数接口</li>
<li>带有receiver的lambda函数的写法</li>
</ol>
<h2 id="Lambda-expressions-and-member-references"><a class="header-anchor" href="#Lambda-expressions-and-member-references">¶</a>Lambda expressions and member references</h2>
<h3 id="Introduction-to-lambdas-blocks-of-code-as-function-parameters"><a class="header-anchor" href="#Introduction-to-lambdas-blocks-of-code-as-function-parameters">¶</a>Introduction to lambdas: blocks of code as function parameters</h3>
<h3 id="Syntax-for-lambda-expressions"><a class="header-anchor" href="#Syntax-for-lambda-expressions">¶</a>Syntax for lambda expressions</h3>
<p>截止目前为止，所有编程语言的lambda的表达式语法是通用和类似的，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> sum = &#123; x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; x + y &#125;</span><br><span class="line">&gt;&gt;&gt; println(sum(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> people = listOf(Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">29</span>), Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">31</span>))</span><br><span class="line">&gt;&gt;&gt; println(people.maxBy &#123; it.age &#125;)</span><br><span class="line">Person(name=Bob, age=<span class="number">31</span>)</span><br></pre></td></tr></table></figure>
<p>上面用了内建的结构体，下面是一般的lambda语法：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.maxBy(&#123; p: Person -&gt; p.age &#125;)</span><br></pre></td></tr></table></figure>
<p>或者写成：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.maxBy() &#123; p: Person -&gt; p.age &#125;</span><br></pre></td></tr></table></figure>
<p>或者写成：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.maxBy &#123; p: Person -&gt; p.age &#125;</span><br></pre></td></tr></table></figure>
<p>简化的类型推断：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.maxBy &#123; p -&gt; p.age &#125;</span><br></pre></td></tr></table></figure>
<p>如果将lambda存储为一个变量，在没有上下文环境的情况下，是无法推断的。必须显式指定：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> getAge = &#123;p: Person -&gt; p.age &#125;</span><br><span class="line">&gt;&gt;&gt; people.maxBy(getAge)</span><br></pre></td></tr></table></figure>
<h3 id="Accessing-variables-in-scope"><a class="header-anchor" href="#Accessing-variables-in-scope">¶</a>Accessing variables in scope</h3>
<p>对于所有函数式编程而言，基本上，能够修改外部开放项的lambda表达式就是闭包(也叫方法，或者带有副作用的函数)；否则就是纯函数。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">tryToCountButtonClicks</span><span class="params">(button: <span class="type">Button</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> clicks = <span class="number">0</span></span><br><span class="line">  button.onClick &#123; clicks++ &#125;</span><br><span class="line">  <span class="keyword">return</span> clicks</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Member-references"><a class="header-anchor" href="#Member-references">¶</a>Member references</h3>
<p>Kotlin的成员引用( <em>member reference</em> )和Java8的 <code>::</code>一样。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> getAge = Person::age</span><br></pre></td></tr></table></figure>
<p>对于top-level的函数可以省略文件名(top-level 成员的类名就是文件名)，譬如：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">salute</span><span class="params">()</span></span> = println(<span class="string">&quot;Salute!&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; run(::salute)</span><br><span class="line">Salute!</span><br></pre></td></tr></table></figure>
<p>成员引用的写法比lambda的写法更加便捷，因为它不需要传递参数：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> action = &#123;person: Person, message: String -&gt; sendEmail(person, message)&#125;  <span class="comment">// This lambda delegates to a sendEmail function.</span></span><br><span class="line"><span class="keyword">val</span> nextAction = ::sendEmail  <span class="comment">// You can use a member reference instead.</span></span><br></pre></td></tr></table></figure>
<p>你可以推迟这种访问用作构造器引用：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> createPerson = ::Person  <span class="comment">// An action of creating an instance of &quot;Person&quot; is saved as a value.</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> p = createPerson(<span class="string">&quot;Alice&quot;</span>, <span class="number">29</span>)</span><br><span class="line">&gt;&gt;&gt; println(p)</span><br><span class="line">Person(name=Alice, age=<span class="number">29</span>)</span><br></pre></td></tr></table></figure>
<p>类似地，也可以用于扩展函数：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Person.<span class="title">isAdult</span><span class="params">()</span></span> = age &gt;= <span class="number">21</span></span><br><span class="line"><span class="keyword">val</span> predicate = Person::isAdult</span><br></pre></td></tr></table></figure>
<h2 id="Functional-APIs-for-collections"><a class="header-anchor" href="#Functional-APIs-for-collections">¶</a>Functional APIs for collections</h2>
<p>现代语言集合的所有API基本上都是通用的，因为数据结构不会相差太大。</p>
<h3 id="Essentials-filter-and-map"><a class="header-anchor" href="#Essentials-filter-and-map">¶</a>Essentials: filter and map</h3>
<p><code>filter</code>和 <code>map</code> 作为集合常见的函数api。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>
<p><code>filter</code>函数过滤偶数：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&gt;&gt;&gt; println(list.filter &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;)  <span class="comment">// Only even numbers remain.</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>过滤超过30岁的人，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> people = listOf(Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">29</span>), Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">31</span>))</span><br><span class="line">&gt;&gt;&gt; println(people.filter &#123; it.age &gt; <span class="number">30</span> &#125;)</span><br><span class="line">[Person(name=Bob, age=<span class="number">31</span>)]</span><br></pre></td></tr></table></figure>
<p><code>map</code>的作用相当于transformer，譬如：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&gt;&gt;&gt; println(list.map &#123; it * it &#125;)</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</span><br></pre></td></tr></table></figure>
<p>转换类型</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; people = listOf(Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">29</span>), Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">31</span>))</span><br><span class="line">&gt;&gt;&gt; println(people.map &#123; it.name &#125;)</span><br><span class="line">[Alice, Bob]</span><br></pre></td></tr></table></figure>
<p>也可以替换为成员引用的写法更加简洁：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.map(Person::name)</span><br></pre></td></tr></table></figure>
<p>可以链式调用，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; people.filter &#123; it.age &gt; <span class="number">30</span> &#125;.map(Person::name)</span><br><span class="line">[Bob]</span><br></pre></td></tr></table></figure>
<p>或者组合lambda和成员引用，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.filter &#123; it.age == people.maxBy[Person::age).age &#125;</span><br></pre></td></tr></table></figure>
<p>改进写法，仅计算一次，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> maxAge = people.maxBy(Person::age).age</span><br><span class="line">people.filter &#123; it.age == maxAge &#125;</span><br></pre></td></tr></table></figure>
<h3 id="“All”-“Any”-“count”-and-“find”-applying-a-predicate-to-a-collection"><a class="header-anchor" href="#“All”-“Any”-“count”-and-“find”-applying-a-predicate-to-a-collection">¶</a>“All”, “Any”, “count”, and “find”: applying a predicate to a collection</h3>
<p>实现上和Java 8 的predicate无差别，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> canBeInClub27 = &#123; p: Person -&gt; p.age &lt;= <span class="number">27</span> &#125;</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> people = listOf(Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">27</span>), Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">31</span>))</span><br><span class="line">&gt;&gt;&gt; println(people.all(canBeInClub27))</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>如果仅检测至少一个匹配，使用<code>any</code>，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; println(people.any(canBeInClub27))</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><code>!all</code>的逆命题就是<code>any</code>，所以下面的写法是等价的，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt; println(!list.all &#123; it == <span class="number">3</span> &#125;)  <span class="comment">// The negation ! isn&#x27;t noticeable, so it&#x27;s better to use &quot;any&quot; in this case.</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt;&gt;&gt; println(list.any &#123; it != <span class="number">3</span> &#125;)  <span class="comment">// The condition in the argument has changed to its opposite.</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><code>count</code>统计满足的predicate，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> people = listOf(Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">27</span>), Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">31</span>))</span><br><span class="line">&gt;&gt;&gt; println(people.count(canBeInClub27))</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="GroupBy-converting-a-list-to-a-map-of-groups"><a class="header-anchor" href="#GroupBy-converting-a-list-to-a-map-of-groups">¶</a>GroupBy: converting a list to a map of groups</h3>
<p><code>groupBy</code>在统计计算的场景被经常用到，顾名思义“分组”，</p>
<p>按年龄分组，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> people = listOf(Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">31</span>), Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">29</span>), Person(<span class="string">&quot;Carol&quot;</span>, <span class="number">31</span>))</span><br><span class="line">&gt;&gt;&gt; println(people.groupBy &#123; it.age &#125;)</span><br></pre></td></tr></table></figure>
<p>和Java一样，分组后放在一个<code>Map&lt;Int, List&lt;Person&gt;&gt;</code>里面。</p>
<h3 id="flatMap-and-flattern-processing-elements-in-nested-collections"><a class="header-anchor" href="#flatMap-and-flattern-processing-elements-in-nested-collections">¶</a>flatMap and flattern: processing elements in nested collections</h3>
<p><code>flatMap</code>的步骤分为两步，即<code>flatten</code>+<code>map</code>。首先将所有元素进行转换(<code>map</code>)，然后在组合(<code>flattern</code>)为一个。它属于集合内嵌操作。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Book</span>(<span class="keyword">val</span> title: String, <span class="keyword">val</span> authors: List&lt;String&gt;)</span><br></pre></td></tr></table></figure>
<p>计算集合，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">books.flatMap &#123; it.authors &#125;.toSet()  <span class="comment">// Set of all authors who wrote books in the &quot;books&quot; collection</span></span><br></pre></td></tr></table></figure>
<h2 id="Lazy-collectino-operations-sequences"><a class="header-anchor" href="#Lazy-collectino-operations-sequences">¶</a>Lazy collectino operations: sequences</h2>
<p>类似于<code>map</code>和<code>filter</code>这一类函数执行后立即计算的称为<code>eagerly</code>。相对于的类似于<code>sequences</code>提供了惰性求值的可能。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.asSequence().map(Person::name).filter &#123; it.startsWith(<span class="string">&quot;A&quot;</span>) &#125;.toList()</span><br></pre></td></tr></table></figure>
<p><code>Sequence</code>在Kotlin 中作为接口，提供了丰富的api和语法糖。</p>
<h3 id="Executing-sequence-operations-intermediate-and-terminal-operations"><a class="header-anchor" href="#Executing-sequence-operations-intermediate-and-terminal-operations">¶</a>Executing sequence operations: intermediate and terminal operations</h3>
<p>操作一个sequence被分为两个步骤：</p>
<ul>
<li><code>intermediate operation</code>，返回另外一个sequence实例，</li>
<li><code>terminal operation</code>，返回真实的结构。</li>
</ul>
<p><img src="/img/kotlin-in-action/chapter05/Figure_05_07.png" alt="Figure 5.7"></p>
<p>intermediate operation总是lazy的，譬如，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).asSequence().map &#123; print(<span class="string">&quot;map&#123;<span class="variable">$it</span>) &quot;</span>); it * it &#125;.filter &#123; print(<span class="string">&quot;filter(<span class="variable">$it</span>) &quot;</span>); it % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure>
<p>执行该代码片段不会在控制台打印任何结果。意味着<code>map</code>和<code>filter</code>被延迟执行(仅当terminal operation被调用才执行)：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).asSequence().map &#123; print(<span class="string">&quot;map&#123;<span class="variable">$it</span>) &quot;</span>); it * it &#125;.filter &#123; print(<span class="string">&quot;filter(<span class="variable">$it</span>) &quot;</span>); it % <span class="number">2</span> == <span class="number">0</span> &#125;.toList()</span><br><span class="line">map(<span class="number">1</span>) filter(<span class="number">1</span>) map(<span class="number">2</span>) filter(<span class="number">4</span>) map(<span class="number">3</span>) filter(<span class="number">9</span>) map(<span class="number">4</span>) filter(<span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<p>eager(collection) 和 lazy(sequences) 的区别在于，某些计算在sequence不会被执行，如下图：</p>
<p><img src="/img/kotlin-in-action/chapter05/Figure_05_08.png" alt="Figure 5.8"></p>
<p>在第一种case，集合中的list会被转换为另外一个list，因此<code>map</code>会作用于每一个元素，包括3和4。之后，在计算得到4。</p>
<p>在第二种case，<code>find</code>的对原始元素一个接一个地处理。对于原来的集合元素，会执行<code>map</code>转换，再执行<code>find</code>操作。所以，当达到2时，满足条件，返回结果，不必关系后面的3、4、5…。</p>
<p>这种对元素的处理顺序操作对于性能是有明显影响的。譬如一下代码，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> people = listOf(Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">29</span>), Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">31</span>), Person(<span class="string">&quot;Charles&quot;</span>, <span class="number">31</span>), Person(<span class="string">&quot;Dan&quot;</span>, <span class="number">21</span>))</span><br><span class="line">&gt;&gt;&gt; println(people.asSequence().map(Person::name).filter &#123; it.length &lt; <span class="number">4</span> &#125;.toList())  <span class="comment">// &quot;map&quot; goes first, then &quot;filter&quot;.</span></span><br><span class="line"></span><br><span class="line">[Bob, Dan]</span><br><span class="line">&gt;&gt;&gt; println(people.asSequence().filter &#123; it.name.length &lt; <span class="number">4</span> &#125;.map(Person::name).toList() <span class="comment">// &quot;map&quot; goes after &quot;filter&quot;.</span></span><br><span class="line"></span><br><span class="line">[Bob, Dan]</span><br></pre></td></tr></table></figure>
<p><img src="/img/kotlin-in-action/chapter05/Figure_05_09.png" alt="Figure 5.9"></p>
<p>如果<code>map</code>先行，每个元素都被转换(transform)了。如果<code>filter</code>先行，不恰当的元素被尽可能地filter掉以减少转换。</p>
<h3 id="Creating-sequences"><a class="header-anchor" href="#Creating-sequences">¶</a>Creating sequences</h3>
<p>处理在集合上使用<code>asSequence()</code>创建一个sequence，还可以通过<code>generateSequence()</code>函数来创建。例如，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> naturalNumbers = generateSequence(<span class="number">0</span>) &#123; it + <span class="number">1</span> &#125;</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> numbersTo100 = naturalNumbers.takeWhile &#123; it &lt;= <span class="number">100</span> &#125;</span><br><span class="line">&gt;&gt;&gt; println(numbersTo100.sum())  <span class="comment">// All the delayed operations are performed when the result &quot;sum&quot; is obtained.</span></span><br><span class="line"><span class="number">5050</span></span><br></pre></td></tr></table></figure>
<h2 id="Using-Java-functional-interfaces"><a class="header-anchor" href="#Using-Java-functional-interfaces">¶</a>Using Java functional interfaces</h2>
<p>Kotlin调用Java的接口函数比较简单，假设有Java接口如下，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnClickListner</span><span class="params">(OnClickListener l)</span> &#123;... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>functional interface声明如下，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnClickListener</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在kotlin中直接使用lambda表达式，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener &#123; view -&gt; ... &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/kotlin-in-action/chapter05/Figure_05_10.png" alt="Figure 5.10"></p>
<p>之所以生效是因为，接口<code>OnClickListner</code>仅包含一个抽象方法。这种接口被称为 <em><code>functional interfaces</code></em> 或 SAM <em><code>interfaces</code></em> ，SAM就是 <em>single abstract method</em> 的缩写。Java的标准API包含大量的这类接口，譬如常见的<code>Runnable</code>和<code>Callable</code>。</p>
<h3 id="Passing-a-lambda-as-a-parameter-to-a-Java-method"><a class="header-anchor" href="#Passing-a-lambda-as-a-parameter-to-a-Java-method">¶</a>Passing a lambda as a parameter to a Java method</h3>
<p>对于Java中包含有functional interface的方法参数可以直接传递lambda表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">postponeComputation</span><span class="params">(<span class="type">int</span> delay, Runnable computation)</span>;</span><br></pre></td></tr></table></figure>
<p>kotlin中的编译器会自动根据表达式进行转换，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postponeComputation(<span class="number">1_000</span>) &#123; println(<span class="number">42</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>它等效于下面的写法，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">postponeComputation(<span class="number">1_000</span>, <span class="keyword">object</span> : Runnable &#123;  <span class="comment">// Passes an object expression as an implementation of a functional interface</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	  println(<span class="number">42</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不同的是，如果现实声明一个对象表达式，每次调用都会创建一个新的实例。如果使用lambda，并且不是闭包的情况下，对应的匿名实例会被重用：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postponeComputation(<span class="number">1_000</span>) &#123; println(<span class="number">42</span>) &#125;  <span class="comment">// One instance of Runnable is created for the entire program.</span></span><br></pre></td></tr></table></figure>
<p>因此，等价的写法应该写为，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> runnable = Runnable &#123; println(<span class="number">42</span>) &#125;  <span class="comment">// Compiled to a global variable; only one instance in the program</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">handleComputation</span><span class="params">()</span></span> &#123;</span><br><span class="line">  postponeComputation(<span class="number">1_000</span>, runnable)  <span class="comment">// One object is used for every handleComputation call.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，如果将lambda表达式传递给一个带有<code>inline</code>标记的函数，则不会有匿名类的创建。</p>
<h3 id="SAM-constructors-explicit-conversion-of-lambdas-to-functional-interfaces"><a class="header-anchor" href="#SAM-constructors-explicit-conversion-of-lambdas-to-functional-interfaces">¶</a>SAM constructors: explicit conversion of lambdas to functional interfaces</h3>
<p>SAM constructors其实就是functional interface!!!</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createAllDoneRunnable</span><span class="params">()</span></span>: Runnable &#123;</span><br><span class="line">  <span class="keyword">return</span> Runnable &#123; println(<span class="string">&quot;All done!&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; createAllDoneRunnable().run()</span><br><span class="line">All done!</span><br></pre></td></tr></table></figure>
<p>炒概念，不作介绍！！</p>
<h2 id="Lambdas-with-receivers-“with”-and-“apply”"><a class="header-anchor" href="#Lambdas-with-receivers-“with”-and-“apply”">¶</a>Lambdas with receivers: “with” and “apply”</h2>
<p>kotlin 的lambda表达式不同于Java，可以带receivers。</p>
<h3 id="The-“with”-function"><a class="header-anchor" href="#The-“with”-function">¶</a>The “with” function</h3>
<p><code>with</code>为inline函数，后面跟着的receiver相当于自由变量，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">  <span class="keyword">val</span> result = StringBuilder()</span><br><span class="line">  <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">    result.append(letter)</span><br><span class="line">  &#125;</span><br><span class="line">  result.append(<span class="string">&quot;\nNow I know the alphebet!&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt; println(alphabet())</span><br><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br><span class="line">Now I know the alphabet!</span><br></pre></td></tr></table></figure>
<p>这个例子中，<code>result</code>被重复调用了很多次。可以用<code>with</code>重写为，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">  <span class="keyword">val</span> stringBuilder = StringBuilder()</span><br><span class="line">  <span class="keyword">return</span> with(stringBuilder) &#123;  <span class="comment">// Specifies the receiver value on which you&#x27;re calling the methods</span></span><br><span class="line">    <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">	  <span class="keyword">this</span>.append(letter)  <span class="comment">// Calls a method on the receiver value though an explicit &quot;this&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	append(<span class="string">&quot;\nNow I know the alphabet!&quot;</span>)  <span class="comment">// Calls a method ommiting &quot;this&quot;</span></span><br><span class="line">	<span class="keyword">this</span>.toString()  <span class="comment">// Returns a value from the lambda</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>with</code>的底层实际为inline函数，接收两个参数：<code>stringBuilder</code>、和一个lambda。逻辑上没有任何区别，仅仅为了提高可读性。甚至可以更加简洁，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet</span><span class="params">()</span></span> = with(StringBuilder()) &#123;</span><br><span class="line">  <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">    append(letter)</span><br><span class="line">  &#125;</span><br><span class="line">  append(<span class="string">&quot;\nNow I know the alphabet!&quot;</span>)</span><br><span class="line">  toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="The-“apply”-function"><a class="header-anchor" href="#The-“apply”-function">¶</a>The “apply” function</h3>
<p><code>apply</code>函数和<code>with</code>的用法类似；不同在于，<code>apply</code>总是返回传递进来的参数对象。我们使用<code>apply</code>重构上述代码，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet</span><span class="params">()</span></span> = StringBuilder().apply (</span><br><span class="line">  <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">    append(letter)</span><br><span class="line">  &#125;</span><br><span class="line">  append(<span class="string">&quot;\nNow I know the alphabet!&quot;</span>)</span><br><span class="line">&#125;.toString()</span><br></pre></td></tr></table></figure>
<p><code>apply</code>最常用到的地方就是创建一个实例，并初始化某些属性。譬如，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createViewWithCustomAttributes</span><span class="params">(context: <span class="type">Context</span>)</span></span> =</span><br><span class="line">  TextView(context).apply &#123;</span><br><span class="line">    text = <span class="string">&quot;Sample Text&quot;</span></span><br><span class="line">	textSize = <span class="number">20.0</span></span><br><span class="line">	setPadding(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>apply</code>传入的lambda表达式被执行后将返回初始化后的实例。另外，kotlin提供了更简洁的inline函数，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet</span><span class="params">()</span></span>: String = buildString &#123;</span><br><span class="line">  <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">    append(letter)</span><br><span class="line">  &#125;</span><br><span class="line">  append(<span class="string">&quot;\nNow I know the alphabet!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Summary"><a class="header-anchor" href="#Summary">¶</a>Summary</h2>
<ul>
<li>lambda可以将代码块作为参数传入函数。</li>
<li>kotlin可以传递无括号的lambda，并用<code>it</code>作为引用。</li>
<li>作为闭包时，lambda表达式可以访问和修改外部变量。</li>
<li>member reference语法使用<code>::</code>表示，可以引用方法、构造函数、属性。</li>
<li>集合提供了丰富的functional api，譬如<code>filter</code>、<code>map</code>、<code>all</code>、<code>any</code>等。</li>
<li>Sequences 表示集合的操作作为中间操作部分，在真正调用的地方按顺序执行。</li>
<li>functional interface和SAM interface作为参数的用法。</li>
<li>lambda带有receivers的用法写在了kotlin的标准inline function中使用。</li>
<li><code>with</code>标准库函数允许方法可以多次重复调用同一个实例；<code>apply</code>可以让你创建实例的同时并初始化成员属性。</li>
</ul>
</div></article><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2021/12/09/kotlin/04_programming_with_lambdas/';
var disqus_title = 'lambdas编程';
var disqus_url = 'https://galudisu.info/2021/12/09/kotlin/04_programming_with_lambdas/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>