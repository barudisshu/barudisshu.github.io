<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>Kotlin 基础</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">Kotlin 基础</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2021-07-25</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/kotlin/">kotlin</a></p></div><div class="article-content"><h2 id="主要内容"><a class="header-anchor" href="#主要内容">¶</a>主要内容</h2>
<ol>
<li>一个基本Kotlin例子</li>
<li>Kotlin语言的主要特质(traits)</li>
<li>Android和服务端开发的可能性</li>
<li>Kotlin和其它语言的不同</li>
<li>编写和运行Kotlin代码</li>
</ol>
<span id="more"></span>
<h2 id="Basic-elements-functions-and-variables"><a class="header-anchor" href="#Basic-elements-functions-and-variables">¶</a>Basic elements: functions and variables</h2>
<p>本章节介绍构成每个Kotlin程序的基本要素：函数和变量。你将会看到Kotlin如何让你省略了许多类型声明，如何促使你使用不可变数据(immutable)，而不是可变数据(mutable)。</p>
<h3 id="Hello-world"><a class="header-anchor" href="#Hello-world">¶</a>Hello, world!</h3>
<p>从&quot;Hello World&quot;开始：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  println(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个简单的代码片段可以一瞥语言的部分特性(feature)：</p>
<ul>
<li><code>fun</code>关键字用于声明函数。</li>
<li>参数类型写在参数名之后。变量的声明也如此。</li>
<li>函数可以声明在一个文件的最顶层；你不需要将其放置在一个类内声明。</li>
<li>Kotlin中的数组就是类。和Java不同，Kotlin没有对数组类型的特定语法。</li>
<li>使用 <code>println</code> 而不是 <code>System.out.println</code>。Kotlin标准库使用简洁的语法，提供了许多关于Java库函数的包装(wrappers)，<code>println</code>就是其中之一。</li>
<li>和其它现代语言一样，你可以在行末省略分号(; )。</li>
</ul>
<h4 id="Functions"><a class="header-anchor" href="#Functions">¶</a>Functions</h4>
<p>如果希望函数包含返回类型，如何在签名中定义？</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(max(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>函数的声明由<code>fun</code>关键字开始，随后是函数名，例如这里的<code>max</code>。之后是括号内的参数列表。返回类型跟随在参数列表之后，由冒号分隔。</p>
<p>图Figure 2.1 展示了一个函数的基本结构。注意在Kotlin，<code>if</code>是一个带有结果的表达式。类似于Java的三元操作：<code>(a &gt; b) ? a : b</code>。</p>
<p><img src="/img/kotlin-in-action/chapter01/Figure_02_01.png" alt="Figure 2.1"></p>
<blockquote>
<h4 id="Statements-and-expressions"><a class="header-anchor" href="#Statements-and-expressions">¶</a>Statements and expressions</h4>
<p>在Kotlin，<code>if</code>是一个表达式，不是语句。区分于语句和表达式的不同点在于，表达式是一个值，它可以被用作另一个表达式的一部分，而一个语句在它的封闭块内总是一个顶层元素，而且没有自己的值。在Java中，所有控制结构(if-else, for, etc)都是语句。而在Kotlin中，除了循环(<code>for</code>, <code>do</code>, <code>do/while</code>)控制结构，其它都是表达式。这种可以组合控制结构和表达式的能力，可以让你更间接地表述许多常用的模式。</p>
<p>另外，分配(assignments)在Java中是表达式，在Kotlin中变成了语句(statements)。这可以帮助避免混淆类比(comparisons)和分配(assignments)。</p>
</blockquote>
<p><strong>EXPRESSION BODIES</strong></p>
<p>前面的函数可以作进一步简化。因为它的语句体仅包含一个表达式，以及Kotlin的大部分控制结构都是表达式，有返回值。可以写为：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure>
<p>如果一个函数的语句体用花括号描述，我们可以说该函数有一个 <em>块体(block body)</em> 。如果它直接返回一个表达式，我们称其为 <em>表达体(expression body)</em>。</p>
<p>带有表达体的函数不仅被用于琐碎的一行函数，也被用于单一但复杂的表达式，诸如<code>if</code>、<code>when</code>或<code>try</code>。</p>
<p>上面的<code>max</code>函数甚至可以省略返回类型：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure>
<p>为什么会有函数不带返回类型的声明？不仅Kotlin这样，作为一门静态类型语言，所有变量和表达式都有类型，所有函数都有返回类型。对于表达体函数，编译器可以分析出函数体内的表达式从而作为函数的返回类型，即使它没有显示拼写出来。这种分析的类型通常被称为 <em>类型推导(type inference)</em>。</p>
<p>注意省略的函数类型仅允许表达体的函数。对于block body的函数需要显式使用<code>return</code>语句并指定返回类型。真实世界的函数通常会有多个<code>return</code>语句，拥有返回类型和<code>return</code>语句可以显式地帮助你捕获需要返回的内容。</p>
<h3 id="Variables"><a class="header-anchor" href="#Variables">¶</a>Variables</h3>
<p>在Java中，变量声明开始于类型。Kotlin则不是，使用关键字声明变量以省略变量类型的声明。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> question = <span class="string">&quot;The Ultimate Question of Life, the Universe, and Everything&quot;</span></span><br><span class="line"><span class="keyword">val</span> anser = <span class="number">42</span></span><br></pre></td></tr></table></figure>
<p>当然你也可以显式指定变量的类型：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> answer: <span class="built_in">Int</span> = <span class="number">42</span></span><br></pre></td></tr></table></figure>
<p>和expression-body函数一样，如果你不指定类型，编译器分析并初始化表达式的类型来作为变量的类型。这里例子中，初始化为42，有<code>Int</code>类型，因此变量的类型为<code>Int</code>。</p>
<p>如果使用一个浮点型常量，则变量的类型为<code>Double</code>：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> yearsToCompute = <span class="number">7.5e6</span></span><br></pre></td></tr></table></figure>
<p>如果变量没有被初始化，你一定显式指定它的类型：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> answer: <span class="built_in">Int</span></span><br><span class="line">answer = <span class="number">42</span></span><br></pre></td></tr></table></figure>
<p>因为你如果你不初始化，编译器无法推断出变量的类型信息。</p>
<p><strong>MUTABLE AND IMMUTABLE VARIABLES</strong></p>
<p>有两个关键字去定义变量：</p>
<ul>
<li><code>val</code>(from <em>value</em>): Immutable reference. 一个变量用<code>val</code>声明初始化后不可重新分配。对应于Java的final变量。</li>
<li><code>var</code>(from <em>variable</em>): Mutable reference. 就是变量的值可以被修改。</li>
</ul>
<p>默认地，你更应该使用<code>val</code>关键字来声明所有变量。仅在某些必要情况下使用<code>var</code>。使用不带副作用(side effects)的不可变引用、不可变对象、不可变函数，可以使得你的代码更接近函数风格。</p>
<p><code>val</code>变量必须在它的定义语句块内初始化一次。但有时你也可以根据条件初始化不同的值，但前提是要确保编译器仅初始化一次：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> message: String</span><br><span class="line"><span class="keyword">if</span> (canPerformOperation()) &#123;</span><br><span class="line">  message = <span class="string">&quot;Success&quot;</span></span><br><span class="line">  <span class="comment">// ... perform the operation</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  message = <span class="string">&quot;Failed&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，尽管一个<code>val</code>自身的引用是不可变的不会被改变，但变量对象的指针则会被改变。例如：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> languages = arrayListOf(<span class="string">&quot;Java&quot;</span>)</span><br><span class="line">languages.add(<span class="string">&quot;Kotlin&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>尽管<code>var</code>关键字声明的对象的值会被改变，但它的类型是固定的。例如：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anser = <span class="number">42</span></span><br><span class="line">answer = <span class="string">&quot;no answer&quot;</span></span><br></pre></td></tr></table></figure>
<p>这会抛出错误，编译器在变量初始化的时候推断了变量的类型，不允许再分配不同的类型。</p>
<p>如果你需要存储一个类型不匹配的变量，必须手动转换或强制该值为合适的类型。</p>
<h3 id="Easier-string-formatting-string-templates"><a class="header-anchor" href="#Easier-string-formatting-string-templates">¶</a>Easier string formatting: string templates</h3>
<p>我们改下前面的例子，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> name = <span class="keyword">if</span> (args.size &gt; <span class="number">0</span>) args[<span class="number">0</span>] <span class="keyword">else</span> <span class="string">&quot;Kotlin&quot;</span></span><br><span class="line">  println(<span class="string">&quot;Hello, <span class="variable">$name</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子引入了一个特性，<em>字符串模板(string templates)</em>。代码中，你声明了一个变量<code>name</code>并使用到字符字面量。和其它脚本语言一样，KotlinKotlin可以在字符串字面量中使用<code>$</code>字符来引用本地变量。这等价于Java的字符串拼接 <code>(Hello, &quot; + name + &quot;!&quot;)</code> 但相比更高效<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。当然，改表达式是静态检查，如果引用的变量不存在，编译不会通过。</p>
<p>另外如果你需要在字符串引入<code>$</code>字符，则需要转义：<code>println(&quot;\$x&quot;)</code>，这样就仅仅是输出<code>$x</code>，不会把<code>x</code>推断为变量引用。</p>
<p>如果表达式太复杂，你不需要被强制简化变量名，可以使用花括号囊括表达式来描述：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (args.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello, <span class="subst">$&#123;args[<span class="number">0</span>]&#125;</span>!&quot;</span>)  <span class="comment">// 使用`$&#123;&#125;`表达式</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者双引号里面再囊括双引号，但前提是它必须是一个表达式：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  println(<span class="string">&quot;Hello, <span class="subst">$&#123;if (args.size &gt; <span class="number">0</span> ) args[<span class="number">0</span>] else <span class="string">&quot;someone&quot;</span>&#125;</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Classes-and-properties"><a class="header-anchor" href="#Classes-and-properties">¶</a>Classes and properties</h2>
<p>如果你对面向对象编程再熟悉不过，并熟知<code>class</code>的概念。那么Kotlin的本节内容对你也同样熟悉，但你会发现许多通用的任务可以使用更少的代码来完成。</p>
<p>让我们从JavaBean的<code>Person</code>类开始。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Java，构造器通常会用于初始化成员变量参数。在Kotlin中，这种逻辑可以不用这种样板代码(boilerplate code)来表述。Kotlin的写法更直接和简单。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure>
<p>这种仅包含数据但没有具体代码逻辑的类型通常被称为 <em>值对象(value objects)</em>，许多语言提供了对其声明的简单语法。</p>
<p>注意到，修改器<code>public</code>在这里被省略了，因为在Kotlin中<code>public</code>默认就是可见的。</p>
<h3 id="Properties"><a class="header-anchor" href="#Properties">¶</a>Properties</h3>
<p>你肯定知道，一个类的设计是封装数据和代码，以及将对该数据的处理表述为一个单一实体类。在Java中，数据被存储在字段部分，通常是private的。如果你想通过外部访问改数据，你会提供 <em>访问器方法(accessor methods)</em>；也就是getter和setter。setter可能会提供额外的逻辑来验证传入的值，发送通知等。</p>
<p>在Java中，accessor + private field的组合通常被作为 <em>property</em> 引用，需要一些Java框架甚至过度使用这个概念。在Kotlin，properties是first-class feature，它会完全替换 accessor + fields这种组合。你可以像定义变量一样来定义属性： 使用<code>val</code> 和 <code>var</code>关键字。属性使用<code>val</code>声明表示只读，使用<code>var</code>表示可变可修改。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">val</span> name: String,        <span class="comment">// 只读属性：产生一个字段和一个繁琐的getter</span></span><br><span class="line">  <span class="keyword">var</span> isMarried: <span class="built_in">Boolean</span>   <span class="comment">// 可写属性：字段, getter, setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本上，当你声明一个属性，相应地声明了accessors(a getter for a read-only property, and both a getter and a setter for a writable one)。默认地，accessor的实现是琐碎的：创建一个字段来存储值，创建getter和setter来获取值以及更新值。但如果你需要，在Kotlin中可以自定义accessor覆盖原有的逻辑。</p>
<p>下面看看Java类如何使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&gt;&gt;&gt; System.out.println(person.getName());</span><br><span class="line">Bob</span><br><span class="line">&gt;&gt;&gt; System.out.println(person.isMarried());</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>然后是对比Kotlin的使用：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> person = Person(<span class="string">&quot;Bob&quot;</span>, <span class="literal">true</span>)    <span class="comment">// 不带`new`关键字调用构造器</span></span><br><span class="line">&gt;&gt;&gt; println(person.name)                <span class="comment">// 直接访问属性。实际调用的是getter</span></span><br><span class="line">Bob</span><br><span class="line">&gt;&gt;&gt; println(person.isMarried)</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>现在，相比调用getter，你可以直接地引用属性。代码逻辑不变，但更简洁。setter方法也一样，在Java，使用<code>person.setMarried(false)</code>，对应Kotlin则<code>person.isMarried = false</code>。</p>
<p><strong>TIP</strong> 你也可以在Java中使用Kotlin的属性语法。Getters也可以在Kotlin中通过<code>val</code>属性访问，对应getter/setter通过<code>var</code>访问。</p>
<h3 id="Custom-accessors"><a class="header-anchor" href="#Custom-accessors">¶</a>Custom accessors</h3>
<p>本届向你展示如何自定义一个属性访问器。假设你声明了一个矩形，并可以判断它是否是正方形。是否是正方形的属性需要通过计算得出，因此：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>(<span class="keyword">val</span> height: <span class="built_in">Int</span>, <span class="keyword">val</span> width: <span class="built_in">Int</span>) &#123;</span><br><span class="line">  <span class="keyword">val</span> isSquare: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() &#123;  <span class="comment">// 属性getter的声明</span></span><br><span class="line">	  <span class="keyword">return</span> height == width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性<code>isSquare</code>不需要额外的字段来存储值。仅需要有一个自定义的getter提供即可。它的值在每次被访问时计算。</p>
<p>注意到你不需要每次都使用花括号；你可以写成<code>get() = height == width</code>。它的调用是等价的：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> rectangle = Rectangle(<span class="number">41</span>, <span class="number">43</span>)</span><br><span class="line">&gt;&gt;&gt; println(rectangle.isSquare)</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>在Java中直接访问Kotlin的<code>isSquare</code>即可。</p>
<h3 id="Kotlin-source-code-layout-directories-and-packages"><a class="header-anchor" href="#Kotlin-source-code-layout-directories-and-packages">¶</a>Kotlin source code layout: directories and packages</h3>
<p>Kotlin中对包的定义和引用和Java一样：在文件在最前面，使用<code>package</code>声明，使用<code>import</code>关键字引入，写法如下：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pacakge geometry.shapes</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>(<span class="keyword">val</span> height: <span class="built_in">Int</span>, <span class="keyword">val</span> width: <span class="built_in">Int</span>) &#123;</span><br><span class="line">  <span class="keyword">val</span> isSquare: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = height == width</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createRandomRectangle</span><span class="params">()</span></span>: Rectangle &#123;</span><br><span class="line">  <span class="keyword">val</span> random = Random()</span><br><span class="line">  <span class="keyword">return</span> Rectangle(random.nextInt(), random.nextInt())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外Kotlin不区分引入包还是函数，所以你可以使用<code>import</code>关键引入任务需要使用的函数名。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> geometry.example</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> geometry.shapes.createRandomRectangle</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  println(createRandomRectangle().isSquare)  <span class="comment">// 打印 &quot;true&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以使用<code>.*</code>这种wildcard来引入所有包内容。需要注意的是，星号不仅匹配的包下的所有类，同样也引入了包下的所有函数和属性。</p>
<p>在Java中，包的结构和目录是对应的，它要求类名和文件名必须有唯一的对应，如下，</p>
<p><img src="/img/kotlin-in-action/chapter01/Figure_02_02.png" alt="Figure 2.2"></p>
<p>但在Kotlin中，文件名不作要求，包名对应文件名，如下：</p>
<p><img src="/img/kotlin-in-action/chapter01/Figure_02_03.png" alt="Figure 2.2"></p>
<p>大多数情况下，还是建议遵循Java的包名习惯来组织代码目录。这对于Kotlin+Java的混合编程会比较清晰。</p>
<h3 id="Representing-and-handling-choices-enums-and-“when”"><a class="header-anchor" href="#Representing-and-handling-choices-enums-and-“when”">¶</a>Representing and handling choices: enums and “when”</h3>
<p>本小节将介绍<code>when</code>结构体。你可以认为它是Java的<code>switch</code>的一种替代，但它功能更强大，使用更频繁。顺便会介绍如何在Kotlin声明枚举，并讨论<code>smart casts</code>的概念。</p>
<h3 id="Declaring-enum-classes"><a class="header-anchor" href="#Declaring-enum-classes">¶</a>Declaring enum classes</h3>
<p>Kotlin的枚举和Java的枚举具有对应关系，声明用法如下：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的关键字部分<code>enum class</code>和Java的<code>enum</code>对应。在Kotlin中，<code>enum</code>被称为 <em>软关键字(soft keyword)</em>。在<code>class</code>前定义有特定含义。另外，<code>class</code>仍然是一个关键字。</p>
<p>在Java中，枚举不仅仅是值的列表：你可以在枚举类中声明属性和方法。在Kotlin中对应为：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Color</span>(<span class="keyword">val</span> r: <span class="built_in">Int</span>, <span class="keyword">val</span> g: <span class="built_in">Int</span>, <span class="keyword">val</span> b: <span class="built_in">Int</span>) &#123;  <span class="comment">// 声明枚举常量的属性</span></span><br><span class="line">  RED(<span class="number">255</span>, <span class="number">0</span> , <span class="number">0</span>),                                      <span class="comment">// 指定每个创建常量的属性值</span></span><br><span class="line">  ORANGE(<span class="number">255</span>, <span class="number">165</span>, <span class="number">0</span>),</span><br><span class="line">  YELLOW(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>),</span><br><span class="line">  GREEN(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>),</span><br><span class="line">  BLUE(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">  INDIGO(<span class="number">75</span>, <span class="number">0</span>, <span class="number">130</span>),</span><br><span class="line">  VIOLET(<span class="number">238</span>, <span class="number">130</span>, <span class="number">238</span>);                                <span class="comment">// 分号; 在这里是必须的</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">rgb</span><span class="params">()</span></span> = (r * <span class="number">156</span> + g) * <span class="number">256</span> + b                   <span class="comment">// 枚举类中定义的方法</span></span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt; println(Color.BLUE.rgb())</span><br></pre></td></tr></table></figure>
<p>枚举常量使用声明构造器和属性相同的语法。声明常量的同时你需要补充上相应的属性值。这里例子是唯一一个在Kotlin中使用分号(;)的地方：因为需要使用分号分离枚举常量和定义的方法。可以说Kotlin的枚举和Java没有区别~</p>
<h3 id="Using-“when”-to-deal-with-enum-classes"><a class="header-anchor" href="#Using-“when”-to-deal-with-enum-classes">¶</a>Using “when” to deal with enum classes</h3>
<p><code>when</code>关键字对应于Java的<code>switch</code>用于处理多分支case。和<code>if</code>，<code>when</code>一样，<code>when</code>作为一个表达式可以用于返回值：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMnemonic</span><span class="params">(color: <span class="type">Color</span>)</span></span> =        <span class="comment">// 直接返回一个&quot;When&quot; 表达式</span></span><br><span class="line">  <span class="keyword">when</span>( color) &#123;                       <span class="comment">// 如果匹配，返回对应的字符串</span></span><br><span class="line">    Color.RED -&gt; <span class="string">&quot;Richard&quot;</span></span><br><span class="line">	Color.ORANGE -&gt; <span class="string">&quot;Of&quot;</span></span><br><span class="line">	Color.YELLOW -&gt; <span class="string">&quot;York&quot;</span></span><br><span class="line">	Color.GREEN -&gt; <span class="string">&quot;Gave&quot;</span></span><br><span class="line">	Color.BLUE -&gt; <span class="string">&quot;Battle&quot;</span></span><br><span class="line">	Color.INDIGO -&gt; <span class="string">&quot;In&quot;</span></span><br><span class="line">	Color.VIOLET -&gt; <span class="string">&quot;Vain&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(getMnemonic(Color.BLUE))</span><br><span class="line">Battle</span><br></pre></td></tr></table></figure>
<p>和Java不同，你不需要为每个分支带入<code>break</code>语句。如果匹配上，只有对应的分支被执行。你也可以在一个分支合并多个值：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getWarmth</span><span class="params">(color: <span class="type">Color</span>)</span></span> = <span class="keyword">when</span>(color) &#123;</span><br><span class="line">  Color.RED, Color.ORANGE, Color.YELLOW -&gt; <span class="string">&quot;warm&quot;</span></span><br><span class="line">  Color.GREEn -&gt; <span class="string">&quot;neutral&quot;</span></span><br><span class="line">  Color.BLUE, Color.INDIGO, Color.VIOLET -&gt; <span class="string">&quot;cold&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(getWarmth(Color.ORANGE))</span><br><span class="line">warm</span><br></pre></td></tr></table></figure>
<p>例子使用了枚举常量的全名，你可以作进一步简化：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Color.*                              <span class="comment">// 导入Color类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getWarmth</span><span class="params">(color: <span class="type">Color</span>)</span></span> = <span class="keyword">when</span>(color) &#123;</span><br><span class="line">  RED, ORANGE, YELLOW -&gt; <span class="string">&quot;warm&quot;</span>             <span class="comment">// 直接使用常量名</span></span><br><span class="line">  GREEN -&gt; <span class="string">&quot;neutral&quot;</span></span><br><span class="line">  BLUE, INDIGO, VIOLET -&gt; <span class="string">&quot;cold&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Using-“when”-with-arbitrary-objects"><a class="header-anchor" href="#Using-“when”-with-arbitrary-objects">¶</a>Using “when” with arbitrary objects</h3>
<p>Kotlin中的<code>when</code>结构体比Java的<code>switch</code>强大多了。<code>switch</code>要求你使用常量(枚举常量，字符串、数字字面量)作为每个分支的条件，<code>when</code>除此还可以使用对象作为分支的条件。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mix</span><span class="params">(c1: <span class="type">Color</span>, c2: <span class="type">Color</span>)</span></span> = </span><br><span class="line">  <span class="keyword">when</span> (setOf(c1, c2)) &#123;</span><br><span class="line">    setOf(RED, YELLOW) -&gt; ORANGE</span><br><span class="line">	setOf(YELLOW, BLUE) -&gt; GREEN</span><br><span class="line">	setOf(BLUE, VIOLET) -&gt; INDIGO</span><br><span class="line">	<span class="keyword">else</span> -&gt; <span class="keyword">throw</span> Exception(<span class="string">&quot;Dirty color&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; pritnln(mix(BLUE, YELLOW))</span><br><span class="line">GREEN</span><br></pre></td></tr></table></figure>
<p>这里的<code>setOf(c1, c2)</code>实际上是一个等价checked：用于检测分支匹配，如果所有分支都不匹配，<code>else</code>分支则被调用。</p>
<h3 id="Using-“when”-without-an-argument"><a class="header-anchor" href="#Using-“when”-without-an-argument">¶</a>Using “when” without an argument</h3>
<p>上面的例子中，每次调用这个函数，它会创建<code>Set</code>实例用于检测分支。通常这没什么问题，但如果调用太过频繁会造成资源浪费。你可以改为如下不带参数的形式：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mixOptimized</span><span class="params">(c1: <span class="type">Color</span>, c2: <span class="type">Color</span>)</span></span> = </span><br><span class="line">  <span class="keyword">when</span> &#123;    <span class="comment">// No argument for &quot;when&quot;</span></span><br><span class="line">    (c1 == RED &amp;&amp; c2 == YELLOW) || (c1 == YELLOW &amp;&amp; c2 == RD) -&gt; ORANGE</span><br><span class="line">	(c1 == YELLOW &amp;&amp; c2 == BLUE) || (c1 == BLUE &amp;&amp; c2 == YELLOW) -&gt; GREEN</span><br><span class="line">	(c1 == BLUE &amp;&amp; c2 == VIOLET) || (c1 == VIOLET &amp;&amp; c2 == BLUE) -&gt; INDIGO</span><br><span class="line">	<span class="keyword">else</span> -&gt; <span class="keyword">throw</span> Exception(<span class="string">&quot;Dirty color&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(mixOptimized(BLUE, YELLOW))</span><br><span class="line">GREEN</span><br></pre></td></tr></table></figure>
<p>如果没有提供任何参数，分支的条件变为任意的Boolean表达式。</p>
<p><em>吐槽</em>: Kotlin没有模式解构，却用<code>when</code>这里奇奇怪怪的关键字+arbitrary objects来混分数。</p>
<h3 id="Smart-casts-combining-type-checks-and-casts"><a class="header-anchor" href="#Smart-casts-combining-type-checks-and-casts">¶</a>Smart casts: combining type checks and casts</h3>
<p>以算术运算式子为例，我们希望计算 (1 + 2) + 4 这样的算子，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Expr</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Num</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>): Expr</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sum</span>(<span class="keyword">val</span> left: Expr, <span class="keyword">val</span> right: Expr): Expr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(ex: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (e <span class="keyword">is</span> Num) &#123;</span><br><span class="line">    <span class="keyword">val</span> n = e <span class="keyword">as</span> Num	<span class="comment">// 显式地转换</span></span><br><span class="line">	<span class="keyword">return</span> n.value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (e <span class="keyword">is</span> Sum) &#123;</span><br><span class="line">    <span class="keyword">return</span> eval(e.right) + eval(e.left)  <span class="comment">// 变量e智能转换</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Unknown expression&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(eval(Sum(Sum(Num(<span class="number">1</span>), Num(<span class="number">2</span>)), Num(<span class="number">4</span>))))</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>这里的<code>eval</code>函数传入了参数类型<code>Expr</code>。编译器会另起一个对象存储转换的对象类型，这样不用显式的使用<code>as</code>关键字就可以访问它的属性。</p>
<h3 id="Refactoring-replacing-“if”-with-“when”"><a class="header-anchor" href="#Refactoring-replacing-“if”-with-“when”">¶</a>Refactoring: replacing “if” with “when”</h3>
<p>前面说过，<code>when</code>关键字可以处理表达式，因此可以简化上面的代码：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> = </span><br><span class="line">  <span class="keyword">when</span> (e) &#123;</span><br><span class="line">    <span class="keyword">is</span> Num -&gt; e.value	<span class="comment">// 检测参数的类型</span></span><br><span class="line">	<span class="keyword">is</span> Sum -&gt; eval(e.right) + eval(e.left)	<span class="comment">// 只能转换</span></span><br><span class="line">	<span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Unknown expression&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Blocks-as-branches-of-“if”-and-“when”"><a class="header-anchor" href="#Blocks-as-branches-of-“if”-and-“when”">¶</a>Blocks as branches of “if” and “when”</h3>
<p>语句块也可以作为表达式部分返回值。譬如你希望在上面的例子作日志，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">evalWithLogging</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">  <span class="keyword">when</span> (e) &#123;</span><br><span class="line">    <span class="keyword">is</span> Num -&gt; &#123;</span><br><span class="line">	  println(<span class="string">&quot;num: <span class="subst">$&#123;e.value&#125;</span>&quot;</span>)</span><br><span class="line">	  e.value</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">is</span> Sum -&gt; &#123;</span><br><span class="line">	  <span class="keyword">val</span> left = evalWithLogging(e.left)</span><br><span class="line">	  <span class="keyword">val</span> right = evalWithLogging(e.right)</span><br><span class="line">	  println(<span class="string">&quot;sum: <span class="variable">$left</span> + <span class="variable">$right</span>&quot;</span>)</span><br><span class="line">	  left + right</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Unknown expression&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&gt;&gt;&gt; println(evalWithLogging(Sum(Sum(Num(<span class="number">1</span>), Num(<span class="number">2</span>)), Num(<span class="number">4</span>))))</span><br><span class="line">num: <span class="number">1</span></span><br><span class="line">num: <span class="number">2</span></span><br><span class="line">sum: <span class="number">1</span> + <span class="number">2</span></span><br><span class="line">num: <span class="number">4</span></span><br><span class="line">sum: <span class="number">3</span> + <span class="number">4</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>
<h2 id="Iterating-over-things-“while”-and-“for”-loops"><a class="header-anchor" href="#Iterating-over-things-“while”-and-“for”-loops">¶</a>Iterating over things: “while” and “for” loops</h2>
<p>Kotlin中的迭代器原理是Java的复刻，不过语法上<code>for</code>的写法被改变了，Kotlin中引入了<code>range</code>的概念。</p>
<p>值域(range) 类似数学的区间、定义域，写法如下：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> oneToTen = <span class="number">1.</span><span class="number">.10</span></span><br></pre></td></tr></table></figure>
<p>不过基于坐标都是从0开始，Kotlin的开区间(inclusive)和闭区间(closed)，指的是第二个值是否被包含。</p>
<p>对值域的基本操作就是进行迭代操作，这样的值域称为 累进(progression)。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fizzBuzz</span><span class="params">(i: <span class="type">INt</span>)</span></span> = <span class="keyword">when</span> &#123;</span><br><span class="line">  i % <span class="number">15</span> == <span class="number">0</span> -&gt; <span class="string">&quot;FizzBuzz &quot;</span></span><br><span class="line">  i % <span class="number">3</span> == <span class="number">0</span> -&gt; <span class="string">&quot;Fizz &quot;</span></span><br><span class="line">  i % <span class="number">5</span> == <span class="number">0</span> -&gt; <span class="string">&quot;Buzz &quot;</span></span><br><span class="line">  <span class="keyword">else</span> -&gt; <span class="string">&quot;<span class="variable">$i</span> &quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;</span><br><span class="line">...   print(fizzBuzzI0))</span><br><span class="line">... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> Fizz <span class="number">4</span> Buzz Fizz <span class="number">7</span> ...</span><br></pre></td></tr></table></figure>
<p>你可以指定递增步长，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">100</span> downTo <span class="number">1</span> step <span class="number">2</span>) &#123;</span><br><span class="line">      print(fizzBuzz(i))</span><br><span class="line">    &#125;</span><br><span class="line">Buzz <span class="number">98</span> Fizz <span class="number">94</span> <span class="number">92</span> FizzBuzz <span class="number">88</span> ...</span><br></pre></td></tr></table></figure>
<p><code>step</code>步长可以是负数，<code>100 downTo 1</code>表示后退到1，因此实际效果是从100开始-2…</p>
<p>如果想要设定终止条件，可以写为<code>for (x in 0 until size)</code>，它等价于 <code>for (x in 0..size-1)</code> 。</p>
<h3 id="Iterating-over-maps"><a class="header-anchor" href="#Iterating-over-maps">¶</a>Iterating over maps</h3>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> binaryReps = TreeMap&lt;<span class="built_in">Char</span>, String&gt;()	<span class="comment">// 使用TreeMap已是的key是排序的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (c <span class="keyword">in</span> <span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">val</span> binary = Integer.toBinaryString(c.toInt())  <span class="comment">// 将ASCII转换为二进制</span></span><br><span class="line">  binaryReps[c] = binary</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((letter, binary) <span class="keyword">in</span> binaryReps) &#123;</span><br><span class="line">  println(<span class="string">&quot;<span class="variable">$letter</span> = <span class="variable">$binary</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>binaryReps[c] = binary</code> 等价于Java的 <code>binaryReps.put(c, binary)</code>。</p>
<p>你可以使用一些解包语法来获得迭代器的索引坐标，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = arrayListOf(<span class="string">&quot;10&quot;</span>, <span class="string">&quot;11&quot;</span>, <span class="string">&quot;1001&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> ((index, element) <span class="keyword">in</span> list.withIndex()) &#123;</span><br><span class="line">  println(<span class="string">&quot;<span class="variable">$index</span>: <span class="variable">$element</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Using-“in”-to-check-collection-and-range-membership"><a class="header-anchor" href="#Using-“in”-to-check-collection-and-range-membership">¶</a>Using “in” to check collection and range membership</h3>
<p>可以使用 <code>in</code> 和 <code>!in</code> 操作符来检测一个值是否在Range内，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isLetter</span><span class="params">(c: <span class="type">Char</span>)</span></span> = c <span class="keyword">in</span> <span class="string">&#x27;a&#x27;</span>..<span class="string">&#x27;z&#x27;</span> || c <span class="keyword">in</span> <span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isNotDigit</span><span class="params">(c: <span class="type">Char</span>)</span></span> = c !<span class="keyword">in</span> <span class="string">&#x27;0&#x27;</span>..<span class="string">&#x27;9&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(isLetter(<span class="string">&#x27;q&#x27;</span>))</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt;&gt;&gt; println(isNotDigit(<span class="string">&#x27;x&#x27;</span>))</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>还可以和<code>when</code>表达式结合使用，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">recognize</span><span class="params">(c: <span class="type">Char</span>)</span></span> = <span class="keyword">when</span> (c) &#123;</span><br><span class="line">  <span class="keyword">in</span> <span class="string">&#x27;0&#x27;</span>..<span class="string">&#x27;9&#x27;</span> -&gt; <span class="string">&quot;It&#x27;s a digit!&quot;</span></span><br><span class="line">  <span class="keyword">in</span> <span class="string">&#x27;a&#x27;</span>..<span class="string">&#x27;z&#x27;</span>, <span class="keyword">in</span> <span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span> -&gt; <span class="string">&quot;It&#x27;s a letter!&quot;</span></span><br><span class="line">  <span class="keyword">else</span> -&gt; <span class="string">&quot;I don&#x27;t know…&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(recognize(<span class="string">&#x27;8&#x27;</span>))</span><br><span class="line">It<span class="string">&#x27;s a digit</span></span><br></pre></td></tr></table></figure>
<p>Range不强制要求它的类型是字符或数字，任何满足<code>java.lang.Comparable</code>接口的类都可以作为Range的值调用，考虑下面的代码：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; println(<span class="string">&quot;Kotlin&quot;</span> <span class="keyword">in</span> <span class="string">&quot;Java&quot;</span>..<span class="string">&quot;Scala&quot;</span>)</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>为什么？它实际上对应于Java的<code>&quot;java&quot; &lt;= &quot;Kotlin&quot; &amp;&amp; &quot;Kotlin&quot; &lt;= &quot;Scala&quot;</code>，也就是调用了<code>compareTo</code>方法。</p>
<p>同理，对于<code>setOf</code>也是如此，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; println(<span class="string">&quot;Kotlin&quot;</span> <span class="keyword">in</span> setOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Scala&quot;</span>))  <span class="comment">// 是否在集合内`contain`</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="Exceptions-in-Kotlin"><a class="header-anchor" href="#Exceptions-in-Kotlin">¶</a>Exceptions in Kotlin</h2>
<p>Kotlin的异常处理和Java无异，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (percentage !<span class="keyword">in</span> <span class="number">0.</span><span class="number">.100</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;A percentage value must be between 0 and 100: <span class="variable">$percentage</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面描述过了，Kotlin不使用<code>new</code>关键字</p>
<p>和Java的不同在于，<code>throw</code>结构体也是一个表达式，可以作为其它表达式的一部分使用。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> percentage = </span><br><span class="line">  <span class="keyword">if</span> (number <span class="keyword">in</span> <span class="number">0.</span><span class="number">.100</span>)</span><br><span class="line">    number</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    <span class="comment">// &quot;throw&quot; is an expression.</span></span><br><span class="line">    <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;A percentage value must be between 0 and 100: <span class="variable">$number</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="“try”-“catch”-and-“finally”"><a class="header-anchor" href="#“try”-“catch”-and-“finally”">¶</a>“try”, “catch”, and “finally”</h3>
<p>你可以和Java一样在Kotlin中使用<code>try-catch-finally</code>三段式，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readNUmber</span><span class="params">(reader: <span class="type">BufferedReader</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> line = reader.readLine()</span><br><span class="line">	<span class="keyword">return</span> Integer.parseInt(line)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (e: NumberFormatException) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    reader.close()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> reader = BufferedReader(StringReader(<span class="string">&quot;239&quot;</span>))</span><br><span class="line">&gt;&gt;&gt; println(readerNumber(reader))</span><br><span class="line"><span class="number">239</span></span><br></pre></td></tr></table></figure>
<p>和Java最大的不同在于这里的代码不出现<code>throws</code>在方法签名中：Kotlin没有区分检查和非检查异常。以及对于java7的<code>try-with-resources</code>也没有特殊的语法作处理，Kotlin中被实现为一个库函数。</p>
<h3 id="“try”-as-an-expression"><a class="header-anchor" href="#“try”-as-an-expression">¶</a>“try” as an expression</h3>
<p>另外一个不同在于，Kotlin中所有的关键字都是表达式，包括<code>try</code>关键字，因此可以被作为返回值</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readNumber</span><span class="params">(reader: <span class="type">BufferedReader</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> number = <span class="keyword">try</span> &#123;</span><br><span class="line">    Integer.parseInt(reader.readLine())</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e: NumberFormatException) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(number)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> reader = BufferedReader(StringReader(<span class="string">&quot;no a number&quot;</span>))</span><br><span class="line">&gt;&gt;&gt; readNumber(reader)	<span class="comment">// 什么东西都没有打印</span></span><br></pre></td></tr></table></figure>
<p>在<code>catch</code>的时候被<code>return</code>了，所有打印语句没有执行。如果希望只需执行，可以在<code>catch</code>的块内添加一个值。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readNumber</span><span class="params">(reader: <span class="type">BufferedReader</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> number = <span class="keyword">try</span> &#123;</span><br><span class="line">    Integer.parseInt(reader.readLine())</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e: NumberFormatException) &#123;</span><br><span class="line">    <span class="literal">null</span>  <span class="comment">// null 被作为表达式返回了</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(number)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> reader = BufferedReader(StringReader(<span class="string">&quot;no a number&quot;</span>))</span><br><span class="line">&gt;&gt;&gt; readNumber(reader)</span><br></pre></td></tr></table></figure>
<h2 id="Summary"><a class="header-anchor" href="#Summary">¶</a>Summary</h2>
<ul>
<li><code>fun</code>关键字用于声明一个函数。<code>val</code>和<code>var</code>对应只读和可变值声明。</li>
<li>字符串模板使用<code>$&#123; &#125;</code>来避免样板代码。</li>
<li>值对象(VO, value-object)在Kotlin中被得到简化，accessor(getter/setter)+field被重新定义为属性(property)。</li>
<li><code>if</code>关键字被作为表达式。</li>
<li><code>when</code>表达式对应于Java的<code>switch</code>语句。</li>
<li>不需要显式地对类型进行转换，Kotlin提供了智能类型转换。</li>
<li><code>for</code>，<code>while</code>，和<code>do-while</code>和Java的类似，但Kotlin的<code>for</code>更简洁，功能更丰富。</li>
<li>这种简洁的<code>1..5</code>语法用于创建Range。通常用于组合<code>for</code>循环和<code>in</code>，<code>!in</code>操作符处理逻辑。</li>
<li>Kotlin的异常处理跟Java的如出一辙，但Kotlin不区分检查类异常和非检查类异常，以及不要求函数抛出异常，<code>try-catch-finally</code>关键字也是一个表达式，可以在适当的代码块内作为返回值。</li>
</ul>
<div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1">为什么高效？这段编译的代码会创建一个<code>StringBuilder</code>将常量部分和变量值进行追加。<a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div></div></article><nav class="article-nav"><div class="article-nav-prev">🔙<a href="/2021/07/29/kotlin/02_defining_and_calling_functions/">Kotlin 函数</a></div><div class="article-nav-next">🔜<a href="/2021/02/26/algorithm/pid/pid/">PID 算法，Feedback Control System</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2021/07/25/kotlin/01_kotlin_basics/';
var disqus_title = 'Kotlin 基础';
var disqus_url = 'https://galudisu.info/2021/07/25/kotlin/01_kotlin_basics/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>