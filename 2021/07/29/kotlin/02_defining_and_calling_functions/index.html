<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>Kotlin 函数</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">Kotlin 函数</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2021-07-29</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/kotlin/">kotlin</a></p></div><div class="article-content"><h2 id="主要内容"><a class="header-anchor" href="#主要内容">¶</a>主要内容</h2>
<ol>
<li>函数处理集合、字符串、正则表达式</li>
<li>使用命名参数，默认参数值，中缀调用</li>
<li>通过扩展函数和属性适配Java库</li>
<li>顶层代码结构，本地函数和属性</li>
</ol>
<h2 id="Creating-collections-in-Kotlin"><a class="header-anchor" href="#Creating-collections-in-Kotlin">¶</a>Creating collections in Kotlin</h2>
<p>创建一个新的Set，使用<code>setOf</code>函数。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">set</span> = hashSetOf(<span class="number">1</span>, <span class="number">7</span>, <span class="number">53</span>)</span><br></pre></td></tr></table></figure>
<p>对应地，创建数组list，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = arrayListOf(<span class="number">1</span>, <span class="number">7</span>, <span class="number">53</span>)</span><br><span class="line"><span class="keyword">val</span> map = hashMapOf(<span class="number">1</span> to <span class="string">&quot;one&quot;</span>, <span class="number">7</span> to <span class="string">&quot;seven&quot;</span>, <span class="number">53</span> to <span class="string">&quot;fifty-three&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>注意<code>to</code>不是一个具体的结构体，而是一个函数。</p>
<p>Kotlin的集合和Java对应，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; println(<span class="keyword">set</span>.javaClass)  <span class="comment">// javaClass 是Kotlin版的`getClass()`</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.<span class="title">util</span>.<span class="title">HashSet</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(list.javaClass)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.<span class="title">util</span>.<span class="title">ArrayList</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(map.javaClass)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.<span class="title">util</span>.<span class="title">HashMap</span></span><br></pre></td></tr></table></figure>
<p>为什么Kotlin不提供自己的集合库实现？还是那句话，方便和Java做集成。</p>
<p>Kotlin 的集合虽然和Java是一回事，但可以做更多事情。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> strings = listOf(<span class="string">&quot;first&quot;</span>, <span class="string">&quot;second&quot;</span>, <span class="string">&quot;fourtheenth&quot;</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(strings.last())</span><br><span class="line">fourteenth</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> numbers = setOf(<span class="number">1</span>, <span class="number">14</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(numbers.max())</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure>
<p>后面的内容会介绍lambda表达式，会更多用到集合的使用。</p>
<h2 id="Making-functions-easier-to-call"><a class="header-anchor" href="#Making-functions-easier-to-call">¶</a>Making functions easier to call</h2>
<p>Java集合有默认的<code>toString()</code>实现，但输出格式不尽人意：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt; println(list) <span class="comment">// 调用`toString()`</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>假设你想要覆盖它的方法实现，希望输出 <code>(1; 2; 3)</code> 。Java的解决办法是使用第三发库Guava或Apache Commons或自己实现。在Kotlin中提供了这方面的函数处理。</p>
<p>这里我们希望自己实现这个函数。我们实现<code>joinToString</code>函数，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">joinToString</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        collection: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;, </span></span></span><br><span class="line"><span class="params"><span class="function">        separator: <span class="type">String</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">		prefix: <span class="type">String</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">		postfix: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">  <span class="keyword">val</span> result = StringBuffer(prefix)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ((index, element) <span class="keyword">in</span> collection.withIndex()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">0</span>) result.append(separator) <span class="comment">// 除了第一个元素，前面追加分隔符</span></span><br><span class="line">    result.append(element)</span><br><span class="line">  &#125;</span><br><span class="line">  result.append(postfix)</span><br><span class="line">  <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数是通用的：对任何元素类型的集合都生效。泛型的语法和Java类似。</p>
<p>下面verify一下函数是否如是：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt; println(joinToString(list, <span class="string">&quot;; &quot;</span>, <span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>))</span><br><span class="line">(<span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>函数实现友好。下面关注点是，怎么声明函数函数已使得调用的时候减少冗余？每次调用函数的时候减少非必要参数的传递。</p>
<h3 id="Named-arguments"><a class="header-anchor" href="#Named-arguments">¶</a>Named arguments</h3>
<p>第一个问题我们将会定位关注的是函数的可读性。例如下面对<code>joinToString</code>的调用：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">joinToString(collection, <span class="string">&quot; &quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;.&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>如果不看方法签名的话，可能不知道这些点号逗号都是啥。虽然IDE工具可以帮到你，但调用的时候并不明显。</p>
<p>这里问题对于参数类型为Boolean尤其明显。Java应对的做法是推荐创建枚举带代替Boolean。甚至有些会让你加注释。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">joinToString(collection, <span class="comment">/* separator */</span> <span class="string">&quot; &quot;</span>, <span class="comment">/* preifx */</span> <span class="string">&quot; &quot;</span>, <span class="comment">/* postfix */</span> <span class="string">&quot;.&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>使用Kotlin，可以做得更好：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">joinToString(collection, separator = <span class="string">&quot; &quot;</span>, prefix = <span class="string">&quot; &quot;</span>, postfix = <span class="string">&quot;.&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>Kotlin函数调用时，可以指定参数名来避免误解。</p>
<h3 id="Default-parameter-values"><a class="header-anchor" href="#Default-parameter-values">¶</a>Default parameter values</h3>
<p>另外一个Java常见的问题是过于丰富的重载方法。看看<code>java.lang.Thread</code>类以及它的构造函数。基于兼容性和用户友好的API考量提供重构，但最终的结果是一致的：重复。参数名和返回类型被重复了多次。另外，如果调用一个重载方法省略某些参数，又会显得不明显，不知调用的是哪些参数。</p>
<p>在Kotlin，你可以避免重复创建重载方法。因为你可以在函数声明时指定默认值。下面我们重构<code>joinToString</code>函数。默认值参数通常被用作大部分case适用性。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">joinToString</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        collection: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        separator: <span class="type">String</span> = <span class="string">&quot;, &quot;</span>,  <span class="comment">// 带默认值参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">        prefix: <span class="type">String</span> = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        postfix: <span class="type">String</span> = <span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: String</span><br></pre></td></tr></table></figure>
<p>现在你既可以调用函数带所有参数，亦或者省略默认值部分：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; joinToString(list, <span class="string">&quot;, &quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">&gt;&gt;&gt; joinToString(list)</span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">&gt;&gt;&gt; joinToString(list, <span class="string">&quot;; &quot;</span>)</span><br><span class="line"><span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>如果使用常规调用语法，你必须按照函数声明顺序指定参数，仅可以省略尾部参数(trailing arguments)。如果你使用命名参数，你可以省略参数列表的中间部分参数，并指定一个你需要用到的值，并且顺序不作要求：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; joinToString(list, suffix = <span class="string">&quot;;&quot;</span>, prefix = <span class="string">&quot;# &quot;</span>)</span><br><span class="line"># <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>注意，参数的默认值在函数调用时被编码了，不是在调用方编码。如果重新编译class类时包含该函数，并改变参数的默认值，调用者再次调用该函数不指定默认值时会使用新的值。</p>
<blockquote>
<p><strong>Default values and Java</strong><br>
Java 没有默认参数值的概念，通过Java调用Kotlin的带默认参数时，需要显式指定所有参数值。如果你需要频繁地从Java调用Kotlin的函数，你可以使用<code>@JvmOverloads</code>注解。它会在编译期生成对应的Java的overloaded方法，从最后一个参数开始逐个省略参数并赋予默认值。</p>
<p>例如，如果你使用<code>@JvmOverloads</code>注解<code>joinToString</code>，会生成下面的重载方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Java */</span></span><br><span class="line">String <span class="title function_">joinToString</span><span class="params">(Collection&lt;T&gt; collection, String separator, String prefix, String postfix)</span>;</span><br><span class="line">String <span class="title function_">joinToString</span><span class="params">(Collection&lt;T&gt; collection, String separator, String prefix)</span>;</span><br><span class="line">String <span class="title function_">joinToString</span><span class="params">(Collection&lt;T&gt; collection, String separator)</span>;</span><br><span class="line">String <span class="title function_">joinToString</span><span class="params">(Collection&lt;T&gt; collection)</span>;</span><br></pre></td></tr></table></figure>
<p>每重载一个方法就从方法签名省略最后一个默认值。</p>
</blockquote>
<p>目前为止，你看到的这类工具类(utility)函数并没有包含在某些类内，这样正确吗？实际上，Kotlin认为工具类是非必要的。</p>
<h3 id="Getting-rid-of-static-utility-classes-top-level-functions-and-properties"><a class="header-anchor" href="#Getting-rid-of-static-utility-classes-top-level-functions-and-properties">¶</a>Getting rid of static utility classes: top-level functions and properties</h3>
<p>我们都知道Java是一门面向对象语言，要求所有方法代码写在类内。通常，这中实现是好的。但现实是，几乎每个大型项目带有大量的代码，这些代码实际不属于任何某个类。有时某个对象对协作的两个或多个类起到等价的重要性；有时会有某个主要的对象，并不希望实例化时传递它的API，但不开发它的API又无法在子类继承。</p>
<p>最终的结果可能是，你会将那些不包含状态或实例的方法包装成静态方法。最明显的例子就是JDK中的<code>Collections</code>。另外一个明显的例子就是，你的项目代码中会有大量的<code>*Util</code>命名的代码。</p>
<p>在Kotlin，你不需要创建所有这些无意义的类。相反，你可以直接将函数放置在源文件的最顶层，其它类的任何地方。这些函数仍然是package的成员属性，所以你可以通过import方式访问。</p>
<p>譬如我们将<code>joinToString</code>函数直接放置在<code>strings</code>包层级。创建一个文件join.kt内容如下：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strings</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">joinToString</span><span class="params">(...)</span></span>: String &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>怎么跑起来？你知道，当编译文件时，某些类会被产生，因为JVM仅在类内执行代码。当使用Kotlin工作时，需要知道。通过Java调用kotlin函数时，会编译成对应如下的Java类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Java */</span></span><br><span class="line"><span class="keyword">package</span> strings;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinKt</span> &#123;  <span class="comment">// Corresponds to join.kt, the filename of listing</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">joinToString</span><span class="params">(...)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kotlin 编译生成的类名对应于文件名。文件内容的顶层函数则编译到了该类里面的静态方法。因此，如果通过Java来调用Kotlin会非常简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Java */</span></span><br><span class="line"><span class="keyword">import</span> strings.JoinKt;</span><br><span class="line">...</span><br><span class="line">JoinKt.joinToString(list, <span class="string">&quot;, &quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Changing the file class name</strong><br>
默认地，Kotlin的文件顶层函数包装的类名对应于文件名；如果想要修改类型。可以添加<code>@JvmName</code>注解到文件最开始位置。要在包定义前：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@file:JvmName</span>(<span class="string">&quot;StringFunctions&quot;</span>)  <span class="comment">// 指定类名</span></span><br><span class="line"><span class="keyword">package</span> strings <span class="comment">// 包语句要跟在文件注解之后</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">joinToString</span><span class="params">(...)</span></span>: String &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>现在函数的Java调用变为了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Java */</span></span><br><span class="line"><span class="keyword">import</span> strings.StringFunctions;</span><br><span class="line">StringFunctions.joinToString(list, <span class="string">&quot;, &quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>注解部分内容会在后面章节介绍。</p>
</blockquote>
<p><strong>TOP-LEVEL PROPERTIES</strong></p>
<p>和函数一样，属性也可以放置在文件的顶层。将独立的数据存储在类外部并不常见但很有效。</p>
<p>例如，使用<code>var</code>属性统计操作执行的次数。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> opCount = <span class="number">0</span>  <span class="comment">// 声明一个顶层属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">performOperation</span><span class="params">()</span></span> &#123;</span><br><span class="line">  opCount++ <span class="comment">// 更改属性的值</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">reportOperationCount</span><span class="params">()</span></span> &#123;</span><br><span class="line">  println(<span class="string">&quot;Operation performed <span class="variable">$opCount</span> times&quot;</span>) <span class="comment">// 读取属性值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这类属性值会被存储在一个静态字段。</p>
<p>Top-Level的properties允许你定义常量：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> UNIX_LINE_SEPARATOR = <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>
<p>默认地，Top-Level的properties会相应保留其accessor方法给Java方法调用。但如果你想作为Java的常量<code>public static final</code>字段，可以使用<code>const</code>修饰符：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> UNIX_LINE_SEPARATOR = <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>
<p>它实际上等价于Java代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UNIX_LINE_SEPARATOR</span> <span class="operator">=</span> <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Adding-methods-to-other-people’s-classes-extension-functions-and-properties"><a class="header-anchor" href="#Adding-methods-to-other-people’s-classes-extension-functions-and-properties">¶</a>Adding methods to other people’s classes: extension functions and properties</h2>
<p>Kotlin的一个主题曲是平滑地集成已有的代码。甚至纯粹的Kotlin项目构建于JDK库、Android框架、第三方框架。当你要将Kotlin集成到一个Java项目，你通常需要处理存在的代码，这部分代码不会被或不可能被转换为Kotlin。使用原有的优良的API而不必要转换它这不是好事吗？这就是扩展函数允许你做的事情。</p>
<p>概念上，<code>extension function</code> 是个简单的东西：它是一个可以作为类成员调用的函数进行调用，但却定义在该类的外部。为了证实它，下面添加了一个方法用于计算最后一个字符串的字节数：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strings</span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastChar</span><span class="params">()</span></span>: <span class="built_in">Char</span> = <span class="keyword">this</span>.<span class="keyword">get</span>(<span class="keyword">this</span>.length - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>你需要做的是，将需要进行扩展的类名或接口名放在定义函数名前。类名称为 <em>receiver type</em> ；扩展函数的值部分称为 <em>receiver object</em>. 如下图：</p>
<p><img src="/img/kotlin-in-action/chapter03/Figure_03_01.png" alt="Figure 3.1"></p>
<p>你可以以普通类成员的语法形式使用该函数：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; println(<span class="string">&quot;Kotlin&quot;</span>.lastChar())</span><br><span class="line">n</span><br></pre></td></tr></table></figure>
<p>在该例子中，<code>String</code>是接收者类型(receiver type)，<code>&quot;Kotlin&quot;</code>是接收者对象(receiver object).</p>
<p>在某种意义上，你往<code>String</code>类添加了自定义方法。尽管<code>String</code>不是你代码的一部分，甚至你可能没有该类的源码，你仍然可以对其进行方法扩展。并不需要关系<code>String</code>到底是Java写的、Kotlin写的还是其他JVM语言写的，譬如Groovy。只要它能被编译成Java类，你就可以对其进行方法扩展。</p>
<p>在扩展函数的body部分，你可以使用<code>this</code>来表示对应的类。实际上你可以省略：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strings</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastChar</span><span class="params">()</span></span>: <span class="built_in">Char</span> = <span class="keyword">get</span>(length - <span class="number">1</span>) <span class="comment">// Receiver object members can be accessed without &quot;this&quot;.</span></span><br></pre></td></tr></table></figure>
<p>在extension function，你可以直接访问其自身内部的方法和属性，因为该方法定义的就是它自身。但值得注意的是，extension函数不允许你打破其封装。不像在类内定义方法，extension函数不允许访问private或protected的成员。</p>
<p>后面我们将使用到<code>method</code>术语来描述extension函数。例如，我们可以说extension函数的body部分调用了receiver的任意method，意味着你可以调用成员方法，也可以调用extension函数本身。而对于调用方，extension 函数区分于成员属性，因为它是被定义在类外部的，也就是说不关心这个特殊的方法是作为一个member还是作为一个extension。</p>
<h3 id="Imports-and-extension-functions"><a class="header-anchor" href="#Imports-and-extension-functions">¶</a>Imports and extension functions</h3>
<p>当你定义一个扩展函数，并不会自动地在你整个项目中可用。相反，它需要被导入，就和其它类或函数一样。这样有助于避免名字冲突。Kotlin允许你导入独自的函数：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> strings.lastChar</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> c = <span class="string">&quot;Kotlin&quot;</span>.lastChar()</span><br></pre></td></tr></table></figure>
<p>当然，<code>*</code>号的导入也是OK的：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> strings.*</span><br><span class="line"><span class="keyword">val</span> c = <span class="string">&quot;Kotlin&quot;</span>.lastChar()</span><br></pre></td></tr></table></figure>
<p>你可以使用<code>as</code>关键字来更改导入的类或函数名</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> strings.lastChar <span class="keyword">as</span> last</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> c = <span class="string">&quot;Kotlin&quot;</span>.last()</span><br></pre></td></tr></table></figure>
<p>import是更改原有的名字是个常态化行为。因为你可能会用到不同的包名和类名或方法名相同的情况。</p>
<h3 id="Calling-extension-functions-from-Java"><a class="header-anchor" href="#Calling-extension-functions-from-Java">¶</a>Calling extension functions from Java</h3>
<p>在底层，extension函数实际上是一个静态方法，第一个参数为receiver object实例传入。调用该函数实际上并没有涉及到适配对象的创建或任何其他运行时的额外开销。</p>
<p>这使得从Java调用扩展函数变得相当容易：直接调用该静态函数，然后传递receiver对象实例即可。就像其他top-level函数一样，包含该静态方法的Java类名，取决于该函数声明的文件名的声明。假设改方法声明在一个StringUtil.kt的文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> StringUtilKt.lastChar(<span class="string">&quot;Java&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>扩展函数被声明为一个top-level函数，因此它被编译为一个静态方法。你可以在Java中静态地引入<code>lastChar</code>方法，最简单的写法是<code>lastChar(&quot;Java&quot;)</code>。这种代码写法在Kotlin版本易读性差一点，在Java语言层面反而很顺畅。</p>
<h3 id="Utility-functions-as-extensions"><a class="header-anchor" href="#Utility-functions-as-extensions">¶</a>Utility functions as extensions</h3>
<p>现在我们来编写最终版的<code>joinToString</code>函数。这其实会在Kotlin标准库中有很多类似的地方：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Collection<span class="type">&lt;T&gt;</span>.<span class="title">joinToString</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        separator: <span class="type">String</span> = <span class="string">&quot;, &quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        prefix: <span class="type">String</span> = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        postfix: <span class="type">String</span> = <span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder(prefix)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ((index, element0 <span class="keyword">in</span> <span class="keyword">this</span>.withIndex())</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>) result.append(separator)</span><br><span class="line">        result.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    result.append(postfix)</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt; println(list.joinToString(separator = <span class="string">&quot;; &quot;</span>,</span><br><span class="line">...     prefix = <span class="string">&quot;(&quot;</span>, postfix = <span class="string">&quot;)&quot;</span>))</span><br><span class="line">(<span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>这里为所有参数都提供了默认值。所以现在你可以像调用member成员一样调用该方法：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> list = arrayListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt; println(list.joinToString(<span class="string">&quot; &quot;</span>))</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>因为扩展函数实际上是静态方法的高效语法糖，你可以使用更多的指定类型的receiver type，不仅仅是一个类。譬如：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Collection<span class="type">&lt;String&gt;</span>.<span class="title">join</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        separator: <span class="type">String</span> = <span class="string">&quot;, &quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        prefix: <span class="type">String</span> = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        postfix: <span class="type">String</span> = <span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> = joinToString(separator, preifx, postfix)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(listOf(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;eight&quot;</span>).join(<span class="string">&quot; &quot;</span>))</span><br><span class="line">one two eight</span><br></pre></td></tr></table></figure>
<p>这类函数如果使用其它类型不会生效：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>).join()</span><br><span class="line">Error: Type mismatch: inferred type <span class="keyword">is</span> List&lt;<span class="built_in">Int</span>&gt; but Collection&lt;String&gt;</span><br><span class="line">was expected.</span><br></pre></td></tr></table></figure>
<p>这也意味着扩展函数不能在子类中进行重载(override)。</p>
<h3 id="No-overriding-for-extension-functions"><a class="header-anchor" href="#No-overriding-for-extension-functions">¶</a>No overriding for extension functions</h3>
<p>Kotlin中成员函数(member function)的重载是可行的，但对于extension function的重载是禁止的。假设我们有两个类，<code>View</code>和它的子类<code>Button</code>，<code>Button</code>类可以重载父类的<code>click</code>函数。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">clock</span><span class="params">()</span></span>  = println(<span class="string">&quot;View clocked&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span>: <span class="type">View</span>() &#123;  <span class="comment">// Button extends View.</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> = println(<span class="string">&quot;Button clocked&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你声明了一个类型为<code>View</code>的变量，你可以使用该变量存储类型为<code>Button</code>的值，因为<code>Button</code>是<code>View</code>的子类。如果你调用一个常规的方法，例如这里的<code>click</code>，由于<code>Button</code>类进行了重载，所以实际上它是调用了<code>Button</code>的<code>click</code>的实现部分代码：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> view: View -= Button()</span><br><span class="line">&gt;&gt;&gt; view.click() <span class="comment">// Determines the method to call based on the actual value of &quot;view&quot;</span></span><br><span class="line"></span><br><span class="line">Button clicked</span><br></pre></td></tr></table></figure>
<p>但是这种方式对于extension function不起作用，如图figure 3.2 。</p>
<p>extension function并不是类的一部分；他们在类外部被声明。尽管你可以定义跟基础类内方法名同名的扩展函数，但函数的调用取决于变量的静态声明类型，而不是运行时存储的变量类型。</p>
<p><img src="/img/kotlin-in-action/chapter03/Figure_03_02.png" alt="Figure 3.2"></p>
<p>下面例子展示了同名的<code>showOff</code>扩展函数的声明。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">showOff</span><span class="params">()</span></span> = println(<span class="string">&quot;I&#x27;m a view!&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> Button.<span class="title">showOff</span><span class="params">()</span></span> = println(<span class="string">&quot;I&#x27;m a button!&quot;</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> view: View = Button()</span><br><span class="line">&gt;&gt;&gt; view.showOff()</span><br><span class="line">I<span class="string">&#x27;m a view!  // The extension function is resolved statically.</span></span><br></pre></td></tr></table></figure>
<p>扩展函数是被静态处理的。如果你在Java中调用这函数时就一点不会感到惊讶：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Java */</span></span><br><span class="line">&gt;&gt;&gt; <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>();</span><br><span class="line">&gt;&gt;&gt; ExtensionsKt.showOff(view);</span><br><span class="line">I<span class="string">&#x27;m a view! // showOff functions are declared in the extensions.kt file.</span></span><br></pre></td></tr></table></figure>
<p>Kotlin中对extension function不支持重载，它被静态处理。</p>
<blockquote>
<p><strong>NOTE</strong><br>
如果一个类内部包含同名的成员函数和扩展函数。成员函数(member function)总是优先处理。</p>
</blockquote>
<h3 id="Extension-properties"><a class="header-anchor" href="#Extension-properties">¶</a>Extension properties</h3>
<p>扩展属性和扩展函数具有相似的语法和行为。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> String.lastChar: <span class="built_in">Char</span></span><br><span class="line">  <span class="keyword">get</span>() = <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>扩展属性带有receiver type，其它地方和常规的properties差不多。并且getter必须总是被定义，因为它没有被定义在类，没有后背的字段值也没有默认的getter实现。初始化器(initializers)不允许这种情况发生，因此getter必须定义。</p>
<p>如果你要在<code>StringBuilder</code>上定义相同的属性，你可以使用<code>var</code>，因为<code>StringBuilder</code>的内容是可以被修改的：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> StringBuilder.lastChar: <span class="built_in">Char</span> </span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">set</span>(value: <span class="built_in">Char</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setCharAt(length - <span class="number">1</span>, value)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以及，你可以像成员属性一样方法扩展属性：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; println(<span class="string">&quot;Kotlin&quot;</span>.lastChar)</span><br><span class="line">n</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> sb = StringBuilder(<span class="string">&quot;Koltin?&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; sb.lastChar = <span class="string">&#x27;!&#x27;</span></span><br><span class="line">&gt;&gt;&gt; println(sb)</span><br><span class="line">Kotlin!</span><br></pre></td></tr></table></figure>
<p>需要在Java中访问扩展属性是，你应该显式地调用它的getter：<code>StringUtilKt.getLastChar(&quot;Java&quot;)</code></p>
<h2 id="Working-with-collections-varargs-infix-calls-and-library-support"><a class="header-anchor" href="#Working-with-collections-varargs-infix-calls-and-library-support">¶</a>Working with collections: varargs, infix calls, and library support</h2>
<p>该小节会展示一些Kotlin方式的集合库的调用，包括有：</p>
<ul>
<li><code>vararg</code>关键字，允许你声明一个字面量类型函数</li>
<li><code>infix</code>符号调用某些一个参数的函数</li>
<li><code>Destructuring declarations</code> 结构一个组合值到多个变量</li>
</ul>
<h3 id="Extending-the-Java-Collections-API"><a class="header-anchor" href="#Extending-the-Java-Collections-API">¶</a>Extending the Java Collections API</h3>
<p>从本章开始会留意到Kotlin的集合类和Java的集合类是相同的，但有extend API。譬如之前的例子：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> strings: List&lt;String&gt; = listOf(<span class="string">&quot;first&quot;</span>, <span class="string">&quot;second&quot;</span>, <span class="string">&quot;fourteenth&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; strings.last()</span><br><span class="line">fourteenth</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> numbers: Collection&lt;<span class="built_in">Int</span>&gt; = setOf(<span class="number">1</span>, <span class="number">14</span>, <span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt; numbers.max()</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure>
<p>其中<code>last</code>和<code>max</code>函数为extension function。</p>
<p><code>last</code>和<code>max</code>扩展函数的声明如下：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> List<span class="type">&lt;T&gt;</span>.<span class="title">last</span><span class="params">()</span></span>: T &#123; <span class="comment">/* return sthe last element */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> Collection<span class="type">&lt;Int&gt;</span>.<span class="title">max</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123; <span class="comment">/* finding a maximum in a collection */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>大多数的扩展函数会被声明在Kotlin的标准库中，这里不一一列表。你可能想方设法去学习Kotlin标准库。实际上没必要——任何时候在任何对象需要用到集合相关的内容时，IDE编辑器会提示相应对象的可能选项。IDE的代码提示会包含常规方法(regular method)和扩展函数(extension function)；你可以选择你需要的函数。另外，标准库也引用列表所有出该类内所有可用的方法列表和扩展列表(包括properties、extensions).</p>
<p>在章节开始的部分看到如何创建集合。这些集合的调用参数为任意数字。</p>
<h3 id="Varargs-functions-that-accept-an-arbitrary-number-of-arguments"><a class="header-anchor" href="#Varargs-functions-that-accept-an-arbitrary-number-of-arguments">¶</a>Varargs: functions that accept an arbitrary number of arguments</h3>
<p>当你调用函数来创建一个list时，你可以传递任何数字型的参数：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>)</span><br></pre></td></tr></table></figure>
<p>该函数在标准库的定义如下：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> listOf<span class="type">&lt;T&gt;</span><span class="params">(<span class="keyword">vararg</span> values: <span class="type">T</span>)</span></span>: List&lt;T&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>你可能会熟悉Java的vararg：允许传递数字型字面值到一个方法并包装到一个数组中。Kotlin的vararg和Java如出一辙，但语法上有明显的区别：Java中采取形如<code>main(String args...)</code>的形式，Kotlin中使用<code>vararg</code>修改器标记。</p>
<p>另一个不同的地方是，Kotlin的语法表述上要求传入的是一个包装好的数组。Java的三点形式的参数不要求传递单个或多个。技术上，这种特性被称为 <strong>扩展符(spread operator)</strong>，对于要传入的数组使用<code>*</code>符号进行扩展：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="string">&quot;args: &quot;</span>, *args)  <span class="comment">// Spread operator unpacks the array contents</span></span><br><span class="line">    println(list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Working-with-pairs-infix-calls-and-destructuring-declarations"><a class="header-anchor" href="#Working-with-pairs-infix-calls-and-destructuring-declarations">¶</a>Working with pairs: infix calls and destructuring declarations</h3>
<p>要创建map，使用<code>mapOf</code>函数：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = mapOf(<span class="number">1</span> to <span class="string">&quot;one&quot;</span>, <span class="number">7</span> to <span class="string">&quot;seven&quot;</span>, <span class="number">53</span> to <span class="string">&quot;fifty-three&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>单词<code>to</code>在代码行中并不是内置结构体，而是一个特殊的方法调用，称为 <strong><code>中缀调用(infix call)</code></strong> 。</p>
<p>中缀调用就是方法名处于两个参数对象之间的意思，并且不带任何分隔符。实际上下面这两种调用是等价的：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>to(<span class="string">&quot;one&quot;</span>) <span class="comment">// 常规模式</span></span><br><span class="line"><span class="number">1</span> to <span class="string">&quot;one&quot;</span>  <span class="comment">// 中缀调用</span></span><br></pre></td></tr></table></figure>
<p>两种调用方式的参数相同，要允许一个函数使用中缀记法，需要在函数签名前面使用<code>infix</code>修饰符。下面是<code>to</code>函数的简单写法：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> Any.<span class="title">to</span><span class="params">(other: <span class="type">Any</span>)</span></span> = Pair(<span class="keyword">this</span>, other)</span><br></pre></td></tr></table></figure>
<p><code>to</code>函数返回一个实例<code>Pair</code>，它是Kotlin标准库类，表示一对元素。实际上<code>Pair</code>的<code>to</code>声明使用了泛型，不过这里省略掉以方便描述。</p>
<p>注意<code>Pair</code>可以直接用于初始化变量：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (number, name) = <span class="number">1</span> to <span class="string">&quot;one&quot;</span></span><br></pre></td></tr></table></figure>
<p>该特性称为 <strong><code>声明解构(destructuring declaration)</code></strong>。</p>
<p><strong>NOTE</strong> 声明解构不是模式解构，仅限于变量声明；做不到类似rust的match匹配。<code>when</code>更不是模式匹配，而是Java的一种<code>instanceOf</code>做得不伦不类。</p>
<p>声明解构不局限于pair。也可作用于loop循环，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((index, element) <span class="keyword">in</span> collection.withIndex()) &#123;</span><br><span class="line">  println(<span class="string">&quot;<span class="variable">$index</span>: <span class="variable">$element</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>to</code>函数是一个扩展函数。你可以创建任意类型的pair：<code>1 to &quot;one&quot;</code>、<code>&quot;one&quot; to 1</code>、<code>list to list.size()</code>等等。让我们看看<code>mapOf</code>函数的声明：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> <span class="title">mapOf</span><span class="params">(<span class="keyword">vararg</span> values: <span class="type">Pair</span>&lt;<span class="type">K</span>, V&gt;)</span></span>: Map&lt;K, V&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Working-with-strings-and-regular-expressions"><a class="header-anchor" href="#Working-with-strings-and-regular-expressions">¶</a>Working with strings and regular expressions</h2>
<p>Kotlin的字符串和Java 的字符串是一回事。因此，Kotlin标准库中定义的有关字符串的函数或方法可以直接在Java代码中使用。Kotlin标准库中对于字符串没有作任何额外的封装，其中包含了大量的扩展函数(extension functions)。</p>
<h3 id="Splitting-strings"><a class="header-anchor" href="#Splitting-strings">¶</a>Splitting strings</h3>
<p><code>split</code>字符串在Java中也有。Kotlin中对<code>split</code>作了增强。譬如支持正则表达式：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; println(<span class="string">&quot;12.345-6.A&quot;</span>.split(<span class="string">&quot;\\.|-&quot;</span>.toRegex()))</span><br><span class="line">[<span class="number">12</span>, <span class="number">345</span>, <span class="number">6</span>, A]</span><br></pre></td></tr></table></figure>
<p>又或者写成任意个数分隔字符的形式，对应于前面说到的<code>vararg</code>。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; println(<span class="number">12.345</span>-<span class="number">6.</span>A<span class="string">&quot;.split(&quot;</span>.<span class="string">&quot;, &quot;</span>-<span class="string">&quot;))</span></span><br><span class="line"><span class="string">[12, 345, 6, A]</span></span><br></pre></td></tr></table></figure>
<h3 id="Regular-expressions-and-triple-quoted-strings"><a class="header-anchor" href="#Regular-expressions-and-triple-quoted-strings">¶</a>Regular expressions and triple-quoted strings</h3>
<p>(略，没有亮点)</p>
<h3 id="Multiline-triple-quoted-strings"><a class="header-anchor" href="#Multiline-triple-quoted-strings">¶</a>Multiline triple-quoted strings</h3>
<p>多行三引号字符串。该特性允许将超大字符串以更美观的方式进行多行表述。实际上还是一个字符串。类似scala语言的trim。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> kotlinLogo = <span class="string">&quot;&quot;&quot;| //</span></span><br><span class="line"><span class="string">                   .|//</span></span><br><span class="line"><span class="string">                   .|/ \&quot;&quot;&quot;</span></span><br><span class="line">&gt;&gt;&gt; println(kotlinLogo.trimMargin(<span class="string">&quot;.&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>其中，上面的点号可以不写，换成<code>trimMargin(&quot;&quot;)</code>。三引号字符串也可以压缩成一行的写法<code>&quot;&quot;&quot;C:\Users\&lt;yourname&gt;\kotlin-book&quot;&quot;&quot;</code>。</p>
<h2 id="Making-your-code-tidy-local-functions-and-extensions"><a class="header-anchor" href="#Making-your-code-tidy-local-functions-and-extensions">¶</a>Making your code tidy: local functions and extensions</h2>
<p>遵循于DRY原则(Don’t Repeat Yourself)。Kotlin允许使用本地函数的方式来简化重复代码或者样板代码。譬如下面例子：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String, <span class="keyword">val</span> address: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> (user.name.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> IllegalArgumentException(</span><br><span class="line"><span class="string">&quot;Can&#x27;t save user <span class="subst">$&#123;user.id&#125;</span>: empty Name&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (user.address.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> IllegalArgumentException(</span><br><span class="line"><span class="string">&quot;Can&#x27;t save user <span class="subst">$&#123;user.id&#125;</span>: empty Address&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Save user to the database</span></span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt; saveUser(User(<span class="number">1</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">java.lang.IllegalArgumentException: Can<span class="string">&#x27;t save user 1: empty Name</span></span><br></pre></td></tr></table></figure>
<p>上面的两处<code>if</code>语句包含的重复的部分。如果将校验部分写成本地函数，会让代码简洁很多。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String, <span class="keyword">val</span> address: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(user: <span class="type">User</span>, value: <span class="type">String</span>, fieldName: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Can&#x27;t save user <span class="subst">$&#123;user.id&#125;</span>: empty <span class="variable">$fieldName</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    validate(user, user.name, <span class="string">&quot;Name&quot;</span>)        <span class="comment">// Calls the local function to validate the specific fields</span></span><br><span class="line">    validate(user, user.address, <span class="string">&quot;Address&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外本地函数由于在语句块内，可以直接访问生成的参数，user可以省略。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String, <span class="keyword">val</span> address: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(value: <span class="type">String</span>, fieldName: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Can&#x27;t save user <span class="subst">$&#123;user.id&#125;</span>: empty <span class="variable">$fieldName</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    validate(user, user.name, <span class="string">&quot;Name&quot;</span>)        <span class="comment">// Calls the local function to validate the specific fields</span></span><br><span class="line">    validate(user, user.address, <span class="string">&quot;Address&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了让代码逻辑更清晰，你可以将validation 逻辑更改为<code>User</code>类的扩展函数，因为它仅属于该类的部分。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String, <span class="keyword">val</span> address: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> User.<span class="title">validateBeforeSave</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(value: <span class="type">String</span>, fieldName: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Can&#x27;t save user <span class="variable">$id</span>: emtpy <span class="variable">$fieldName</span>&quot;</span>) <span class="comment">// You can access properties of User directly.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    validate(name, <span class="string">&quot;Name&quot;</span>)</span><br><span class="line">    validate(address, <span class="string">&quot;Address&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">    user.validateBeforeSave()  <span class="comment">// Calls the extension function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，扩展函数也可以本地函数，即本地函数里面再嵌套本地函数，不过这种写法可读性并不好。</p>
<h2 id="Summary"><a class="header-anchor" href="#Summary">¶</a>Summary</h2>
<ul>
<li>Kotlin并没有定义自己的集合类，而是在Java集合的基础上作扩展。</li>
<li>定义函数参数的默认值可以减少函数的重载，函数命名参数(named-argument)的调用方法可读性更加良好。</li>
<li>函数(functions)和属性(properties)可以直接作为kt文件的top-level。不仅可以作为一个类的成员属性，允许更灵活的代码结构。</li>
<li>扩展函数(extension functions)和扩展属性(extension properties)相当于对已有类的扩展实现，包括对已有标准库类的函数和属性的扩展，它的原理是编程成对应的static方法，所以它不是基于运行时的，不会有额外的运行时开销。</li>
<li>中缀调用(infix call)提供了一种清晰的语法体验。</li>
<li>Kotlin提供了大量的有关字符串的处理方法和语法。</li>
<li>三重引号(triple-quoted)字符串提供了一种清晰的字符串语法表述。</li>
<li>本地函数帮助你优化代码减少重复代码和样板代码的实现。</li>
</ul>
</div></article><nav class="article-nav"><div class="article-nav-prev">🔙<a href="/2021/08/23/kotlin/03_classes_objects_and_interfaces/">类，对象，接口</a></div><div class="article-nav-next">🔜<a href="/2021/07/25/kotlin/01_kotlin_basics/">Kotlin 基础</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2021/07/29/kotlin/02_defining_and_calling_functions/';
var disqus_title = 'Kotlin 函数';
var disqus_url = 'https://galudisu.info/2021/07/29/kotlin/02_defining_and_calling_functions/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>