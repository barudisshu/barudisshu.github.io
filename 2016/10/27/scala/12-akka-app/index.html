<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>第十二章：Akka构建扩展、分布式应用</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">第十二章：Akka构建扩展、分布式应用</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2016-10-27</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/scala/">scala</a></p><p class="meta-item meta-category"><span class="meta-item-title"></span><i class="icon-bookmark"> </i><a class="category-link" href="/categories/learning/">learning</a></p></div><div class="article-content"><h4 id="主要内容："><a class="header-anchor" href="#主要内容：">¶</a>主要内容：</h4>
<ol>
<li>Akka背后哲学思想</li>
<li>Actor并发、STM、代理以及数据流</li>
<li>构建一个大型的可扩展应用：Akkaoogle</li>
</ol>
<p>本章介绍一个已有的Scala工具包：Akka，让你为JVM平台构建新一代的、事件驱动的、容错的、可伸缩的分布式应用。Akka提供了多并发的抽象，本章着重探索其内容。前面内容，仅介绍了Actor面向消息的(message-oriented)并发使用。这里将继续探索诸如 STM、Agent和Dataflow的并发抽象内容。</p>
<span id="more"></span>
<p>为了理解Akka各部分是如何整合在一起的，我们将使用Akka来构建一个真实的搜索应用：Akkaoogle。该应用类似于<a target="_blank" rel="noopener" href="http://www.google.com/products">Froogle</a>，它是google的一个服务，用于搜索产品的最低价格。你将马上构建这个产品，这样你就可以看到应该在什么场合，使用怎样的Akka特性。</p>
<p><strong>注意</strong> 本章所有覆盖的Akka特性，同时都有相应的Java API。但不在本章阐述Java方面的内容，你可以查阅[文档](<a target="_blank" rel="noopener" href="http://akka.io/docs/">http://akka.io/docs/</a> for details)了解该方面的内容。</p>
<p>Akka由Scala编写，却在Java和Scala APIs上开发了所有的特性。因为这里只介绍Scala方面的内容，也主要讨论Scala的API，当然也包含有Java的例子。你可以仿照Akkaoogle在Scala上的例子，构建一个Java的Akkaoogle版本，因为两者的API是相同的。最开始会先介绍Akka背后的哲学思想，理解之后将进入到Akka项目中，并尝试解决实际问题。</p>
<h3 id="12-1〖The-philosophy-behind-Akka〗P345"><a class="header-anchor" href="#12-1〖The-philosophy-behind-Akka〗P345">¶</a>12~1〖The philosophy behind Akka〗P345</h3>
<p>Akka背后的哲学思想是简单的：使开发者更容易构建正确的、并发的、可伸缩的和容错的应用。为此，Akka提供了一个高层抽象，用于处理并发性、可伸缩性和错误问题。图12.1展示了3个核心模块concurrency、scalability和fault tolerance。</p>
<p><img src="/img/scala-in-action/chapter12/Figure_12_01.png" alt="Figure 12.1"></p>
<p>这些并发模块提供了处理并发性相关问题的选项。到目前为止，我确信你只会Actor(面向消息的并发性)。但Actor不是个从一而终的并发解决方案。你需要理解Akka模块的其它替代方案。在下面的小节将探索所有该内容。在内核，Akka是一个基于事件的(event-based)平台，依赖于Actor的消息传递和伸缩性。Akka任由你使用本地和远程的Actor。通过路由(routing)使用本地Actor，你可以向上扩展；使用远程Actor则帮助你水平扩展。在本章最后，将看到有关于此的更多详细内容。</p>
<h3 id="12-2〖Simple-concurrency-with-Akka〗P346"><a class="header-anchor" href="#12-2〖Simple-concurrency-with-Akka〗P346">¶</a>12~2〖Simple concurrency with Akka〗P346</h3>
<p>为了拓展你的应用，使用并发。在第9章学习到，线程是实现并发的一个困难的、易出错的方式，它应该作为你的最后的一个选择方案。问题是最优的方案是什么，第二、第三方案呢？本小节将介绍如何选择合适的方案。表 12.1 描述了Akka中的所有可用并发技术。好消息是，你可以组合所有这些并发技术，它是大多数Akka开发者最终的做法。</p>
<table>
<thead>
<tr>
<th style="text-align:left">name</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>Actors</code></td>
<td style="text-align:left">一个Actor是一个异步处理消息并封装状态的一个对象。Actor实现了消息传递的并发性。</td>
</tr>
<tr>
<td style="text-align:left"><code>STM(Software transactional memory)</code></td>
<td style="text-align:left">软件事务内存，模拟数据库事务的机制，控制在并行计算时对共享内存的访问控制。它是锁的一种替代机制，以及提供了可组合性。</td>
</tr>
<tr>
<td style="text-align:left"><code>Agents</code></td>
<td style="text-align:left">Agents提供了在可变数据(mutable data)上的抽象。它仅允许你通过一个异步的写(write)动作来改变数据。</td>
</tr>
<tr>
<td style="text-align:left"><code>Dataflow</code></td>
<td style="text-align:left">Dataflow并发性是确定的。这意味着每次执行都表现出相同的行为。因此你的应用最先是死锁的，它会始终是死锁，这有帮助你debug问题。Akka使用<code>Future</code>来实现 Oz-style 的dataflow</td>
</tr>
</tbody>
</table>
<p>这些选项提供了设计正确并发应用的灵活性。例如你可以使用Actor来建模一个应用，用STM或Agents来处理可变状态，以及使用Dataflow并发来组合多并发进程。这都有无尽的可能性。</p>
<p><strong>注意</strong> Akka不再包含STM模块，取而代之的是支持Scala STM。</p>
<p>下面开始Akka并发世界之旅————这会是一个有趣的旅程。</p>
<h3 id="1221〖Remote-actors〗P347"><a class="header-anchor" href="#1221〖Remote-actors〗P347">¶</a>12<sub>2</sub>1〖Remote actors〗P347</h3>
<p>在第9章我们详细探索了Actor内容。Actor编程不仅仅局限于单个JVM，因此每个Actor可以跨多个JVM进行交流。Akka的远程Actor允许你在远程设备上部署Actor，透明地来回发送消息。远程Actor是实现扩展的、分布式应用的一个很好的方式。这些消息，使用<a target="_blank" rel="noopener" href="http://code.google.com/p/protobuf/">Google protocol buffer</a> 进行自动序列化，两个节点间的交流，通过使用<a target="_blank" rel="noopener" href="http://www.jboss.org/netty">JBoss Netty</a> 处理。可以把Google protocl buffer 认为是小巧而又快速的XML，Netty认为是一个非IO阻塞(non-blocking I/O)的实现，它们让Akka高效地使用线程为I/O操作。</p>
<p><img src="/img/scala-in-action/chapter12/Figure_12_02.png" alt="Figure 12.2"></p>
<p>Akka实现了透明的远程调用，即在部署时Actor的运程(remoteness)被完全配置。你可以在构建方案时使用本地Actor，在部署期间为每个独立的Actor配置运程详情。</p>
<p><strong>注意</strong> 在将来的Akka版本，Netty将由一个基于Actor的I/O库 Actor I/O所代替。</p>
<p>在此之前，先让我们为远程Actor添加依赖项。Akka是模块化的，如其添加整个akka库，你仅需要添加Actor依赖库即可。下面是其远程依赖的<code>build.sbt</code>文件配置。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resolvers ++= <span class="type">Seq</span>(</span><br><span class="line">  <span class="string">&quot;Akka Repo&quot;</span> at <span class="string">&quot;http://akka.io/repository&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Typesafe Repo&quot;</span> at <span class="string">&quot;http://repo.typesafe.com/typesafe/repo&quot;</span></span><br><span class="line">)</span><br><span class="line">libraryDependencies ++= <span class="type">Seq</span>(</span><br><span class="line">  <span class="string">&quot;com.typesafe.akka&quot;</span> %% <span class="string">&quot;akka-actor&quot;</span> % <span class="string">&quot;2.3.6&quot;</span>,</span><br><span class="line">  <span class="string">&quot;com.typesafe.akka&quot;</span> %% <span class="string">&quot;akka-remote % &quot;</span><span class="number">2.3</span><span class="number">.6</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure>
<p><code>resolvers</code>定义了依赖的地址，<code>libraryDependencies</code>则添加远程Actor。</p>
<p>我们将使用第9章的word count例子，更改原来读取文本文件的方式，改为读取URL的内容。目的是链接到URL，并计算页面的单词数。在Java中要创建一个Akka Actor，你需要继承<code>akka.actor.UntypedActor</code>类，并重写<code>onReceive</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.UntypedActor;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCountWorker</span> <span class="keyword">extends</span> <span class="title class_">UntypedActor</span> &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Object message)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该类被称为<code>UntypedActor</code>因为Akka包括有一个<code>TypedActor</code>概念。这个类型Actor实现了主动对象(active object)模式，即将任意的POJO接口，转变为一个异步的API。</p>
<p><strong>注意</strong> Akka的类型化Actor(typed actor)是主动对象模式(active object pattern)的一个实现。它将同步方法调用变为异步派遣。使用类型化Actor的一个优势在于，你可以有一个静态的编译的类型约定，这样你不需要定义消息。在Akka文档中读取更多有关内容。</p>
<p>因为你的<code>wordCountWorker</code>需要处理<code>FileToCount</code>消息，你需要将接收的参数消息转换类型为<code>FileToCount</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (message <span class="keyword">instanceof</span> FileToCount) &#123;</span><br><span class="line">	<span class="type">FileToCount</span> <span class="variable">c</span> <span class="operator">=</span> (FileToCount)message;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown message: &quot;</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用了<code>instanceof</code>来检验接收消息的类型，如果消息不是<code>FileToCount</code>类型，将抛出一个异常。在Scala代码，需要添加<code>countWords</code>方法到<code>FileToCount</code> case 类，以计算所有单词：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">FileToCount</span>(<span class="params">url: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">countWords</span> </span>= &#123;</span><br><span class="line">    <span class="type">Source</span>.fromURL(<span class="keyword">new</span> <span class="type">URL</span>(url)).getLines.foldRight(<span class="number">0</span>)(_.split(<span class="string">&quot; &quot;</span>).size + _)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>WordCountWorker</code> Actor，你可以调用 <code>countWords</code> 方法来统计单词数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileToCount</span> c = (<span class="type">FileToCount</span>)message;</span><br><span class="line"><span class="type">Integer</span> count = c.countWords();</span><br></pre></td></tr></table></figure>
<p>要给发送者回复一个响应，使用 <code>getSender().tell(...)</code> 方法。方法 <code>tell</code> 允许Actor向发送者回复。要向主干回复，子Actor需要构造<code>WordCount</code> 消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileToCount</span> <span class="variable">c</span> <span class="operator">=</span> (FileToCount)message;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> c.countWords();</span><br><span class="line">getSender().tell(<span class="keyword">new</span> <span class="title class_">WordCount</span>(c.url(), count));</span><br></pre></td></tr></table></figure>
<p><code>getSelf</code> 方法返回当前Actor的引用。下面代码清单为完整的<code>WordCountWorker</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> countwords;</span><br><span class="line"><span class="keyword">import</span> akka.actor.UntypedActor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCountWorker</span> <span class="keyword">extends</span> <span class="title class_">UntypedActor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Object message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> FileToCount) &#123;</span><br><span class="line">            <span class="type">FileToCount</span> <span class="variable">c</span> <span class="operator">=</span> (FileToCount)message;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> c.countWords();</span><br><span class="line">            getSender().tell(<span class="keyword">new</span> <span class="title class_">WordCount</span>(c.url(), count), getSelf());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown message: &quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了利用好远程Actor，我们在一个JVM中，将所有worker actor从master actor分离。为此，需要创建两个Actor系统。配置Akka Actor最简单的方式是在classpath中提供一个配置文件。你可以在akka文档中找到所有配置属性的更多内容。下面例子定义两个Actor系统：主Actor系统和工作Actor系统。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">workersystem &#123;</span><br><span class="line">  akka &#123;</span><br><span class="line">    actor&#123;provider = &quot;akka.remote.RemoteActorRefProvider&quot;&#125;</span><br><span class="line">    remote &#123;</span><br><span class="line">      enabled-transports = [&quot;akka.remote.netty.tcp&quot;]</span><br><span class="line">      // transports = &quot;akka.remote.netty.NettyRemoteTransport&quot;</span><br><span class="line">      //log-sent-messages = on</span><br><span class="line">      //log-received-messages = on</span><br><span class="line">      netty.tcp &#123;</span><br><span class="line">        hostname = &quot;127.0.0.1&quot;</span><br><span class="line">        port = 2560</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mainsystem &#123;</span><br><span class="line">  akka &#123;</span><br><span class="line">    actor.provider = &quot;akka.remote.RemoteActorRefProvider&quot;</span><br><span class="line">    remote.netty.tcp.hostname = &quot;127.0.0.1&quot;</span><br><span class="line">    actor &#123;</span><br><span class="line">      deployment &#123;</span><br><span class="line">        /wordCountMaster &#123;</span><br><span class="line">          remote = &quot;akka.tcp://workersystem@127.0.0.1:2560&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Actor系统提供的灵活性定义配置，将每个Actor系统进行分离。下面元素添加运程(remoteness)到Actor系统：</p>
<ul>
<li>Actor provider 改为 <code>akka.remote.RemoteActorRefProvider</code>。</li>
<li>添加主机名。并确保IP地址可访问。</li>
<li>添加远程Actor系统监听的端口号。</li>
<li>映射将被部署的Actor系统的名称。</li>
</ul>
<p>现在将上述配置保存到src/main/resources文件夹下的application.conf文件中。要是<code>workersystem</code>能够在一个不同的JVM上运行，在该终端执行下面代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package countwords</span><br><span class="line">import akka.actor._</span><br><span class="line">import com.typesafe.config.ConfigFactory</span><br><span class="line">object WorkerSystem extends App &#123;</span><br><span class="line">	val workerSystem = ActorSystem(&quot;workersystem&quot;,</span><br><span class="line">		ConfigFactory.load.getConfig(&quot;workersystem&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它将开启&quot;workersystem&quot;，并监听来自端口号为2560的消息。现在创建一个新的Actor。它用于运行主Actor系统：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">FileToCount</span>(<span class="params">url: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">countWords</span> </span>= &#123;</span><br><span class="line">    <span class="type">Source</span>.fromURL(<span class="keyword">new</span> <span class="type">URL</span>(url)).getLines.foldRight(<span class="number">0</span>)(_.split(<span class="string">&quot; &quot;</span>).size + _)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span>(<span class="params">url: <span class="type">String</span>, count: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">StartCounting</span>(<span class="params">urls: <span class="type">Seq</span>[<span class="type">String</span>], numActors: <span class="type">Int</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MainSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MainActor</span>(<span class="params">accumulator: <span class="type">ActorRef</span></span>) <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;start&quot;</span> =&gt;</span><br><span class="line">        <span class="keyword">val</span> urls = <span class="type">List</span>(<span class="string">&quot;http://www.infoq.com/&quot;</span>,</span><br><span class="line">          <span class="string">&quot;http://www.dzone.com/links/index.html&quot;</span>,</span><br><span class="line">          <span class="string">&quot;http://www.manning.com/&quot;</span>,</span><br><span class="line">          <span class="string">&quot;http://www.reddit.com/&quot;</span>)</span><br><span class="line">        accumulator ! <span class="type">StartCounting</span>(urls, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) = run</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">val</span> mainSystem = <span class="type">ActorSystem</span>(<span class="string">&quot;main&quot;</span>, <span class="type">ConfigFactory</span>.load.getConfig(<span class="string">&quot;mainsystem&quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> accumulator = mainSystem.actorOf(<span class="type">Props</span>[<span class="type">WordCountMaster</span>], name = <span class="string">&quot;wordCountMaster&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> m = mainSystem.actorOf(<span class="type">Props</span>(<span class="keyword">new</span> <span class="type">MainActor</span>(accumulator)))</span><br><span class="line">    m ! <span class="string">&quot;start&quot;</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你在两个不同的JVM实例上开启<code>WorkerSystem</code>和<code>MainSystem</code>，将实现了workers Actor运行在一个JVM，而主Actor运行在另一个JVM上。现在你实现了Akka的分布式部署方案。</p>
<p><img src="/img/scala-in-action/chapter12/Figure_12_remote.png" alt="Figure 12.remote"></p>
<h3 id="1222〖Making-mutable-data-safe-with-STM〗P351"><a class="header-anchor" href="#1222〖Making-mutable-data-safe-with-STM〗P351">¶</a>12<sub>2</sub>2〖Making mutable data safe with STM〗P351</h3>
<p>软件事务内存(STM, Software transactional memory)将一个Java堆栈变为一个事务数据集。STM类似于数据库事务，但是使用内存代替。因为STM不能在内存中实现持久化，你仅能获得事务ACID的前三个属性(atomicity,consistency,isolation,durability)：</p>
<ul>
<li>原子性——所偶修改应该遵循“all or nothing” 规则。在STM，所有修改由一个不可分割的事务处理，一项修改失败将导致所有的改动回滚。</li>
<li>一致性——表明一个STM事务将系统从一个一致状态到另一个一致性状态。如果你想要删除一个Map中的一个元素，再插入到另外一个Map，那么STM事务最终，两个Map都被适当地修改。</li>
<li>隔离性——STM的事务间相互不可见，彼此孤立，不互相干预。</li>
</ul>
<p>STM最好的部分是锁自由。它从异常中回滚，并且是可组合的。你可以将两个小的STM操作组合成为一个大的STM操作。在展示STM例子之前，先让我们理解一下STM的状态是什么，以及它是如何表示的。</p>
<p><strong>HOW STATE IS DEFINED IN STM</strong></p>
<p>让我们看看在命令式编程中状态是如何处理的。图12.3展示了状态是如何处理的。你直接访问内存中的数据，并改变这个数据。在图中，一个对象A，直接被B和C访问数据。问题是在并发世界这种方式无效。当一些其它驻留在B或C的线程或进程尝试访问数据，而A正尝试修改数据时，会怎样？结果显然不是我们所期望的。</p>
<p><img src="/img/scala-in-action/chapter12/Figure_12_03.png" alt="Figure 12.3"></p>
<p>要解决这种方式上的问题，STM定义了不同的可变状态。在STM中，<code>state</code>被定义为值，它是一个在特殊点上具体标识的实体。一个值<code>value</code>是指不会变化的(不可变的)。标识<code>identity</code>是指在一个给定的点上对一个值的引用。图12.4展示了STM的这种结构。可变部分是唯一标识的，它可一系列值相关联。STM使得从一个值到另一个值的可变引用具有原子性。当驻留在B和C的其它进程或线程，访问正在修改的A时，会发生什么？你会看到与B或C关联的值，因为STM事务被隔离的，事务的部分改变在外部不可见。</p>
<p>这种根据标识和值来定义状态的思想，来源于编程语言<a target="_blank" rel="noopener" href="http://clojure.org">Clojure</a> 。现在看看在Akka中，STM是如何工作的。</p>
<p><strong>HANDLING MUTABLE DATA IN AKKA USING STM</strong></p>
<p>Akka使用Scala的STM库作为它的STM。在SBT项目中添加该库：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolvers += (<span class="string">&quot;Typesafe Repository&quot;</span> at <span class="string">&quot;http://repo.typesafe.com/typesafe/</span></span><br><span class="line"><span class="string">	releases/&quot;</span>)</span><br><span class="line">libraryDependencies ++= <span class="type">Seq</span>(</span><br><span class="line">  <span class="string">&quot;org.scala-stm&quot;</span> %% <span class="string">&quot;scala-stm&quot;</span> % <span class="string">&quot;0.7&quot;</span>,</span><br><span class="line">  <span class="string">&quot;org.specs2&quot;</span> %% <span class="string">&quot;specs2&quot;</span> % <span class="string">&quot;1.13&quot;</span> % <span class="string">&quot;test&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>为演示STM如何工作，我们以一个小实例着手，你创建一个为可变Map删除和增加元素的原子操作。为了管理可变性，用<code>scala.concurrent.stm.Ref</code>来封装这个可变的值：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ref1 = <span class="type">Ref</span>(<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">Any</span>](</span><br><span class="line"><span class="string">&quot;service1&quot;</span> -&gt; <span class="string">&quot;10&quot;</span>,</span><br><span class="line"><span class="string">&quot;service2&quot;</span> -&gt; <span class="string">&quot;20&quot;</span>,</span><br><span class="line"><span class="string">&quot;service3&quot;</span> -&gt; <span class="literal">null</span>))</span><br><span class="line"><span class="keyword">val</span> ref2 = <span class="type">Ref</span>(<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">Int</span>]())</span><br></pre></td></tr></table></figure>
<p>这两个值不是别的，就是多并发参与者中的值的可变引用。上述代码片段创建了两个值，指向可变的HashMap。要在Ref上处理操作，你需要使用定义在STM包中的<code>atomic</code>方法。Scala的STM库创建事务对象，并授权调用者处理事务性的读和写操作。闭包内的任何<code>refs</code>的改变都在一个STM事务中完成。例如，下面代码中，由ref2向Map添加一个新的元素：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">atomicInsert</span></span>(key: <span class="type">String</span>, value: <span class="type">Int</span>) = atomic &#123; <span class="keyword">implicit</span> txn =&gt;</span><br><span class="line">  <span class="keyword">val</span> oldMap = ref2.get</span><br><span class="line">  <span class="keyword">val</span> newMap = oldMap + ( key -&gt; value)</span><br><span class="line">  ref2.swap(newMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调用<code>ref2.get</code>得到当前由<code>Ref</code>关联的，使用<code>swap</code>替代的一个新值。如果操作失败，该操作将会回滚。事务参数被隐式标志，因此你不需要直接传递。</p>
<p>要从<code>ref1</code>中实现<code>key</code>的<code>atomic</code>删除，你需要使用定义在<code>Ref</code>的<code>transform</code>方法。方法<code>transform</code>允许你转换<code>Ref</code>引用的值：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">atomicDelete</span></span>(key: <span class="type">String</span>): <span class="type">Option</span>[<span class="type">Any</span>] = atomic &#123;</span><br><span class="line">  <span class="keyword">val</span> oldMap = ref1.get</span><br><span class="line">  <span class="keyword">val</span> value = oldMap.get(key)</span><br><span class="line">  ref1.transform(_ - key)</span><br><span class="line">  value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>atomicDelete</code>返回删除了的 value。为什么返回 old value？因为之后会用到。</p>
<p>接着讨论关于STM的组合性。假设你构建了一个<code>atomicSwap</code>函数，用于将一个Map的一个元素，移动到另一个Map中。使用STM，这变的容易：你需要做的是封装<code>atomicDelete</code>和<code>atomicInsert</code>这两个函数，如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">atomicSwap</span></span>(key: <span class="type">String</span>) = atomic &#123; <span class="keyword">implicit</span> txn =&gt;</span><br><span class="line">  <span class="keyword">val</span> value: <span class="type">Option</span>[<span class="type">Any</span>] = atomicDelete(key)</span><br><span class="line">  atomicInsert(key, <span class="type">Integer</span>.parseInt(value.get.toString))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>ref2</code>仅接收一个<code>Int</code>类型值，在插入之前先要解析为<code>Int</code>。为了完全理解<code>swap</code>的优雅所在，看下面规范：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Atomic operations in composition&quot;</span> should &#123;</span><br><span class="line">  <span class="string">&quot;rollback on exception&quot;</span> in &#123;</span><br><span class="line">	swap(<span class="string">&quot;service3&quot;</span>)</span><br><span class="line">	ref1.single().contains(<span class="string">&quot;service3&quot;</span>) must beEqualTo(<span class="literal">true</span>)</span><br><span class="line">	ref2.single().contains(<span class="string">&quot;service3&quot;</span>) must beEqualTo(<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>STM的方法<code>single</code>可以不要求事务，访问<code>Ref</code>的上下文。当尝试转换&quot;service3&quot;时，<code>Integer.parseInt</code>会抛出一个异常。这时删除动作已经成功了，但多亏了STM，整个事务将回滚。锁(lock)可以做到这点吗？不能。</p>
<p>STM很好地构建了小型的一致性操作，以及能够组合这些操作。要学习有关STM的更多内容，查阅Scala STM文档。</p>
<h3 id="1223〖Agents〗P354"><a class="header-anchor" href="#1223〖Agents〗P354">¶</a>12<sub>2</sub>3〖Agents〗P354</h3>
<p>Agent提供了对任何独立存储位置异步修改的绑定。一个Agent仅允许提供的一个动作改变这个位置内容。这个动作指的是函数，该函数被异步地应用于Agent的状态，其返回值成为Agent的新状态。 然而，从Agent读取一个值是瞬时的和同步的。因而<code>Ref</code>和<code>Agent</code>的不同在于，<code>Ref</code>是一个同步读和写；<code>Agent</code>是响应式的(reactive)。要任意异步地提供动作，Akka提供了两个方法：<code>send</code>和<code>sendOff</code>。<code>send</code>方法使用响应式的线程池分配给agent，而<code>sendOff</code>使用一个专有的线程，适用于一个长时间运行的操作。下面是一个Agent相关例子，通过<code>send</code>动作，向一个文件写日志信息：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">ActorSystem</span></span><br><span class="line"><span class="keyword">import</span> akka.agent.<span class="type">Agent</span></span><br><span class="line"><span class="keyword">import</span> org.specs2.mutable.<span class="type">Specification</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">Await</span></span><br><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">ExecutionContext</span>.<span class="type">Implicits</span>.global</span><br><span class="line"><span class="keyword">import</span> scala.concurrent.duration._</span><br><span class="line"></span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">&quot;agentExample&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> writer = <span class="keyword">new</span> <span class="type">FileWriter</span>(<span class="string">&quot;src/test/resources/log.txt&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> a = <span class="type">Agent</span>(writer)</span><br><span class="line">a.send &#123; w =&gt; w.write(<span class="string">&quot;This is a log message&quot;</span>); w&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait for reply</span></span><br><span class="line"><span class="keyword">val</span> future = a.future</span><br><span class="line"><span class="type">Await</span>.result(future, <span class="number">100</span> seconds) should be(writer)</span><br><span class="line"></span><br><span class="line">writer.close</span><br></pre></td></tr></table></figure>
<p>Agent将运行，直到调用<code>close</code>方法。因为在其背后，agent由Actor被实现，你需要为agent创建一个Actor系统。如果你想要做更多的花费时间的事情，你需要使用<code>sendoff</code>方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.sendOff &#123; someLongRunningProcess &#125;</span><br></pre></td></tr></table></figure>
<p>注意在任何时间，仅有一个<code>send</code>动作被调用。即使是多并发处理发送的操作，这些动作将按照顺序执行。注意这些动作可能在多线程间交错。</p>
<p>为了在你的项目中使用Agents，需要添加下列依赖项到SBT配置文件中：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">libraryDependencies ++= <span class="type">Seq</span>(</span><br><span class="line"><span class="string">&quot;com.typesafe.akka&quot;</span> %% <span class="string">&quot;akka-actor&quot;</span> % <span class="string">&quot;2.6.3&quot;</span>,</span><br><span class="line"><span class="string">&quot;com.typesafe.akka&quot;</span> %% <span class="string">&quot;akka-agent&quot;</span> % <span class="string">&quot;2.6.3&quot;</span>,</span><br><span class="line"><span class="string">&quot;org.specs2&quot;</span> %% <span class="string">&quot;specs2&quot;</span> % <span class="string">&quot;3.8.5&quot;</span> % <span class="string">&quot;test&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>当使用<code>atomic</code>块，以及消息被挂起直到事务完成，Agent也参与到STM事务。这对于有side-effect的动作很有帮助，如记录日志文件，你不想以STM实现。为什么？因为STM事务如果失败，它们自动重试，意味着你的副作用操作被执行了多次。这可能不是你想要的，因此组合agent和STM，会是在STM事务间，执行副作用动作的一个很好的模式。有时候，Agent的异步性质，人们会迷惑因为agent和Actor类似，但是它们完完全全在设计方式上不同。Agent与数据相关联，你从外部，以一个函数的形式，向Agent发起行为。而Actor的行为定义在内部，数据则以消息的形式发送。</p>
<p>你将在使用Akkaoogle日志事务时再一次看到agent，但现在让我们继续我们下一个并发模型：dataflow。Dataflow是一个很好的从一个程序封装并发的实现方式。它可以顺序读取。</p>
<h3 id="1224〖Dataflow〗P355"><a class="header-anchor" href="#1224〖Dataflow〗P355">¶</a>12<sub>2</sub>4〖Dataflow〗P355</h3>
<p>数据流并发是一个确定性的并发模型。运行并工作时，它会一直处于工作中而不会有死锁。又或者，如果一开始是死锁，它会总是处于死锁中。这点在并发应用中是一个有力的保障，你可以更容易理解这些代码。数据流并发允许你编写顺序的代码，以并行处理这些操作。限制是你的代码应该是完全无副作用的。因为这些代码被用于处理有副作用操作时，你不能获得确定性的行为。</p>
<p>Dataflow在Akka中使用了Scala的分离延续(delimited continuations)编译器插件实现。要在SBT项目中使用该插件，在配置中添加下列内容：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scalacOptions += <span class="string">&quot;-P:continuations:enable&quot;</span></span><br><span class="line"></span><br><span class="line">libraryDependencies += <span class="string">&quot;com.typesafe.akka&quot;</span> % <span class="string">&quot;akka-dataflow_2.10&quot;</span> % <span class="string">&quot;2.3.6&quot;</span></span><br><span class="line"></span><br><span class="line">autoCompilerPlugins := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">libraryDependencies &lt;+= </span><br><span class="line">	scalaVersion &#123; v =&gt; compilerPlugin(<span class="string">&quot;org.scala-lang.plugins&quot;</span> % <span class="string">&quot;continuations&quot;</span> % v) &#125;</span><br></pre></td></tr></table></figure>
<p>要用到数据流并发，必须用到数据流变量。一个数据流变量像一个单赋值(single-assignment)变量。一旦被绑定，不会再改变，以及之后任何新值的绑定将被忽略。下列例子定义了一个数据流变量：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> messageFromFuture = <span class="type">Promise</span>[<span class="type">String</span>]()</span><br></pre></td></tr></table></figure>
<p>这里的Akka <code>Promise</code>被用作创建一个数据流变量。一个<code>Promise</code>为一个值的读处理，该值会在将来的某个时候被用到。任何数据流操作，会在<code>Future.flow</code>块中被处理：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Future</span>.flow &#123;</span><br><span class="line">	messageFromFuture()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述调用会处于一个线程等待中，直到有一个值被绑定到<code>messageFromFuture</code>。<code>Future.flow</code>返回一个<code>Future</code>，这样你可以处理其它操作，而不用阻塞主线程的执行。你可以把<code>Future</code>认为是用于接收某些并发操作结果的数据结构。要为数据流变量指派一个值，使用<code>&lt;&lt;</code>方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Future</span>.flow &#123;</span><br><span class="line">	messsageFromFuture &lt;&lt; <span class="string">&quot;Future looks very cool&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦一个值被绑定到一个数据流变量，所有<code>Future</code>将等待，该值将被非阻塞，以能继续执行。下面列出使用dataflow变量的一个完整例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">ActorSystem</span></span><br><span class="line"><span class="keyword">import</span> akka.dataflow._</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">ExecutionContext</span>.<span class="type">Implicits</span>.global</span><br><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">Promise</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @author barudisshu</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DataflowExample</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">&quot;dataflow&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> messageFromFuture, rawMessage, parsedMessage = <span class="type">Promise</span>[<span class="type">String</span>]()</span><br><span class="line">  flow &#123;</span><br><span class="line">    messageFromFuture &lt;&lt; parsedMessage()</span><br><span class="line">    println(<span class="string">&quot;z = &quot;</span> + messageFromFuture())</span><br><span class="line">  &#125;</span><br><span class="line">  flow &#123;</span><br><span class="line">    rawMessage &lt;&lt; <span class="string">&quot;dlrow olleh&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  flow &#123;</span><br><span class="line">    parsedMessage &lt;&lt; toAscii(rawMessage())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">toAscii</span></span>(s: <span class="type">String</span>) = s.reverse</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下个小节将使用Akka的概念，构建一个应用，实践Akka并发。</p>
<h3 id="12-3〖Building-a-real-time-pricing-system-Akkaoogle〗P357"><a class="header-anchor" href="#12-3〖Building-a-real-time-pricing-system-Akkaoogle〗P357">¶</a>12~3〖Building a real-time pricing system: Akkaoogle〗P357</h3>
<p>略，请参考本书源码。</p>
<h3 id="12-4〖Adding-asynchronous-HTTP-support-with-Play2-mini〗P375"><a class="header-anchor" href="#12-4〖Adding-asynchronous-HTTP-support-with-Play2-mini〗P375">¶</a>12~4〖Adding asynchronous HTTP support with Play2-mini〗P375</h3>
<p>略，像Play2、Lift、Spray这些REST框架，基本上都封装了并发接口。Play2框架使用的是Netty作为NIO，包含大量易上手的工具和模版。请参考官网用户指导手册了解详情。</p>
<h3 id="12-5-〖Summary〗P379"><a class="header-anchor" href="#12-5-〖Summary〗P379">¶</a>12~5 〖Summary〗P379</h3>
<p>在构建框架和应用中，Akka是一个强大的工具。Akka使得并发对编程者来说更容易，它提升了一个抽象层次。Akka并发框架构建在Actor之上，但也提供了所有流行的并发抽象技术。使得你可以在构建下一代应用中有更多的选择。Akka的STM支持可变数据结构的操作，最重要的是，你可以通过组合小部分原子性操作来解决问题。另外我们还探索了另外一个并发模式Agent，它让你从外部发送行为，修改安全管理器内的数据。额外地，还学习了Dataflow并发，通过数据流，能够让我们编写流式的程序，而不用担心它们之间的并发问题，Dataflow并发代码也很好理解和掌握，但要注意dataflow不适用于处理带有副作用的操作。</p>
<p>Akkaoogle是一个典型的并发应用，通过构建该应用，探索了如何思考并发问题，如何约束，设计以及抉择方案。Akka提供丰富的选项、灵活的配置，你应该从Akka上，拾取一些更好的特性和选项，以更好地适应你的应用项目。Akka早已经实践在各种真实应用中，我们应该炙手可热尝试一番。</p>
</div></article><nav class="article-nav"><div class="article-nav-prev"><a href="/2017/04/28/docker/docker-learning/">docker学习记录</a></div><div class="article-nav-next"><a href="/2016/10/27/scala/11-jvm-integrate/">第十一章：Scala和Java相互集成</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2016/10/27/scala/12-akka-app/';
var disqus_title = '第十二章：Akka构建扩展、分布式应用';
var disqus_url = 'https://galudisu.info/2016/10/27/scala/12-akka-app/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>