<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>第二章：开始学习Scala</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">第二章：开始学习Scala</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2016-10-27</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/scala/">scala</a></p><p class="meta-item meta-category"><span class="meta-item-title"></span><i class="icon-bookmark"> </i><a class="category-link" href="/categories/learning/">learning</a></p></div><div class="article-content"><p>本章内容将学习Scala的类型，函数，for-comprehensions，模式匹配，以及其它方面内容。</p>
<p>注意模式匹配和for-comprehensions，是函数式编程概念。本章主要目的是先熟悉Scala语言的环境和一些基本的语法。一开始，会先从REPL简单环境入手。</p>
<p>在作进一步学习之前，先确保已经安装好Scala。现在，让我们先了了解Scala的解析器REPL。</p>
<span id="more"></span>
<h2 id="Scala解析器REPL"><a class="header-anchor" href="#Scala解析器REPL">¶</a>Scala解析器REPL</h2>
<p>Scala 解析器，指的是一个可以编写Scala表达式和程序的交互shell。要进入到Scala的交互模式，在命令提示符中输入<code>scala</code>即可。你将进入到Scala的命令提示符：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Welcome to Scala version 2.10.0.final (Java ...).</span><br><span class="line">Type in expressions to have them evaluated.</span><br><span class="line">Type :help for more information.</span><br><span class="line"><span class="meta prompt_">scala&gt;</span></span><br></pre></td></tr></table></figure>
<p>这表明Scala安装成功。在Scala提示符输入42，按回车，将看到：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">42</span></span><br><span class="line">res0: Int = 42</span><br></pre></td></tr></table></figure>
<p><code>res0</code>为Scala解析器创建的变量名，持有值42。如果再输入变量名，将再次得到相似的输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">res0</span></span><br><span class="line">res1: Int = 42</span><br></pre></td></tr></table></figure>
<p>带有这些步骤的，称之为 REPL(read-evaluate-print loop)。即你可以在Scala解析器内部重复的循环 读-执行-打印 步骤。现在再看看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">println(<span class="string">&quot;Hello world&quot;</span>)</span></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>
<p>这里调用了<code>println</code>函数，以及传递参数<code>&quot;Hello World&quot;</code>，并输出结果。</p>
<p><code>println</code>是<code>scala.Console</code>中的一个函数，该函数使用<code>System.out.println()</code>将消息输出在控制台上，Scala库中的Predef会将<br>
<code>Console.println</code>映射为<code>println</code>，因此你可以不使用包名调用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala &gt; val myList = new java.util.ArrayList[String]()</span><br><span class="line">myList: java.util.ArrayList[String] = []</span><br></pre></td></tr></table></figure>
<p>在Scala中可以直接调用Java对象和方法。</p>
<p>下面列出REPL的一些比较有用的选项：</p>
<table>
<thead>
<tr>
<th>Command</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>:help</code></td>
<td style="text-align:left">This command prints the help message with all the commands available in the Scala interpreter.</td>
</tr>
<tr>
<td><code>:cp</code></td>
<td style="text-align:left">Use this command to add a JAR file to the classpath for the Scala interpreter. For example, <code>:cp tools/junit.jar</code> will try to find a JUnit JAR file relative to your current location and, if found, it will add the JAR file to your classpath so that you can refer to the classes inside the JAR file.</td>
</tr>
<tr>
<td><code>:load</code> or <code>:l</code></td>
<td style="text-align:left">Allows you to load Scala files into the interpreter. If you want to investigate existing Scala code, you could load the file into the Scala interpreter, and all the definitions will be accessible to you.</td>
</tr>
<tr>
<td><code>:replay</code> or <code>:r</code></td>
<td style="text-align:left">Resets the interpreter and replays all the previous commands.</td>
</tr>
<tr>
<td><code>:quit</code> or <code>:q</code></td>
<td style="text-align:left">Exits the interpreter.</td>
</tr>
<tr>
<td><code>:type</code></td>
<td style="text-align:left">Displays the type of an expression without evaluating it. For example, <code>:type 1 + 2</code> will determine the type of the expression to <code>Int</code> without performing the add operation.</td>
</tr>
</tbody>
</table>
<h2 id="Scala基础"><a class="header-anchor" href="#Scala基础">¶</a>Scala基础</h2>
<p>接下来将介绍Scala的基础类型，包括<code>String</code>和值类型<code>Byte</code>，<code>Short</code>，<code>Int</code>，<code>Long</code>，<code>Float</code>，<code>Double</code>，<code>Boolean</code>以及<code>Char</code>。同时将介绍Scala的两种变量类型<code>var</code>和<code>val</code>。你将学习Scala函数，如何定义，如何调用。</p>
<h3 id="基础类型"><a class="header-anchor" href="#基础类型">¶</a>基础类型</h3>
<p>Scala的所有基础类型都是对象，它们定义在<code>scala</code>包下。</p>
<p>2种变量类型，9种基本数据类型</p>
<table>
<thead>
<tr>
<th>Value type</th>
<th style="text-align:left">Description and range</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Byte</code></td>
<td style="text-align:left">8位二进制，-128~127</td>
</tr>
<tr>
<td><code>Short</code></td>
<td style="text-align:left">16位二进制，-32768~32767</td>
</tr>
<tr>
<td><code>Int</code></td>
<td style="text-align:left">32位二进制，–2,147,483,648~2,147,483,647</td>
</tr>
<tr>
<td><code>Long</code></td>
<td style="text-align:left">64位二进制，-9,223,372,036,854,775,808~,223,372,036,854,775,807</td>
</tr>
<tr>
<td><code>Float</code></td>
<td style="text-align:left">A single-precision 32-bit IEEE 754 floating point.</td>
</tr>
<tr>
<td><code>Double</code></td>
<td style="text-align:left">A double-precision 64-bit IEEE 754 floating point.</td>
</tr>
<tr>
<td><code>Boolean</code></td>
<td style="text-align:left">True False</td>
</tr>
<tr>
<td><code>Char</code></td>
<td style="text-align:left">16位的Unicode字符，‘、u0000’~‘\uffff’</td>
</tr>
</tbody>
</table>
<p>在Scala中，所有的基本数据类型的第一个字母都是大写的。在Scala的早期版本中既可以使用小写也可以使用首字母大写，<br>
但从2.8版本开始，将不再支持小写。</p>
<p><strong>注意</strong> 在Scala中是默认导入了<code>java.lang</code>和<code>Scala.Predef</code>，在.Net环境中对应是system包。对象Predef定义了函数和类型<br>
别名，由于Predef是自动导入的，你可以使用Predef中的所有成员和方法。</p>
<p><strong>说明</strong> 你可以在REPL编译环境中通过命令<code>:import</code>查看所有被自动导入的包。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">:imports</span></span><br><span class="line">1) import java.lang._ (153 types, 158 terms)</span><br><span class="line">2) import scala._ (798 types, 806 terms)</span><br><span class="line">3) import scala.Predef._ (16 types, 167 terms, 96 are implicit)</span><br></pre></td></tr></table></figure>
<h4 id="字面常量"><a class="header-anchor" href="#字面常量">¶</a>字面常量</h4>
<h5 id="整形"><a class="header-anchor" href="#整形">¶</a>整形</h5>
<p>Byte，Short，Int，Long和Char这些基本类型被称为 整形。字面常量可以表示十进制、十六进制和八进制的数，这取决于<br>
这些字面常量的定义方式。如果是0或非零的数字，则它是十进制的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scala &gt; val decimal = 11235</span><br><span class="line">decimal: Int = 11235</span><br></pre></td></tr></table></figure>
<p>和Java一样，如果要声明为Long长整型，只需要在后面加上L或l，如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val decimal = 11235L</span></span><br><span class="line">decimal: Long = 11235</span><br></pre></td></tr></table></figure>
<p>类似地，如果要声明为十六进制和八进制则在数据前面加上前缀0x(十六进制)和0(八进制)：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val hexa = 0x23</span></span><br><span class="line">hexa: Int = 35</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val octa = 023</span></span><br><span class="line">hexa: Int = 19</span><br></pre></td></tr></table></figure>
<p>值得注意的是，不管是十六进制还是八进制，Scala总是返回一个十进制，如果你可以通过类型声明的方式指定，如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val i = 1</span></span><br><span class="line">i: Int = 1</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val i2: Byte = 1</span></span><br><span class="line">i2: Byte = 1</span><br></pre></td></tr></table></figure>
<h5 id="浮点型"><a class="header-anchor" href="#浮点型">¶</a>浮点型</h5>
<p>浮点型字面量一般包含整数部分和小数部分，小数点和小数部分通常是可选的，浮点型(Float)以F或f作后缀标记，否则就是<br>
Double型的，如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val d = 0.0</span></span><br><span class="line">d: Double = 0.0</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val f = 0.0f</span></span><br><span class="line">f: Float = 0.0</span><br></pre></td></tr></table></figure>
<p>Double型可以通过科学记数法表示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt;</span><span class="language-bash">val exponent = 1e30</span></span><br><span class="line">exponent: Double = 1.0E30</span><br></pre></td></tr></table></figure>
<p>特列：由于浮点型数据可以以 <code>1.</code> 表示，在使用<code>toString</code>方法时，需要用空格分开，即<code>1. toString</code>。对于非字母开头的方法<br>
则可以自动识别，如<code>1.+1</code>将返回<code>2.0</code>，这是一种不规范的写法，应该尽量避免使用。</p>
<h5 id="字符字面量"><a class="header-anchor" href="#字符字面量">¶</a>字符字面量</h5>
<p>字符字面量有两种表示形式，一种是使用Unicode编号，一种是直接显示，即：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val capB = <span class="string">&#x27;\102&#x27;</span></span></span><br><span class="line">capB: Char = B</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val capB = <span class="string">&#x27;B&#x27;</span></span></span><br><span class="line">capB: Char = B</span><br></pre></td></tr></table></figure>
<p>因此，一些比较特殊的字符，比如换行和回车也可以表示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val new_line = <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line">new_line: Char = </span><br></pre></td></tr></table></figure>
<h5 id="字符串字面量"><a class="header-anchor" href="#字符串字面量">¶</a>字符串字面量</h5>
<p>字符串字面量表示方式和字符字面量一样，表示形式和Java语言一样，基本类型也是String。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val bookName = <span class="string">&quot;Scala in \&quot;Action\&quot;&quot;</span></span></span><br><span class="line">bookName: java.lang.String = Scala in &quot;Action&quot;</span><br></pre></td></tr></table></figure>
<p>同时也具有如python的换行等特性，如用连续三个引号来表示换行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val multiLine = <span class="string">&quot;&quot;</span><span class="string">&quot;This is a</span></span></span><br><span class="line">| multi line</span><br><span class="line">| string&quot;&quot;&quot;</span><br><span class="line">multiLine: java.lang.String =</span><br><span class="line">This is a</span><br><span class="line">multi line</span><br></pre></td></tr></table></figure>
<blockquote><p><strong>新特性</strong><br>
从Scala 2.10开始支持字符串内插(String interpolation)写法，因此你可以这样写：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val name = <span class="string">&quot;Nilanjan&quot;</span></span></span><br><span class="line">name: String = Nilanjan</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">s<span class="string">&quot;My name <span class="variable">$name</span>&quot;</span></span></span><br><span class="line">res0: String = My name Nilanjan</span><br></pre></td></tr></table></figure>
<p>在Scala内部将调用一个类StringContext来对字符串进行处理，以<code>$</code>或<code>${...}</code>开头的字符token将被替换，头处理f会将匹配的字符进行格式化操作，如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val height = 1.9d</span></span><br><span class="line">height: Double = 1.9</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val name = <span class="string">&quot;James&quot;</span></span></span><br><span class="line">name: String = James</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">println(f<span class="string">&quot;<span class="variable">$name</span>%s is <span class="variable">$height</span>%2.2f meters tall&quot;</span>)</span></span><br><span class="line">James is 1.90 meters tall</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote><p><em><strong>RichString vs. StringLike</strong></em><br>
如果你使用之前的版本，你将使用<code>scala.RichString</code>来为字符串对象提供额外的方法，但从Scala2.8开始被叫做<code>scala.collection.immutable.StringLike</code>，因为字符串是一个字符集合，它将把字符串视作一个不可变的容器(immutable collection)。相对地，Rich的封装基本类还有<code>RichInt</code>，<code>RichBoolean</code>，<code>RichDouble</code>等等。</p>
</blockquote>
<h5 id="XML字面量"><a class="header-anchor" href="#XML字面量">¶</a>XML字面量</h5>
<p>传统地，使用XML意味着需要第三方解析器或者库，但在Scala中属于语言的一部分，Scala支持XML字面量，因此，可以直接输入：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> book = &lt;book&gt;</span><br><span class="line">&lt;title&gt;<span class="type">Scala</span> in <span class="type">Action</span>&lt;/title&gt;</span><br><span class="line">&lt;author&gt;<span class="type">Nilanjan</span> <span class="type">Raychaudhuri</span>&lt;/author&gt;</span><br><span class="line">&lt;/book&gt;</span><br><span class="line">book: scala.xml.<span class="type">Elem</span> =</span><br><span class="line">&lt;book&gt;</span><br><span class="line">&lt;title&gt;<span class="type">Scala</span> in <span class="type">Action</span>&lt;/title&gt;</span><br><span class="line">&lt;author&gt;<span class="type">Nilanjan</span> <span class="type">Raychaudhuri</span>&lt;/author&gt;</span><br><span class="line">&lt;/book&gt;</span><br></pre></td></tr></table></figure>
<p>Scala将XML字面量转换为<code>scala.xml.Elem</code>类型对象，不仅仅如此，你可以使用<code>&#123;&#125;</code>在XML中传递参数和变量。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val message = <span class="string">&quot;I didn&#x27;t know xml could be so much fun&quot;</span></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val code = “1”</span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val alert = &lt;alert&gt;</span></span><br><span class="line">&lt;message priority=&#123;code&#125;&gt;&#123;message&#125;&lt;/message&gt;</span><br><span class="line">&lt;date&gt;&#123;new java.util.Date()&#125;&lt;/date&gt;</span><br><span class="line">&lt;/alert&gt;</span><br><span class="line">alert: scala.xml.Elem =</span><br><span class="line">&lt;alert&gt;</span><br><span class="line">&lt;message priority=”1”&gt;</span><br><span class="line">I didn&#x27;t know xml could be so much fun</span><br><span class="line">&lt;/message&gt;</span><br><span class="line">&lt;date&gt;Fri Feb 19 19:18:08 EST 2010&lt;/date&gt;</span><br><span class="line">&lt;/alert&gt;</span><br></pre></td></tr></table></figure>
<p>像这样代码定义在<code>&#123;&#125;</code>里面的，在Scala中称之为 Scala代码块(Scala code blocks)。顾名思义，我们可以在<code>&#123;&#125;</code>内写入程序代<br>
码。值得注意的是，在<code>&#123;&#125;</code>外不要使用<code>“”</code>双引号，否则将解析成字符串。</p>
<h4 id="变量"><a class="header-anchor" href="#变量">¶</a>变量</h4>
<p>Scala中变量的声明有两种方式：<code>val</code>和<code>var</code>。<br>
<code>val</code> 是一个赋值变量，有时又叫 值(value)，表示一旦初始化就不能被修改和指定到其他值(类似于Java的final)。<br>
<code>var</code> 是可再分配的(reassignable)，你可以在其初始化后任意更改变量的值。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val constant = 87</span></span><br><span class="line">constant: Int = 87</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">constant = 88</span></span><br><span class="line">&lt;console&gt;:5: error: reassignment to val</span><br><span class="line">constant = 88</span><br><span class="line">^</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">var variable = 87</span></span><br><span class="line">variable: Int = 87</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">variable = 88</span></span><br><span class="line">variable: Int = 88</span><br></pre></td></tr></table></figure>
<p>尽管Scala解析器在变量类型上实现和很好的机制，但有时需要对变量声明指定的类型，我们可以通过 变量:【类型】的形式进行指定。当你声明一个变量而又不明确该变量的值时，你可以使用占位符(_)表示默认类型</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">var willKnowLater:String = _</span></span><br><span class="line">willKnowLater: String = null</span><br></pre></td></tr></table></figure>
<p>因为String的默认类型为null，在该例子中willKnowLater的值就是null。特别声明，不管是var还是val都要为其指定值或<code>_</code>占位符(val不能通过占位符<code>_</code>表示值，因为val声明的是一个确切的不能被改变的值，本地方法或语句块内的var变量不能<br>
使用占位符<code>_</code>)，只有变量声明在类内部时才不用指定值。</p>
<h5 id="Lazy-变量"><a class="header-anchor" href="#Lazy-变量">¶</a>Lazy 变量</h5>
<p>由于变量在var或val声明时便被赋值，但你又不想在一些耗时的操作中声明该变量的值，为了改变这种行为，可以使用<code>lazy val</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">lazy val forLater = someTimeConsumingOperation()</span></span><br><span class="line">forLater: Unit = &lt;lazy&gt;</span><br><span class="line"></span><br><span class="line">表示forLater不在绑定变量后立即求值，</span><br><span class="line">而是在someTimeConsumingOperation()被调用时，才进行求值，如</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">var a = 1</span></span><br><span class="line">a: Int = 1</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">lazy val b = a + 1</span></span><br><span class="line">b: Int = &lt;lazy&gt;</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">a = 5</span></span><br><span class="line">a: Int = 5</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">b</span></span><br><span class="line">res1: Int = 6</span><br></pre></td></tr></table></figure>
<p>变量<code>b</code>在最后一步被调用，但是原来的<code>a</code>已经由<code>1</code>变成了<code>5</code>，所有<code>b</code>最后计算的<code>6</code>。</p>
<p><strong>注意</strong> <code>lazy</code>关键字只能跟随<code>val</code>，不能声明<code>lazy var</code>，因为只有<code>val</code>是不可变的，这意味着通过<code>lazy val</code>声明的变量将在第<br>
一次被调用时产生一个确切的不可变的值。</p>
<h5 id="模式匹配"><a class="header-anchor" href="#模式匹配">¶</a>模式匹配</h5>
<p>我们还可以通过模式匹配来进行声明变量，如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val first :: rest = List(1, 2, 3)</span></span><br><span class="line">first: Int = 1</span><br><span class="line">rest: List[Int] = List(2, 3)</span><br></pre></td></tr></table></figure>
<p>List在Scala中是一个队列容器，模式匹配中左边的<code>first</code>将匹配到List中的第一个元素，最后一个rest匹配剩余的元素，符号<code>::</code>是一个定义在List中的方法，模式匹配将在本章着重讨论。</p>
<p>记住，声明变量时习惯上将其用<code>val</code>声明，而在实际需要是再将其更改为<code>var</code>，以避免出错。</p>
<h4 id="函数"><a class="header-anchor" href="#函数">¶</a>函数</h4>
<h5 id="函数结构定义"><a class="header-anchor" href="#函数结构定义">¶</a>函数结构定义</h5>
<p>函数在Scala中以语句块形式表示，在本小节我们将着重探讨。<br>
在Scala中，函数的定义形式为：</p>
<p>def 方法名（方法参数） 可选返回类型 = 方法主体</p>
<p>在函数中，使用<code>:</code>从返回类型中分割参数列表；多个参数使用<code>,</code>隔开；使用<code>=</code>将方法声明部分和方法主体部分隔开。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">def myFirstMethod():String = &#123; <span class="string">&quot;exciting times ahead&quot;</span> &#125;</span></span><br><span class="line">myFirstMethod: ()String</span><br></pre></td></tr></table></figure>
<p>在该部分，方法返回类型是可选的，因此上面也可以这样声明</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">def myFirstMethod() = &#123; <span class="string">&quot;exciting times ahead&quot;</span> &#125;</span></span><br><span class="line">myFirstMethod: ()java.lang.String</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">myFirstMethod()</span></span><br><span class="line">res6: java.lang.String = exciting times ahead</span><br></pre></td></tr></table></figure>
<p>在方法中<code>=</code>的作用不仅仅用于区分方法声明和方法主体，另一个作用是告诉Scala编译器，应该返回什么类型的数据。如果<br>
省略了<code>=</code>号，Scala将不返回任何东西，如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">def <span class="function"><span class="title">myFirstMethod</span></span>()&#123; <span class="string">&quot;exciting times ahead&quot;</span> &#125;</span></span><br><span class="line">myFirstMethod: ()Unit</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">myFirstMethod()</span></span><br></pre></td></tr></table></figure>
<p>以上面为例，在REPL环境中，返回类型不再是<code>java.lang.String</code>，而已<code>Unit</code>。<code>Unit</code>即相当于Java中的void，就是表示一个<br>
方法不返回任何东西。</p>
<p>对于一般比较简单的方法，你可以直接去掉大括号</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">def myFirstMethod() = <span class="string">&quot;exciting times ahead&quot;</span></span></span><br><span class="line">myFirstMethod: ()java.lang.String</span><br></pre></td></tr></table></figure>
<p>像这些不包含复杂结构的，或不进行参数传递的，可以直接省略掉<code>&#123;&#125;</code>大括号。甚至，如果不包含参数，可以直接将小括号去掉<code>()</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">def myFirstMethod = <span class="string">&quot;exciting times ahead&quot;</span></span></span><br><span class="line">myFirstMethod: java.lang.String</span><br></pre></td></tr></table></figure>
<p>输出结果形式更像是一个声明，因此这也意味着你可以用这种<code>def</code>的方法声明形式代替<code>val</code>或<code>var</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">myFirstMethod</span></span><br><span class="line">res17: java.lang.String = exciting times ahead</span><br></pre></td></tr></table></figure>
<p>明显，调用这种形式的方法和调用var和val是一样的。</p>
<h5 id="函数类型"><a class="header-anchor" href="#函数类型">¶</a>函数类型</h5>
<p>回到函数参数，下面提供一个函数<code>max</code>传递了两个参数，并返回一个最大的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">def max(a: Int, b: Int) = <span class="keyword">if</span>(a &gt; b) a <span class="keyword">else</span> b</span></span><br><span class="line">max: (a: Int,b: Int)Int</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">max(5, 4)</span></span><br><span class="line">res8: Int = 5</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">max(5, 7)</span></span><br><span class="line">res9: Int = 7</span><br></pre></td></tr></table></figure>
<p>在Scala中，<code>return</code>是可选的，在函数中你可以不用使用<code>return</code>关键，它将返回的是最后一个表达式的值。在上面的例子中，if<br>
else语句中的表达式部分为<code>a</code>和<code>b</code>，又因为<code>a</code>和<code>b</code>都是最后一个表达式，因此，当if条件为<code>true</code>时返回<code>a</code>，否则返回<code>b</code>。</p>
<p>尽管<code>return</code>是可选的，你也不用在函数定义的时候声明函数的参数类型。Scala是在函数调用时推断出函数的返回类型，而不是在函数声明的时候<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</p>
<blockquote><p><strong>类型推断</strong></p>
<p>如果你有诸如Haskell，OCaml等类型推断编程语言的使用背景，你会对Scala参数定义的方式感到怪异。原因是，Scala不使用Hindley-Milner算法进行类型推断；实际上Scala的类型推断是基于本地声明的信息，也就是本地类类型推断。类型推断超出本书的范围，你可以阅读更多有关于Hindley-Milner类型推断算法的资料以及为什么它是有用的。</p>
</blockquote>
<h5 id="参数化类型-parameterized-type"><a class="header-anchor" href="#参数化类型-parameterized-type">¶</a>参数化类型 (parameterized type)</h5>
<p>有时我们要通过List作为参数传入一个函数中，但是不能确定List参数传入的是Int还是String，面对这种情况，Scala中提供了一个参数化类型，可以使得在函数调用的时候在决定函数参数的类型。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">def toList[A](value:A) = List(value)</span></span><br><span class="line">toList: [A](value: A)List[A]</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">toList(1)</span></span><br><span class="line">res16: List[Int] = List(1)</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">toList(<span class="string">&quot;Scala rocks&quot;</span>)</span></span><br><span class="line">res15: List[java.lang.String] = List(Scala rocks)</span><br></pre></td></tr></table></figure>
<p>在声明函数时，标识未知的参数类型为A。当toList方法被调用时，A将被传入的参数的类型代替，由于List在Scala中也使用了参数化类型，所以将返回实际参数的类型。</p>
<p>注意：如果你是一个Java编程员，你会发现Java的泛型和Scala的参数化类型十分相似。不同的是，Java是使用(<code>&lt;&gt;</code>)而Scala则是使用(<code>[]</code>)。另外稍微不同的是Scala通常是使用A，B，C… Z标识，而Java通常是T，K，V和E。</p>
<h5 id="函数字面量"><a class="header-anchor" href="#函数字面量">¶</a>函数字面量</h5>
<p>在Scala中，你把函数作为参数传递给另一个函数，这种把函数作为参数传递的宽松机制被称为闭包(closure)（函数作参数传递不总是闭包，这会在第四节介绍）。Scala提供了一个简便的机制创建函数，就是你只需要写函数主体，这种形式叫做函数字面量。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val evenNumbers = List(2, 4, 6, 8, 10)</span></span><br><span class="line">evenNumbers: List[Int] = List(2, 4, 6, 8, 10)</span><br></pre></td></tr></table></figure>
<p>我们可以使用List中的foldLeft方法计算list中的和。foldLeft方法传递两个参数，一个初始化值和一个二元运算。二元运算提供了初始化值和list中的所有元素。二元运算将作为一个函数，这个函数包含了两个参数用于自身操作，如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">evenNumbers.foldLeft(0) &#123; (a: Int, b:Int) =&gt; a + b &#125;</span></span><br><span class="line">res19: Int = 30</span><br></pre></td></tr></table></figure>
<p>如上例子，第一个参数为<code>(0)</code>表示初始化值，第二个参数为<code>&#123; (a: Int, b:Int) =&gt; a + b &#125;</code>，它是一个二元运算，在本例中，它也是一个匿名函数，或称为一个没有预定义函数名的函数。由于在Scala中可以使用类型推断，因此下面形式是等价的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">evenNumbers.foldLeft(0) &#123; (a, b) =&gt; a + b &#125;</span></span><br><span class="line">res20: Int = 30</span><br></pre></td></tr></table></figure>
<p>分析：在Scala中，foldLeft方法定义方式为<code>def foldLeft[B](z: B)(f: (B, A) =&gt; B): B</code>，其中<code>[B]</code>为参数化，<code>(z: B)</code>为第一个参数，B是要返回的对象，<code>(f: (B, A) =&gt; B)</code>为第二个参数，它是一个二元运算，他表示将(B,A)得到的结果赋予给B，用数学公式表示就是 y = f(x,y)。在本例中就是b = a + b，实际上就是个累加器。</p>
<p>Scala允许你对匿名函数做更进一步的操作：你可以去掉匿名函数的参数部分，仅仅保留方法主体，这种情况下，匿名函数的参数要用占位符<code>_</code>代替。下划线在Scala中有特殊意义，在本例中下划线就相当于占位符，因此，下面写法也是等价的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">evenNumbers.foldLeft(0) &#123; _ + _ &#125;</span></span><br><span class="line">res21: Int = 30</span><br></pre></td></tr></table></figure>
<p>下划线在Scala中用得比较多，占位符<code>_</code>可以用在任何地方，具体表示什么值取决于所在的上下文，并且是在其被真正调用的时候才决定其值。函数字面量是Scala中的习惯用法，在Scala基础代码和库中会频繁出现。<br>
回到第一章的例子我们就可以明白，占位符代表了exists方法中的参数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val hasUpperCase = name.exists(_.isUpper)</span><br></pre></td></tr></table></figure>
<h4 id="使用Scala闭包和第一类函数"><a class="header-anchor" href="#使用Scala闭包和第一类函数">¶</a>使用Scala闭包和第一类函数</h4>
<p>闭包就是在它被定义的环境中封装起来的方法。例如，闭包会跟踪函数内部指向函数外部的变量的变化。<br>
在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。运行时，一旦外部的 函数被执行，一个闭包就形成了，闭包中包含了内部函数的代码，以及所需外部函数中的变量的引用。其中所引用的变量称作上值(upvalue)。<br>
注意：闭包一词经常和匿名函数混淆。这可能是因为两者经常同时使用，但是它们是不同的概念。<br>
这里要说明，Scala中没有break或continue，也不是保留字。Scala是一门可扩展的语言，因此，你可以扩展来达到break的作用。我们可以通过Scala的异常处理机制来实现break。因为，抛出一个异常会是执行队列停止，使得catch语句块只执行到这之前，因为return在Scala中是多余的，Scala总是返回最后一个语句。我们通过声明异常，就可以达到模拟break的实现，如我们定义一个抛出异常的break方法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def break = new RuntimeException(&quot;break exception&quot;)</span><br></pre></td></tr></table></figure>
<p>下面我们以此创建一个闭包函数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def breakable(op: =&gt; Unit) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>op: =&gt; Unit</code>是什么？右箭头<code>=&gt;</code>表示函数<code>breakable</code>中要求一个函数作为参数；箭头右边的为breakable函数的返回类型（——本例中Unit相当于Java中的void）；<code>op</code>为参数名。因为在右箭头(<code>=&gt;</code>)左边没有定义任何东西，这意味着作为参数的函数自身不具有参数，若其要传递参数，以foldLeft为例，需要如下定义</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def foldLeft(initialValue: Int, operator: (Int, Int) =&gt; Int)= &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>我们以Scala实现搜索SCALA_HOME环境变量为例</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> breakException = <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">&quot;break exception&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">breakable</span></span>(op: =&gt; <span class="type">Unit</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">op</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123; <span class="keyword">case</span> _ =&gt; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">break</span> </span>= <span class="keyword">throw</span> breakException</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">install</span> </span>= &#123;</span><br><span class="line"><span class="keyword">val</span> env = <span class="type">System</span>.getenv(<span class="string">&quot;SCALA_HOME&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(env == <span class="literal">null</span>) <span class="keyword">break</span></span><br><span class="line">println(<span class="string">&quot;found scala home lets do the real work&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用该闭包:breakable(install)，因为breakable中的实际参数为install，而install的参数为空，所以另外一种方式就是通过行内调用，如</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">breakable &#123;</span><br><span class="line"><span class="keyword">val</span> env = <span class="type">System</span>.getenv(<span class="string">&quot;SCALA_HOME&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(env == <span class="literal">null</span>) <span class="keyword">break</span></span><br><span class="line">println(<span class="string">&quot;found scala home lets do the real work&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong> 在Scala中，如果函数的最后一个参数为function类型，你就可以把该函数作为闭包传递。这个语法糖对创建DSL非常有用。下一章开始将介绍闭包如何转换为对象，记住，在Scala中，一切都是对象。</p>
<p><strong>注意</strong> 在Scala的库中早就已经提供了breakable，参考<code>scala.util.control.Breaks</code>。Scala中没有break关键字，如果你需要使用break你需要使用Breaks即可。</p>
<h3 id="Working-with-Array-and-List"><a class="header-anchor" href="#Working-with-Array-and-List">¶</a>Working with Array and List</h3>
<p>在第四章为数据结构部分，在此之前，先来了解一下List和Array，这样我们就可以写一些比较有用的Scala脚本。<br>
下面例子中，array是scala.Array中的一个实例，scala.Array类似Java中的Array类。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val array = new Array[String](3)</span></span><br><span class="line">array: Array[String] = Array(null, null, null)</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">array(0) = <span class="string">&quot;This&quot;</span></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">array(1) = <span class="string">&quot;is&quot;</span></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">array(2) = <span class="string">&quot;mutable&quot;</span></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">array</span></span><br><span class="line">res37: Array[String] = Array(This, is, mutable)</span><br></pre></td></tr></table></figure>
<p>记住，在Scala中，类型信息和参数化使用方括号，他们的作用是等同的。参数化是用于在创建实例的时候计算出该实例的数据类型。<br>
下面打印出每个Array的元素</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">array.foreach(println)</span></span><br><span class="line">This</span><br><span class="line">is</span><br><span class="line">mutable</span><br></pre></td></tr></table></figure>
<p>由于Scala中默认引入了Predef，所以，在使用Array对象的同时，请查看<code>scala.collection.mutable.ArrayLike</code>类，它被声明为<code>trait</code>（特质）。因此在使用Array实例的时候，可以动态地使用ArrayLike提供的功能。</p>
<p><strong>注意</strong> Predef默认将Array转换为<code>scala.collection.mutable.ArrayOps.ArrayOps</code>，该类是ArrayLike的子类。因此，ArrayLike就相当于一个接口为其子类提供了大量的方法，不同的是，在Scala中是通过trait声明，而在Java中是通过interface声明。</p>
<h5 id="命令行参数"><a class="header-anchor" href="#命令行参数">¶</a>命令行参数</h5>
<p>你可以使用一个隐式的val变量args来获取命令行输入的参数，如输出在控制台输入的参数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">args.foreach(println)</span><br></pre></td></tr></table></figure>
<p>我们把该表达式存储为一个myfirstScript.scala文件，在控制台输入如下命令 <code>scala myfirstScript.scala my first script</code>将输出如下结果</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my </span><br><span class="line">first </span><br><span class="line">script</span><br></pre></td></tr></table></figure>
<p>Array是一个可变数据结构。通过向array中添加元素会改变array实例并产生副作用。在函数式编程中，方法不应该有副作用。方法的唯一作用就是计算值并返回值而不改变实例。因此，你可以使用List代替，在Scala中，List是不可变的并使得函数式编程变得容易。创建一个List可以如下创建</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val myList = List(<span class="string">&quot;This&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;immutable&quot;</span>)</span></span><br><span class="line">myList: List[java.lang.String] = List(This, is, immutable)</span><br></pre></td></tr></table></figure>
<p>也可以如下创建</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val myList = scala.collection.immutable.List(<span class="string">&quot;This&quot;</span>, <span class="string">&quot;is&quot;</span>,<span class="string">&quot;immutable&quot;</span>)</span></span><br><span class="line">myList: List[java.lang.String] = List(This, is, immutable)</span><br></pre></td></tr></table></figure>
<blockquote><p><strong>什么是scala.collection.immutable.<img src="https://math.now.sh?inline=colon" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>colon？</strong></p>
<p>在上面例子中，你调用getClass方法查看对象的类型，你会对其输出觉得奇怪</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">myList.getClass</span></span><br><span class="line">res42: java.lang.Class[_] = class</span><br><span class="line">scala.collection.immutable.$colon$colon</span><br></pre></td></tr></table></figure>
<p>这是因为<code>scala.collection.immutable.List</code>是一个抽象类，它包含两个实现类，<code>scala.Nil</code>和<code>scala.::.</code>。在Scala中，<code>::</code>是个有效标识符，你可以用它来命名一个类。<code>Nil</code>代表一个空的list，<code>scala.::</code>则代表非空的list。</p>
</blockquote>
<p>可变集合大多数情况用于添加和删除元素，但不可变集合是不会被改变的，但可以通过创建新的实例实现，如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val oldList = List(1, 2)</span></span><br><span class="line">oldList: List[Int] = List(1, 2)</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val newList = 3 :: oldList</span></span><br><span class="line">newList: List[Int] = List(3, 1, 2)</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">oldList</span></span><br><span class="line">res45: List[Int] = List(1, 2)</span><br></pre></td></tr></table></figure>
<p>上述例子中，<code>::</code>用于创建一个新的实例并将元素添加的list的前面，如果要放到最后，可以使用<code>:+</code>方法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val newList = oldList :+ 3</span></span><br><span class="line">newList: List[Int] = List(1, 2, 3)</span><br></pre></td></tr></table></figure>
<p>Scala中提供了一个特殊的对象<code>Nil</code>用于表示空List，因此，你可以用它创建一个空列表</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val myList = <span class="string">&quot;This&quot;</span> :: <span class="string">&quot;is&quot;</span> :: <span class="string">&quot;immutable&quot;</span> :: Nil</span></span><br><span class="line">myList: List[java.lang.String] = List(This, is, immutable)</span><br></pre></td></tr></table></figure>
<p>在Scala中，若要删除一个元素，可以使用<code>-</code>方法，但是它是过时的。取而代之的是使用<code>filterNot</code>方法，该方法提供一个断言(predicate)，然后根据断言选择出所有不符合的元素并放置到新的实例里面。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val afterDelete = newList.filterNot(_ == 3)</span></span><br><span class="line">afterDelete: List[Int] = List(1, 2)</span><br></pre></td></tr></table></figure>
<p>关于集合更多内容，将在本书第四章4.3节作着重介绍。</p>
<h2 id="Controlling-flow-with-loops-and-ifs"><a class="header-anchor" href="#Controlling-flow-with-loops-and-ifs">¶</a>Controlling flow with loops and ifs</h2>
<p>if~else流程控制语句和其他编程语言一样，if为true则执行if语句块，否则执行else语句块。不同的是，在Scala中所有语句都是表达式，而它的值取决于最后一个表达式的值。因此，声明一个值取决于某些条件，如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val someValue = if(some condition) value1 else value2</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val useDefault = <span class="literal">false</span></span></span><br><span class="line">useDefault: Boolean = false</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val configFile = <span class="keyword">if</span>(useDefault) <span class="string">&quot;custom.txt&quot;</span> <span class="keyword">else</span> <span class="string">&quot;default.txt&quot;</span></span></span><br><span class="line">configFile: java.lang.String = default.txt</span><br></pre></td></tr></table></figure>
<p>在Java中可以使用<code>？</code>三元表达式，但在Scala中不支持，因为<code>？</code>表达式是多余的，你甚至可以用if~else组合更加复杂的表达式语句。<br>
循环语句在Scala中全面支持，比如<code>while</code>循环、<code>do-while</code>循环，但这两个都比较独立，和Java以及C#的使用没有异样。在<br>
Scala中真正比较有趣的是for循环。</p>
<h2 id="For-comprehensions"><a class="header-anchor" href="#For-comprehensions">¶</a>For-comprehensions</h2>
<p>For-comprehensions 就像一把瑞士军刀一样，你可以用它做许多事情。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> files = <span class="keyword">new</span> java.io.<span class="type">File</span>(<span class="string">&quot;.&quot;</span>).listFiles</span><br><span class="line"><span class="keyword">for</span>(file &lt;- files) &#123;</span><br><span class="line"><span class="keyword">val</span> filename = file.getName</span><br><span class="line"><span class="keyword">if</span>(fileName.endsWith(<span class="string">&quot;.scala&quot;</span>)) println(file)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和Java和C#不同是地方是<code>file &lt;- files</code>，在Scala中叫做生成器(generator)，生成器的工作就是用于迭代，箭头右边的表示集合。用Java写则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(File file: files) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> file.getName();</span><br><span class="line"><span class="keyword">if</span>(filename.endsWith(<span class="string">&quot;.scala&quot;</span>)) System.out.println(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在本例中，你可以不用声明迭代对象的类型。另外一种写法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(</span><br><span class="line">  file &lt;- files;</span><br><span class="line">  fileName = file.getName</span><br><span class="line">  <span class="keyword">if</span> fileName.endsWith(<span class="string">&quot;.iml&quot;</span>)</span><br><span class="line">) println(file)</span><br></pre></td></tr></table></figure>
<p>不同的是，在括号内的所有变量都是val类型的，因此它们不能被修改并减少代码的副作用。<br>
你也可以声明多个生成器(generator)，如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val aList = List(1, 2, 3)</span></span><br><span class="line">aList: List[Int] = List(1, 2, 3)</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val bList = List(4, 5, 6)</span></span><br><span class="line">bList: List[Int] = List(4, 5, 6)</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash"><span class="keyword">for</span> &#123; a &lt;- aList; b &lt;- bList &#125; println(a + b)</span></span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<p>实际上这是两层循环，即当a=1时，对b=4，5，6进行迭代，依此类推。你也可以用小括号()代替中括号。</p>
<p>从for-comprehension中可以看出了Scala的两种特性。即命令式和函数式。上面例子即为命令式，这种模式中容许语句反复运行数次而不返回值，直到某些条件改变。另一种命令式(functional form)也就序列解析(sequence comprehension)，在这种模式中，更偏向于使用值而不是执行表达式语句，并且不返回值。如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash"><span class="keyword">for</span> &#123; a &lt;- aList; b &lt;- bList &#125; yield a + b</span></span><br><span class="line">res27: List[Int] = List(5, 6, 7, 6, 7, 8, 7, 8, 9)</span><br><span class="line">为了取代输出一个值，Scala中使用yield关键字代替返回的值，因此当你实际需要输出时，替换yield操作</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val result = <span class="keyword">for</span> &#123; a &lt;- aList; b &lt;- bList &#125; yield a + b</span></span><br><span class="line">result: List[Int] = List(5, 6, 7, 6, 7, 8, 7, 8, 9)</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash"><span class="keyword">for</span>(r &lt;- result) println(r)</span></span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<p>看起来函数式比命令式要累赘，但是想想。你已经将计算（本例为两个数相加）和使用（输出结果）进行了分离，这提高了代码复用和函数的组合能力，这就是函数式编程的一个好处。例如下面是for-yield复用的一个例子</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val xmlNode = &lt;result&gt;&#123;result.mkString(<span class="string">&quot;,&quot;</span>)&#125;&lt;/result&gt;</span></span><br><span class="line">xmlNode: scala.xml.Elem = &lt;result&gt;5,6,7,6,7,8,7,8,9&lt;/result&gt;</span><br></pre></td></tr></table></figure>
<p>mkString是定义在<code>scala.collection.immutable.List</code>中的一个方法，但是如果在表达中直接输出结果会怎样？显然这不好实现。记住，所有东西在Scala中都是表达式，并且都有一个返回值。例如将代码改为如下仍然可以获得一个返回值，但是返回的是一个空的集合</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash"><span class="keyword">for</span> &#123; a &lt;- aList; b &lt;- bList &#125; yield &#123; println(a+b)&#125;</span></span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">res32: List[Unit] = List((), (), (), (), (), (), (), (), ())</span><br></pre></td></tr></table></figure>
<p>因为yield 后面跟着的是println，println返回值类型是unit，即相当于Java中的void。</p>
<h2 id="Pattern-Matching"><a class="header-anchor" href="#Pattern-Matching">¶</a>Pattern Matching</h2>
<p>模式匹配属于Scala函数式编程中的一个概念部分。模式匹配跟Java中的switch case类似。如下列出模式匹配在Scala和Java中的实现<br>
-一般匹配模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ordinal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ordinal(Integer.parseInt(args[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ordinal</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(number) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: System.out.println(<span class="string">&quot;1st&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: System.out.println(<span class="string">&quot;2nd&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: System.out.println(<span class="string">&quot;3rd&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: System.out.println(<span class="string">&quot;4th&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: System.out.println(<span class="string">&quot;5th&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: System.out.println(<span class="string">&quot;6th&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: System.out.println(<span class="string">&quot;7th&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>: System.out.println(<span class="string">&quot;8th&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>: System.out.println(<span class="string">&quot;9th&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>: System.out.println(<span class="string">&quot;10th&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span> : System.out.println(<span class="string">&quot;Cannot do beyond 10&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Scala中实现</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ordinal(args(<span class="number">0</span>).toInt)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ordinal</span></span>(number:<span class="type">Int</span>) = number <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> =&gt; println(<span class="string">&quot;1st&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span> =&gt; println(<span class="string">&quot;2nd&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span> =&gt; println(<span class="string">&quot;3rd&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span> =&gt; println(<span class="string">&quot;4th&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span> =&gt; println(<span class="string">&quot;5th&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span> =&gt; println(<span class="string">&quot;6th&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span> =&gt; println(<span class="string">&quot;7th&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span> =&gt; println(<span class="string">&quot;8th&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span> =&gt; println(<span class="string">&quot;9th&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span> =&gt; println(<span class="string">&quot;10th&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> _ =&gt; println(<span class="string">&quot;Cannot do beyond 10&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和Java不同的是，你不用声明main方法入口，不用使用break语句，因为在Scala的case中不会跳转到其它语句上，default值则使用_占位符匹配所有。因为Scala支持脚本，因此在终端输入运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala Ordinal.scala &lt;your input&gt;</span><br></pre></td></tr></table></figure>
<p>在Scala中，<code>case _</code>是可选的，移除后如果不匹配，则Scala会提示错误</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">2 match &#123; <span class="keyword">case</span> 1 =&gt; <span class="string">&quot;One&quot;</span> &#125;</span></span><br><span class="line">scala.MatchError: 2</span><br><span class="line">at .&lt;init&gt;(&lt;console&gt;:5)</span><br><span class="line">at .&lt;clinit&gt;(&lt;console&gt;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这点和Java的default不同，Java中去掉default后，如果不匹配，不会抛出任何信息，因为Java中这不算是异常。</p>
<h5 id="类型匹配"><a class="header-anchor" href="#类型匹配">¶</a>类型匹配</h5>
<p>Java中的switch case只能用于断言或枚举，而在Scala中，你可以匹配字符串，值，类型，变量，常量和构造器。更多模式匹配的概念会在下一章介绍，特别是构造器的匹配。下面是Scala模式匹配的一个例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printType</span></span>(obj: <span class="type">AnyRef</span>) = obj <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s: <span class="type">String</span> =&gt; println(<span class="string">&quot;This is string&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> l: <span class="type">List</span>[_] =&gt; println(<span class="string">&quot;This is List&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> a: <span class="type">Array</span>[_] =&gt; println(<span class="string">&quot;This is an array&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> d: java.util.<span class="type">Date</span> =&gt; println(<span class="string">&quot;This is a date&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中用于匹配类型，如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">printType(<span class="string">&quot;Hello&quot;</span>)</span></span><br><span class="line">This is string</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">printType(List(1, 2, 3))</span></span><br><span class="line">This is List</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">printType(new Array[String](2))</span></span><br><span class="line">This is an array</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">printType(new java.util.Date())</span></span><br><span class="line">This is a date</span><br></pre></td></tr></table></figure>
<h5 id="中辍操作匹配（插入操作匹配）"><a class="header-anchor" href="#中辍操作匹配（插入操作匹配）">¶</a>中辍操作匹配（插入操作匹配）</h5>
<p>更为强大的是Scala中支持中辍操作匹配，如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">List(1, 2, 3, 4) match &#123;</span></span><br><span class="line">case f :: s :: rest =&gt; List(f, s)</span><br><span class="line">case _ =&gt; Nil</span><br><span class="line">&#125;</span><br><span class="line">res7: List[Int] = List(1, 2)</span><br></pre></td></tr></table></figure>
<p>上面例子中表示要求list元素匹配<code>f::ss::rest</code>并输出<code>f::ss</code>，满足这种匹配的结果有<code>1::2::3，4</code>，则输出<code>f::ss</code>结果就是<code>1，2</code>。</p>
<h5 id="case增强"><a class="header-anchor" href="#case增强">¶</a>case增强</h5>
<p>Scala允许你在case语句中使用扩展</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rangeMatcher</span></span>(num:<span class="type">Int</span>) = num <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> within10 <span class="keyword">if</span> within10 &lt;= <span class="number">10</span> =&gt; println(<span class="string">&quot;with in 0 to 10&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> within100 <span class="keyword">if</span> within100 &lt;= <span class="number">100</span> =&gt; println(<span class="string">&quot;with in 11 to 100&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> beyond100 <span class="keyword">if</span> beyond100 &lt; <span class="type">Integer</span>.<span class="type">MAX_VALUE</span> =&gt; println(<span class="string">&quot;beyond 100&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了上面这些功能后，我们对原来的例子进行改进</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> suffixes = <span class="type">List</span>(<span class="string">&quot;th&quot;</span>, <span class="string">&quot;st&quot;</span>, <span class="string">&quot;nd&quot;</span>, <span class="string">&quot;rd&quot;</span>, <span class="string">&quot;th&quot;</span>, <span class="string">&quot;th&quot;</span>, <span class="string">&quot;th&quot;</span>, <span class="string">&quot;th&quot;</span>, <span class="string">&quot;th&quot;</span>,<span class="string">&quot;th&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ordinal</span></span>(number:<span class="type">Int</span>) = number <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> tenTo20 <span class="keyword">if</span> <span class="number">10</span> to <span class="number">20</span> contains tenTo20 =&gt; number + <span class="string">&quot;th&quot;</span></span><br><span class="line"><span class="keyword">case</span> rest =&gt; rest + suffixes(number % <span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处调用了RichInt的to方法，该方法创建了一个范围对象(scala.collection.immutable<br>
.Inclusive)，该对象包含一个contains方法用于判断返回。最后一个表达式将不在10到20的变量映射到rest上。这叫做 可变模式匹配。你可以通过下标访问list中的特定元素。</p>
<h2 id="Exception-handling"><a class="header-anchor" href="#Exception-handling">¶</a>Exception handling</h2>
<p>前面的breakable例子初步接触了异常处理。Scala中的异常处理和Java有些许的不同。Scala支持单一的try/catch语句块，在这个单一catch语句块里面你可以使用模式匹配来捕获异常。实际上catch语句块就是匹配语句块，因此前面你所学到的模式匹配技术都可以用到catch语句块中。如修改rangeMatcher为</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rangeMatcher</span></span>(num:<span class="type">Int</span>) = num <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> within10 <span class="keyword">if</span> within10 &lt;= <span class="number">10</span> =&gt; println(<span class="string">&quot;with in 0 to 10&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> within100 <span class="keyword">if</span> within100 &lt;= <span class="number">100</span> =&gt; println(<span class="string">&quot;with in 11 to 100&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(</span><br><span class="line"><span class="string">&quot;Only values between 0 and 100 are allowed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，将其包含到try/catch语句中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">try &#123;</span></span><br><span class="line">rangeMatcher1(1000)</span><br><span class="line">&#125; catch &#123; case e: IllegalArgumentException =&gt; e.getMessage &#125;</span><br><span class="line">res19: Any = Only values between 0 and 100 are allowed</span><br></pre></td></tr></table></figure>
<p>Scala中没有类型检测的概念，所有异常都是未检测的。这是非常强大和灵活的，因为对于编程人员，你可以决定是否需要抛出异常，尽管Scala异常处理被实现得非常不一样，但行为机制和Java是一模一样的，通过不进行异常检测，是的Scala可以更容易地和Java现有的框架进行相互操作。你会在本书各处看到Scala异常处理的例子。</p>
<h2 id="Command-line-REST-client-building-a-working-example"><a class="header-anchor" href="#Command-line-REST-client-building-a-working-example">¶</a>Command-line REST client: building a working example</h2>
<h4 id="什么是REST"><a class="header-anchor" href="#什么是REST">¶</a>什么是REST?</h4>
<p>REST是(REpresentational State Transfer)的缩写，意即表述性状态转移。它是分布式超媒体系统(如WWW)的软件架构风格。<br>
系统遵循如下REST原则的称为RESTful：</p>
<p>①Application state and functionality are divided into resources.<br>
应用的状态和功能被分成资源。</p>
<p>②Every resource is uniquely addressable using a universal syntax.<br>
任何一个资源都有唯一一个访问入口，可使用一般语法访问。</p>
<p>③All resources share a uniform interface for transfer of state between client and resource, consisting of well-defined operations (GET, POST, PUT, DELETE, OPTIONS, and so on, for RESTful web services) and content types.<br>
所有资源共享标准接口用于在客户~资源之间进行状态转换，持有良好的操作和上下文类型。</p>
<p>④A protocol that’s client/server, stateless cacheable, and layered.<br>
协议是C/S，无状态的，缓存的，分层的。</p>
<h3 id="Introducing-HttpClient-library"><a class="header-anchor" href="#Introducing-HttpClient-library">¶</a>Introducing HttpClient library</h3>
<p>HttpClient<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>是Apache的一个框架，它是一个客户端HTTP传输库。作用是用于发送和接口HTTP消息。它不是浏览器，也不执行与HTTP传输无关的事情，诸如JavaScript解析或猜测客户content-type内容等。HttpClient的主要工作就是执行HTTP方法。HttpClient会接受用户的请求对象(如HttpPost或HttpGet)，然后将请求发送到目标服务器并返回响应对象或者抛出异常。<br>
HttpClient封装了每个HTTP方法类型在一个对象中，这些方法在org.apache.http.client.methods中提供。本例将使用4中请求类型 GET, POST, DELETE, 和 OPTIONS。HttpClient默认提供的client已经足够我们使用了</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> httpDelete = <span class="keyword">new</span> <span class="type">HttpDelete</span>(url)</span><br><span class="line"><span class="keyword">val</span> httpResponse = <span class="keyword">new</span> <span class="type">DefaultHttpClient</span>().execute(httpDelete)</span><br></pre></td></tr></table></figure>
<p>根据HTTP规范，HTTP的POST方法有点不同，POST方法和PUT方法是实体封装的。<br>
如果要在脚本中使用HttpClient，需要导入相应的包，Scala和Java一样，使用import关键字导入，不同的是Scala是使用_表示包中的所有类</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.http._</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.entity._</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods._</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client._</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.utils._</span><br><span class="line"><span class="keyword">import</span> org.apache.http.message._</span><br><span class="line"><span class="keyword">import</span> org.apache.http.params._</span><br></pre></td></tr></table></figure>
<p>关于import的更多用法，将在下一章介绍</p>
<h2 id="Building-the-client-step-by-step"><a class="header-anchor" href="#Building-the-client-step-by-step">¶</a>Building the client, step by step</h2>
<p>这部分为本章所有知识点用例，请参考项目代码RestClient.scala，并尝试动手调试。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.scala.chapter2.o</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile in sbt</span></span><br><span class="line"><span class="comment">// Run in sbt&gt;run get https://raw.githubusercontent.com/nraychaudhuri/scalainaction/master/chap02/breakable.scala</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The command line in sbt is </span></span><br><span class="line"><span class="comment">// &gt;run (post | get | delete | options) -d &lt;request parameters comma separated -h &lt;headers comma separated&gt; &lt;url&gt;</span></span><br><span class="line"><span class="comment">// at minimum you should specify action(post, get, delete, options) and url</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.cert.<span class="type">X509Certificate</span></span><br><span class="line"><span class="keyword">import</span> javax.net.ssl._</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.entity.<span class="type">UrlEncodedFormEntity</span></span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods._</span><br><span class="line"><span class="keyword">import</span> org.apache.http.conn.scheme.<span class="type">Scheme</span></span><br><span class="line"><span class="keyword">import</span> org.apache.http.conn.ssl.&#123;<span class="type">SSLSocketFactory</span>, <span class="type">X509HostnameVerifier</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client._</span><br><span class="line"><span class="keyword">import</span> org.apache.http.message._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">RestClient</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*解析参数*/</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parseArgs</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Map</span>[<span class="type">String</span>, <span class="type">List</span>[<span class="type">String</span>]] = &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nameValuePair</span></span>(paramName: <span class="type">String</span>) = &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">values</span></span>(commaSeperatedValues: <span class="type">String</span>) = commaSeperatedValues.split(<span class="string">&quot;,&quot;</span>).toList</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> index = args.indexWhere(_ == paramName)</span><br><span class="line">      (paramName, <span class="keyword">if</span> (index == <span class="number">-1</span>) <span class="type">Nil</span> <span class="keyword">else</span> values(args(index + <span class="number">1</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Map</span>(nameValuePair(<span class="string">&quot;-d&quot;</span>), nameValuePair(<span class="string">&quot;-h&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">splitByEqual</span></span>(nameValue: <span class="type">String</span>): <span class="type">Array</span>[<span class="type">String</span>] = nameValue.split(&#x27;=&#x27;)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">headers</span> </span>= <span class="keyword">for</span> (nameValue &lt;- params(<span class="string">&quot;-h&quot;</span>)) <span class="keyword">yield</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tokens</span> </span>= splitByEqual(nameValue)</span><br><span class="line">    <span class="keyword">new</span> <span class="type">BasicHeader</span>(tokens(<span class="number">0</span>), tokens(<span class="number">1</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">formEntity</span> </span>= &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toJavaList</span></span>(scalaList: <span class="type">List</span>[<span class="type">BasicNameValuePair</span>]) = &#123;</span><br><span class="line">      java.util.<span class="type">Arrays</span>.asList(scalaList.toArray: _*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">formParams</span> </span>= <span class="keyword">for</span> (nameValue &lt;- params(<span class="string">&quot;-d&quot;</span>)) <span class="keyword">yield</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">tokens</span> </span>= splitByEqual(nameValue)</span><br><span class="line">      <span class="keyword">new</span> <span class="type">BasicNameValuePair</span>(tokens(<span class="number">0</span>), tokens(<span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">formEntity</span> </span>= <span class="keyword">new</span> <span class="type">UrlEncodedFormEntity</span>(toJavaList(formParams), <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">    formEntity</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handlePostRequest</span></span>() = &#123;</span><br><span class="line">    <span class="keyword">val</span> httppost = <span class="keyword">new</span> <span class="type">HttpPost</span>(url)</span><br><span class="line">    headers.foreach &#123;</span><br><span class="line">      httppost.addHeader(_)</span><br><span class="line">    &#125;</span><br><span class="line">    httppost.setEntity(formEntity)</span><br><span class="line">    <span class="keyword">val</span> responseBody = httpClient.execute(httppost, <span class="keyword">new</span> <span class="type">BasicResponseHandler</span>())</span><br><span class="line">    println(responseBody)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handleGetRequest</span></span>() = &#123;</span><br><span class="line">    <span class="keyword">val</span> query = params(<span class="string">&quot;-d&quot;</span>).mkString(<span class="string">&quot;&amp;&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> httpget = <span class="keyword">new</span> <span class="type">HttpGet</span>(<span class="string">s&quot;<span class="subst">$url</span>?<span class="subst">$query</span>&quot;</span>)</span><br><span class="line">    headers.foreach &#123;</span><br><span class="line">      httpget.addHeader(_)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> responseBody = httpClient.execute(httpget, <span class="keyword">new</span> <span class="type">BasicResponseHandler</span>())</span><br><span class="line">    println(responseBody)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handleDeleteRequest</span></span>() = &#123;</span><br><span class="line">    <span class="keyword">val</span> httpDelete = <span class="keyword">new</span> <span class="type">HttpDelete</span>(url)</span><br><span class="line">    <span class="keyword">val</span> httpResponse = httpClient.execute(httpDelete)</span><br><span class="line">    println(httpResponse.getStatusLine)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handleOptionsRequest</span></span>() = &#123;</span><br><span class="line">    <span class="keyword">val</span> httpOptions = <span class="keyword">new</span> <span class="type">HttpOptions</span>(url)</span><br><span class="line">    headers.foreach &#123;</span><br><span class="line">      httpOptions.addHeader(_)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> httpResponse = httpClient.execute(httpOptions)</span><br><span class="line">    println(httpOptions.getAllowedMethods(httpResponse))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*require 函数用于抛出异常*/</span></span><br><span class="line">  require(args.size &gt;= <span class="number">2</span>, <span class="string">&quot;at minimum you should specify action(post, get, delete, options) and url&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> command = args.head</span><br><span class="line">  <span class="keyword">val</span> params = parseArgs(args)</span><br><span class="line">  <span class="keyword">val</span> url = args.last</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** SNI(Server Name Indication) 问题</span></span><br><span class="line"><span class="comment">    * 针对https服务器会使用SNI选择证书进行发送，但是本例不支持SNI(如一些Android系统)，在SSL/TLS握手期间，</span></span><br><span class="line"><span class="comment">    * 服务器无法根据客户端选择哪种SNI证书发送，因此需要让其验证时为True</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">val</span> xtm = <span class="keyword">new</span> <span class="type">X509TrustManager</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getAcceptedIssuers</span></span>: <span class="type">Array</span>[<span class="type">X509Certificate</span>] = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">checkClientTrusted</span></span>(p1: <span class="type">Array</span>[<span class="type">X509Certificate</span>], p2: <span class="type">String</span>): <span class="type">Unit</span> = &#123;&#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">checkServerTrusted</span></span>(p1: <span class="type">Array</span>[<span class="type">X509Certificate</span>], p2: <span class="type">String</span>): <span class="type">Unit</span> = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> hostnameVerifier = <span class="keyword">new</span> <span class="type">X509HostnameVerifier</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">verify</span></span>(p1: <span class="type">String</span>, p2: <span class="type">SSLSocket</span>): <span class="type">Unit</span> = &#123;&#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">verify</span></span>(p1: <span class="type">String</span>, p2: <span class="type">X509Certificate</span>): <span class="type">Unit</span> = &#123;&#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">verify</span></span>(p1: <span class="type">String</span>, p2: <span class="type">Array</span>[<span class="type">String</span>], p3: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;&#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">verify</span></span>(p1: <span class="type">String</span>, p2: <span class="type">SSLSession</span>): <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//TLS1.0与SSL3.0基本上没有太大的差别，可粗略理解为TLS是SSL的继承者，但它们使用的是相同的SSLContext</span></span><br><span class="line">  <span class="keyword">val</span> ctx = <span class="type">SSLContext</span>.getInstance(<span class="string">&quot;TLS&quot;</span>)</span><br><span class="line">  <span class="comment">//使用TrustManager来初始化该上下文，TrustManager只是被SSL的Socket所使用</span></span><br><span class="line">  ctx.init(<span class="literal">null</span>, <span class="type">Array</span>(xtm), <span class="literal">null</span>)</span><br><span class="line">  <span class="comment">//创建SSLSocketFactory</span></span><br><span class="line">  <span class="keyword">var</span> socketFactory = <span class="keyword">new</span> <span class="type">SSLSocketFactory</span>(ctx)</span><br><span class="line">  socketFactory.setHostnameVerifier(hostnameVerifier)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> httpClient = <span class="keyword">new</span> <span class="type">DefaultHttpClient</span>()</span><br><span class="line">  httpClient.getConnectionManager.getSchemeRegistry</span><br><span class="line">    .register(<span class="keyword">new</span> <span class="type">Scheme</span>(<span class="string">&quot;https&quot;</span>, socketFactory, <span class="number">443</span>))</span><br><span class="line"></span><br><span class="line">  command <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;post&quot;</span> =&gt; handlePostRequest()</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;get&quot;</span> =&gt; handleGetRequest()</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;delete&quot;</span> =&gt; handleDeleteRequest()</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;options&quot;</span> =&gt; handleOptionsRequest()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Summary"><a class="header-anchor" href="#Summary">¶</a>Summary</h2>
<p>本章涵盖了Scala的大部分基础概念，如数据类型、变量和函数，以及如何安装和配置Scala。更重要的是，你学会了如何定义函数，Scala语句块，函数式语言的概念，模式匹配和for-comprehension。你更学习了如何通过模式匹配技术来定义异常。同时本章也介绍了List和Array集合的使用以及如何编写Scala脚本。本章还介绍了REPL编程环境，并且REPL将通篇出现。本章最后还介绍了运用所学知识点编写REST程序代码。下一章开始，我们将着重介绍Scala类和对象。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a target="_blank" rel="noopener" href="http://mng.bz/32jw">Type inference</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a target="_blank" rel="noopener" href="http://mng.bz/H4ip">Daniel Spiewak, posted at Code Commit, “What is Hindley-Milner? (and why is it cool?)”</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a target="_blank" rel="noopener" href="http://mng.bz/Q4Bf">HttpClient Overview</a><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div></div></article><nav class="article-nav"><div class="article-nav-prev"><a href="/2016/10/27/scala/03-scala-oop/">第三章：Scala OOP</a></div><div class="article-nav-next"><a href="/2016/10/27/scala/01-scala-conception/">第一章：Scala基础</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2016/10/27/scala/02-getting-started/';
var disqus_title = '第二章：开始学习Scala';
var disqus_url = 'https://galudisu.info/2016/10/27/scala/02-getting-started/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>