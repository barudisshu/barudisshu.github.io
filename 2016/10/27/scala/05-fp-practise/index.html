<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>第五章：函数式编程</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">第五章：函数式编程</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2016-10-27</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/scala/">scala</a></p><p class="meta-item meta-category"><span class="meta-item-title"></span><i class="icon-bookmark"> </i><a class="category-link" href="/categories/learning/">learning</a></p></div><div class="article-content"><h4 id="主要内容"><a class="header-anchor" href="#主要内容">¶</a>主要内容</h4>
<ol>
<li>为什么函数式编程</li>
<li>FP和OOP</li>
<li>各种形式的函数</li>
<li>Monads以及应用实例</li>
</ol>
<p>前面部分或多或少介绍了Scala的函数式编程，或在Scala的面向对象结构中混入了函数式编程。本章将专注于函数式编程概念，以及它们是如何在Scala中实现的。本章主要目的是使你对函数式编程有个清晰的感知，并帮助你编写函数式编程风格代码。</p>
<p><em>函数式编程</em> 是一个编程范式，将计算行为模拟为表达式的求值。而这个表达式使用函数构建，不带有可变状态和副作用。函数式编程的起源是值得探索的<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 。相信与否，函数式编程始于约1930，Alonzo Church 介绍的 λ演算<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> 。一个λ演算是一套用于研究函数定义、函数应用和递归的形式系统。λ演算的函数都是第一类值(first-class value）；函数可以接收其它函数作为参数，返回函数作为输出(高阶函数)。</p>
<span id="more"></span>
<p>一个带有两个参数的函数，在λ演算中可以写作：</p>
<p style="filter: opacity(90%);transform:scale(0.85);text-align:center;"><img src="https://math.now.sh?from=%CE%BBx.%20%CE%BBy.%20x%20%2B%20y%0A" /></p><p>这个的<code>λx. λy. x + y</code>表示一个匿名函数，它接收<code>x</code>参数，返回新的匿名函数<code>λy. x + y</code>，新的匿名函数带有一个<code>y</code>参数，并返回结果<code>x + y</code>。在λ演算中，所有函数都是匿名的，并由符号 <code>λ</code>表示(因而得名lambda)。</p>
<p>λ演算是函数式编程的主要灵感所在。函数式编程语言以一些约束和类型来实现λ演算。不是所有的编程语言有诸如第一类函数(first-class functions)，模式匹配(pattern matching)之类的特性，但却可能在几乎所有编程语言中作函数式编程。接下来将介绍函数式编程的详细内容。</p>
<h2 id="5-1-什么是函数式编程？"><a class="header-anchor" href="#5-1-什么是函数式编程？">¶</a>5.1 什么是函数式编程？</h2>
<p>函数式编程，顾名思义就是以函数的形式实现编程。在这里不必要花太多来理解函数是什么。根据数学的定义，函数就是存在<code>x∈D</code>，总存在唯一的<code>f(x)</code>与之对应。因此，在Scala中，你可以将一个函数作如下标识：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>: <span class="type">X</span> =&gt; <span class="type">Y</span></span><br></pre></td></tr></table></figure>
<p>一个函数提供了可预测性,对于一个给定的输入你总会得到相同的输出。如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">def add(a: Int, b: Int): Int = a + b</span></span><br><span class="line">add: (a: Int,b: Int)Int</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">add(10, 10)</span></span><br><span class="line">res0: Int = 20</span><br></pre></td></tr></table></figure>
<p>这里函数<code>add:(Int,Int)=&gt;Int</code>匹配了函数的定义，因为对于给定的输入，它总是返回相同的结果。<br>
但是函数由内部状态决定使得并不能总是返回相同的结果又是怎么样？这类函数也是函数，但是它们不是纯的函数。纯函数不会有副作用。像更新一个全局的或静态的变量，将一个数据写入文件系统，在屏幕上展示这类称之为“副作用(side-effecting)”函数，抛出异常等都是术语副作用例子。纯函数的行为是不依赖于任何内部行为或状态。不允许改变参数的状态或者调用一个带有副作用的函数到另一个纯函数，如下的weather函数不是一个纯函数，因为weather状态会在调用的时候改变:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weather</span></span>(zipCode: <span class="type">String</span>) = &#123;</span><br><span class="line"><span class="keyword">val</span> url =</span><br><span class="line"><span class="string">&quot;http://api.wunderground.com/auto/wui/geo/GeoLookupXML/index.xml?query=&quot;</span></span><br><span class="line"><span class="type">Source</span>.fromURL(url + zipCode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要如此关心纯函数？纯函数编程的值(value)又是什么？<br>
值是引用透明性的。引用透明(Referential transparency)是指一个属性即一个表达式可以取代它的值而不影响它的程序。下面例子让我们看看引用透明是如何工作的。假设下面是函数程序的一部分:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">val</span> v = add(<span class="number">10</span>, <span class="number">10</span>) + add(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>因为add是一个纯函数，我可以用函数的调用<code>add(10, 10)</code>来替代它的值20，并且不改变程序的行为。相似地，我也可以用<code>add(5, 5)</code>来代替结果10而不影响程序。那我们为什么要如此关系引用透明？它有什么优势？</p>
<h3 id="5-1-1-引用透明的好处"><a class="header-anchor" href="#5-1-1-引用透明的好处">¶</a>5.1.1 引用透明的好处</h3>
<p>引用透明提供了代码的推导能力。通过替换纯函数以及使用纯函数的值，将一个复杂表达式简化为一个简单的表达式。甚至你可以在你的脑海里计算出一个程序的结果。这种代码的思考能力帮助编程工作者更好地调试和解决复杂的问题。它正是函数式编程之所在。面对各种不同的困难，你可以在任何编程语言中做函数式编程。函数式编程的本质是引用透明，它的好处是引用透明——更容易找的问题并修复。因为Scala是类型安全的，你可以在编译之前捕获到更多的异常。</p>
<p>在Scala中，函数式编程被烤制带有面向对象的特性，因此有时难于区分编程语言中你定义了方法还是定义了函数。这将在本节阐述，但现在需要记住的是，Scala中的方法没有任何类型；类型只关联闭包类，相反函数则由类型和对象所表示。</p>
<p>不幸的是，目前提出一个函数式语言的定义仍然显得困难。每个人都有他自己的定义机制，但是尽管函数式编程可能会出现在所有语言中，也并不意味着你应该使用它。它可能会出现在OOP编程语言中，但是也可能非常困难地实现，并且用起来很痛苦。在Scala中，编写函数式编程则是非常简单的，下一小节开始掌握。</p>
<h3 id="5-1-2-一个纯函数式编程"><a class="header-anchor" href="#5-1-2-一个纯函数式编程">¶</a>5.1.2 一个纯函数式编程</h3>
<p>一个纯函数式编程是一个单引用透明表达式(single referentially transparent expression)。一个表达式由一个子表达式的组合创建。一个表达式总是求一个结果。如下面是一个纯函数的例子:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PureFunctionalProgram</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = singleExpression(args.toList)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">singleExpression</span></span>: <span class="type">List</span>[<span class="type">String</span>] =&gt; (<span class="type">List</span>[<span class="type">Int</span>], <span class="type">List</span>[<span class="type">Int</span>]) = &#123; a =&gt;</span><br><span class="line">    a map (_.toInt) partition (_ &lt; <span class="number">30</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的main方法是我们纯函数的入口，剩余部分定义了一个单表达式，它接收一个字符集合参数并返回一个<code>Tuple</code>。返回内容有两个子表达式组成: <code>a map (_.toInt)</code> 和 <code>&lt;result of first sub expression&gt; partition(_ &lt; 30)</code>。你可以认为是由一个子表达式集合组合成为一个单引用透明的表达式，你实现了一个纯函数程式。当然，你还需要从控制台或者系统中读取输入参数，但是不管输入内容是什么，纯函数的行为是不会改变的。</p>
<h2 id="5-2-从OOP到FP"><a class="header-anchor" href="#5-2-从OOP到FP">¶</a>5.2 从OOP到FP</h2>
<p>Java、C#或者C++编程开发者已经早已熟悉类和对象的概念并更习惯于OOP。那如何从更多的OOP经验过渡到更多的函数式编程风格上呢？在这方面，Scala允许你组合一个优雅的和设计良好的代码风格。它可以从只关注的面向对象开始，你可能慢慢地过渡到一个更多的函数式编程风格。在这个章节将强调一些技术关于函数式编程风格以及目前保留的OO技术和风格支持实现。</p>
<h3 id="5-2-1-纯与不纯编程"><a class="header-anchor" href="#5-2-1-纯与不纯编程">¶</a>5.2.1 纯与不纯编程</h3>
<p>咋看之下，在纯与不纯的层面上比较面向对象编程与函数式编程，可能会觉得奇怪。尽管你可以编写面向对象代码而不会有side effects，但在编写OOP中更容易充斥着不良的负面效果。典型地，OO-style的应用程序在程序内部会通过大量的对象构建了一系列的可变状态的概念(冗余作用)。<br>
<strong>面向对象的解决方案是一个环绕着类和对象的模型，这些模型倾向于承载方法的集合，以及共享这些方法或偶尔使这些数据发生变异。</strong> 函数编程风格仅仅解决在函数处理数据中问题的值。因为数据只由值表示，每一个应用中的函数将产生一个新的值而不会带有任何负面效果。<br>
另一个区别就是函数式编程提高了在OOP中的抽象层次。OOP有时感觉像机器从属的(machine-dependent)——值传递、引用传递、相等性以及同一性，并基于程式如何在运行时被解析和执行的定义。如果你仅仅对值(values)作处理，那么你的函数式编程如何被解析和执行变得无关紧要。记住，你可以通过纸和笔计算纯函数程序的结果；使用机器运行则是细节实现。</p>
<p>在诸如Haskell和Clojure语言中，当你仅仅只有函数，你不需要担心不纯问题。但Scala是一门同时包含面向对象和函数编程的语言，因此你必须特别小心副作用(side effects)。在Scala中你仍然需要定义类(或特质traits)和对象来组织你的方法和函数值。并且，你作为一个开发者，你的职责应该确定你不在类内部定义依赖于可变数据。<br>
如下面例子，一个矩形带有一个方法用于计算面积:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span>(<span class="params">var side: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">area</span> </span>= side * side</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类的问题是side的属性是可变的，area方法依赖于side计算的值。很明显它不是一个纯的处理，因为area方法的结果依赖于外部的状态——这里是side属性。同时也很难推出area方法的值，因为你必须时刻保持与side属性的联系。要实现Square的纯函数，你会用到<code>Successor Value pattern</code>模式<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup> ——也叫函数对象模式，即每个状态的改变都返回自身新状态的一个拷贝。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PureSquare</span>(<span class="params">val side: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newSide</span></span>(s: <span class="type">Int</span>): <span class="type">PureSquare</span> = <span class="keyword">new</span> <span class="type">PureSquare</span>(s)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">area</span> </span>= side * side</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，每次side属性被修改，一个新的PureSquare拷贝会被返回，因此你不需要担心可变状态和area方法的结果，因为它已经被关联到一个新的对象了，PureSquare。这个常用的模式被用于模拟一个可能会更改的状态。Java的String类在通篇全书中使用的例子就是一个函数对象模式。现在你的挑战是以相似的形式设计你的对象，因为它很容易地降低了副作用的无意产生。注意所有你的方法中依赖的vars和setters并尽量使他们是纯的。以后我们要记住: 引用透明是一个良好的设计标准。</p>
<h3 id="5-2-2-函数式编程的面向对象设计模式"><a class="header-anchor" href="#5-2-2-函数式编程的面向对象设计模式">¶</a>5.2.2 函数式编程的面向对象设计模式</h3>
<p>设计模式在OOP作为交流的工具，在FP中同样重要。一些设计模式，诸如单例(Singleton)、工厂(Factory)、观察者(Vistor)早已作为语言的一部分实现。你可以使用Scala对象轻松地实现单例和工厂模式。你可以使用Scala的模式匹配来实现观察者模式。看看策略模式(Strategy pattern)<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup> 。该模式允许你在运行时选择算法，并简单地使用高阶函数实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculatePrice</span></span>(product: <span class="type">String</span>, taxingStrategy: <span class="type">String</span> =&gt; <span class="type">Double</span>) = &#123;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">val</span> tax = taxingStrategy(product)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>taxingStrategy</code>被定义为一个函数，你可以传递不同的实现strategy。类似地，你也可以使用高阶函数来实现模板方法(template method)模式。</p>
<p>高阶函数对于处理依赖注入(DI)也很有帮助。你可以使用函数科里化来注入依赖。例如，你可以为tax strategy定义一个类型，以及一个基于strategy和product code的函数，用于计算：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TaxStrategy</span> </span>&#123;<span class="function"><span class="keyword">def</span> <span class="title">taxIt</span></span>(product: <span class="type">String</span>): <span class="type">Double</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ATaxStrategy</span> <span class="keyword">extends</span> <span class="title">TaxStrategy</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">taxIt</span></span>(product: <span class="type">String</span>): <span class="type">Double</span> = ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BTaxStrategy</span> <span class="keyword">extends</span> <span class="title">TaxStrategy</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">taxIt</span></span>(product: <span class="type">String</span>): <span class="type">Double</span> = ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">taxIt</span></span>: <span class="type">TaxStrategy</span> =&gt; <span class="type">String</span> =&gt; <span class="type">Double</span> = s =&gt; p =&gt; s.taxIt(p)</span><br></pre></td></tr></table></figure>
<p>现在我有两个<code>TaxStrategy</code>的实现，<code>ATaxStrategy</code>和<code>BTaxStrategy</code>。其中<code>taxIt</code>为封装的返回<code>String=&gt;Double</code>类型的方法。基于这些设置，你可以更容易地创建一个新函数实现注入不同的策略:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">taxIt_a</span></span>: <span class="type">String</span> =&gt; <span class="type">Double</span> = taxIt(<span class="keyword">new</span> <span class="type">ATaxStrategy</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">taxIt_b</span></span>: <span class="type">String</span> =&gt; <span class="type">Double</span> = taxIt(<span class="keyword">new</span> <span class="type">BTaxStrategy</span>)</span><br></pre></td></tr></table></figure>
<p>你有关OO设计模式的知识，在Scala中依然很有用，但是它的实现方式发生了改变。函数式编程带来了一些你之前没有遇到过的设计模式，而这些主要和迭代编程有关。</p>
<h2 id="5-2-3-建模纯函数式程序"><a class="header-anchor" href="#5-2-3-建模纯函数式程序">¶</a>5.2.3 建模纯函数式程序</h2>
<p>前面已经关注过实现纯函数的解决方案，但像编写socket或database这些，如何处理副作用？你不能避免这些问题，实际上任何企业开发的程序都可能有副作用。就此放弃吗？不！一个自欺的做法就是尽量将副作用推向更远一些。你可以创建一个不纯的层，如图，并尽量使应用剩余的部分作为纯函数。在5.5小节你会学习如何在包含必要副作用的代码中建立抽象。</p>
<p><img src="/img/scala-in-action/chapter5/modeling-purely.png" alt="Separating pure and side-effecting(impure)code.The side-effecting code should form a thin layer around the application"></p>
<p>为了说明它是如何工作的，你要创建一个简单的HTTP服务器，它用于处理从服务端开启的目录文件。你需要实现HTTP的GET命令。任何服务器一样，HTTP服务器充斥了各种副作用(side effects)，比如写入socket，从文件系统读取文件，等等。现在你对这个服务器设计目标是:</p>
<ul>
<li>代码分层，纯代码从副作用代码中分离。</li>
<li>返回基于HTTP GET请求的一个文件的上下文。</li>
<li>当请求missing时，返回一个404信息。</li>
</ul>
<p>这个问题的实质上是：解析请求，获取请求的文件的名称，定位资源，并返回响应。让我们用适当的类型和函数来表示。Http 请求是一个字节流客户端，建立纯模式(pure model)中不需要担心如何接收，我们只需要关心字节集合:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Request</span> </span>= <span class="type">Iterator</span>[<span class="type">Char</span>]</span><br></pre></td></tr></table></figure>
<p>相似地，响应也可以用一个字符串集合表示。为了简化，用<code>List[String]</code>:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Response</span> </span>= <span class="type">List</span>[<span class="type">String</span>]</span><br></pre></td></tr></table></figure>
<p>资源定位符类型应该能够检测文件是否存在、接收文件内容、并检测内容长度。第一个功能用于确定是否返回200还是404页码。下面是<code>ResourceLocator</code>:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">ResourceLocator</span> </span>= <span class="type">String</span> =&gt; <span class="type">Resource</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exists</span></span>: <span class="type">Boolean</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">contents</span></span>: <span class="type">List</span>[<span class="type">String</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">contentLength</span></span>: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ResourceLocator</code>作为一个函数类型，<code>String =&gt; Resource</code>传入资源名称并返回Resource。Resource表示定义中的Resource，他提供了将被用于HTTP响应的所有方法。这里关键的是，你创建了一个抽象层，且抽象层允许你通过 <em>值</em> 和 <em>纯函数</em> 设计你的应用。如下代码为完整的纯实现，并在GET成功时返回 HTTP 200，失败时返回 HTTP 404。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Pure</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Resource</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exists</span></span>: <span class="type">Boolean</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">contents</span></span>: <span class="type">List</span>[<span class="type">String</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">contentLength</span></span>: <span class="type">Int</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">ResourceLocator</span> </span>= <span class="type">String</span> =&gt; <span class="type">Resource</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Request</span> </span>= <span class="type">Iterator</span>[<span class="type">Char</span>]</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Response</span> </span>= <span class="type">List</span>[<span class="type">String</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse HTTP request for filename</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>(req:<span class="type">Request</span>)(<span class="keyword">implicit</span> locator:<span class="type">ResourceLocator</span>):<span class="type">Response</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> requestedResponse = req.takeWhile(x =&gt; x != &#x27;\n&#x27;).mkString.split(<span class="string">&quot; &quot;</span>)(<span class="number">1</span>).drop(<span class="number">1</span>)</span><br><span class="line">    (_200 orElse _404)(locator(requestedResponse))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">_200</span></span>:<span class="type">PartialFunction</span>[<span class="type">Resource</span>,<span class="type">Response</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> resource <span class="keyword">if</span> resource.exists =&gt; <span class="string">&quot;HTTP/1.1 200 OK&quot;</span> </span><br><span class="line">    :: (<span class="string">&quot;Date &quot;</span> + <span class="keyword">new</span> java.util.<span class="type">Date</span>) </span><br><span class="line">    :: <span class="string">&quot;Content-Type: text/html&quot;</span> </span><br><span class="line">    :: (<span class="string">&quot;Content-Length: &quot;</span> + resource.contentLength) </span><br><span class="line">    :: <span class="type">System</span>.getProperty(<span class="string">&quot;line.separator&quot;</span>) </span><br><span class="line">    :: resource.contents</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">_404</span></span>: <span class="type">PartialFunction</span>[<span class="type">Resource</span>, <span class="type">Response</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="type">List</span>(<span class="string">&quot;HTTP/1.1 404 Not Found&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，GET方法会接收请求的文件名，然后根据给定的定位器<code>locator</code>对文件进行定位。偏函数<code>_200</code>和<code>_400</code>被定义为表示成功和失败。如果文件存在则调用<code>_200</code>，否则调用<code>_400</code>。<br>
现在，服务点的核心部分已经实现了，你需要将它至于真实案例中。首先，你需要开启一个socket端口用于监听请求，你也需要异步处理每个线程，以使当处理旧的请求时监听一个新的请求。在Scala中，你可以找到NanoHttpServer.scala对此的完全实现。下面让我们来关注Resource和ResourceLocator的实现:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">Pure</span>._</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">IOResource</span>(<span class="params">name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">exists</span> </span>= <span class="keyword">new</span> <span class="type">File</span>(name).exists</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">contents</span> </span>= <span class="type">Source</span>.fromFile(name).getLines().toList</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">contentLength</span> </span>= <span class="type">Source</span>.fromFile(name).count(x =&gt; <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> ioResourceLocator: <span class="type">ResourceLocator</span> = name =&gt; <span class="type">IOResource</span>(name)</span><br></pre></td></tr></table></figure>
<p>其中<code>IOResource</code>使用<code>scala.io.Source</code>从本地文件系统读取文件，<code>ResourceLocator</code>函数接收文件名，并创建一个IOResource实例。唯一剩下的问题是对socket进行读写。可以看到你已经成功地将side effects 从纯函数代码中分离出来了。这是一项重要的技术，记住，当你设计你的应用时: <strong>push the side<br>
effects to the edge of the world</strong>。</p>
<h2 id="5-3-各种各样的函数"><a class="header-anchor" href="#5-3-各种各样的函数">¶</a>5.3 各种各样的函数</h2>
<p>函数式编程就是关于函数方面的，你能在Scala中创建各种形式的函数。函数在Scala中是第一类值(first-class values)。这意味着可以把函数看作如<code>Int</code>或<code>String</code>类型值一样。因此函数可以作为值创建、作为参数传递到其它函数、以及组合这些函数来创建新的函数。</p>
<h3 id="5-3-1-方法-vs-函数"><a class="header-anchor" href="#5-3-1-方法-vs-函数">¶</a>5.3.1 方法 vs. 函数</h3>
<p>通常被定义为一个类成员的函数。被称为方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UseResourece</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">use</span></span>(r:<span class="type">Resource</span>): <span class="type">Boolean</span> = &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>use</code>是类<code>UseResource</code>定义的一个方法。使用方法时有个缺点是，它容易依赖于封闭类定义的状态，该状态指没有显式传递其依赖的参数，因此要小心，它会使你远离纯函数。和函数不同，方法不会有任何类型的关联。Scala通过将函数转换为对象来实现函数式编程的OOP注入。<br>
例如，你可以赋值一个函数字面量(匿名函数)的值:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> succ = (x:<span class="type">Int</span>) =&gt; x + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这里succ函数的关联类型为<code>Int =&gt; Int</code>，它是如下定义的一种简写:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> succFunction = <span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>,<span class="type">Int</span>]&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x:<span class="type">Int</span>) : <span class="type">Int</span> = x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两个定义是等价的。函数在Scala中通过一个类型和对象表示，但是方法不是。方法仅仅关联它的封闭类。好消息是，Scala允许你使用一个称为Eta扩展的转换过程将方法转换为函数。你可以将任意存在的方法后加<code> _</code> 下划线来创建函数。如下面代码创建了一个函数:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> use_func:<span class="type">Resource</span> =&gt; <span class="type">Boolean</span> = (<span class="keyword">new</span> <span class="type">UseResource</span>).use _</span><br></pre></td></tr></table></figure>
<p>在Scala中，将方法转换为函数，并传递给另外一个函数的情况，在Scala中非常普遍。下一小节你将看到有关高阶函数的例子，以及它是如何帮助解决问题。</p>
<h3 id="5-3-2-高阶函数"><a class="header-anchor" href="#5-3-2-高阶函数">¶</a>5.3.2 高阶函数</h3>
<p>高阶函数就是，接收函数参数或以函数作为返回值的函数。在前面已经介绍了大量有关高阶函数的内容。尤其在Scala集合中每一个地方都用到高阶函数。例如，过滤掉List中的所有偶数，你会如下写:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val l = List(1, 2, 3, 5, 7, 10, 15)</span></span><br><span class="line">l: List[Int] = List(1, 2, 3, 5, 7, 10, 15)</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">l.filter(_ % 2 == 0)</span></span><br><span class="line">res0: List[Int] = List(2, 10)</span><br></pre></td></tr></table></figure>
<p>这里的 <code>% 2 == 0</code>是一个函数字面量。现在让我们看看如何用高阶函数来处理日积月累的问题。一个最常见的编程问题是资源管理。例如，在TCP连接上发送数据，你必须打开一个socket，发送数据，然后关闭socket。类似地，在一个文件系统中读取文件，你必须要打开文件，读数据，然后关闭文件的句柄。典型的处理资源的方法是将它们包装在try-finally块里面:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> r: <span class="type">Resource</span> = getResource()</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">useResourceToDoUsefulStuff(r)</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">r.dispose()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你获得了对资源操作的一个句柄，并在try-finally(有时包含catch)块里面操作。现在让我们看看如何将该资源管理部分分离出来,并通过高阶函数use实现:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use</span></span>[<span class="type">A</span>, <span class="type">B</span> &lt;: <span class="type">Resource</span> ](r: <span class="type">Resource</span>)(f: <span class="type">Resource</span> =&gt; <span class="type">A</span>): <span class="type">A</span> = &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">f(r)</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">r.dispose()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的use函数接入资源管理，以及函数参数<code>f</code>允许你使用资源而不用担心释放或处理的问题。现在socket的发送代码变为:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use(socketResource) &#123; r=&gt; sendData(r) &#125;</span><br></pre></td></tr></table></figure>
<p>资源管理的抽象实现移除了代码的重复并在资源暴露之后进行集中管理，而不会混乱try-finally块的代码。要实现这个抽象，你需要定义一个通用的类型Resource。在Scala中这是一个常见的模式 借贷模式Loan pattern<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup> (在面向对象中被称为模版方法模式)。<br>
下面一个例子会证明高阶函数对复杂设计编程的强大之处。下面常见的几点逻辑可能是你处理问题的步骤:</p>
<ul>
<li>创建或查找某些存在的实例。</li>
<li>处理某些包含副作用的操作。</li>
<li>在其他部分代码中使用实例。</li>
</ul>
<p>在你开始使用实例之前你会进行1、2步，问题是，包含副作用的代码有数据结构关联，并且它和步骤1、3混在一起使用。让我们看看下面的伪代码:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="type">Person</span>(firstName, lastName)</span><br><span class="line">x.setInfo(someInfo)</span><br><span class="line">println(<span class="string">&quot;log: new person is created&quot;</span>)</span><br><span class="line">mailer.mail(<span class="string">&quot;new person joined &quot;</span> + x)</span><br><span class="line">x.firstName</span><br></pre></td></tr></table></figure>
<p>在使用实例之前，你需要先完成1、2步，问题是在访问时可能没有调用者命名空间的上下文。例如，mailer的引用在前面的代码片段仅仅在调用者的上下文有效，而在Person实例内部无效。处理该问题的一个方法是使用高阶函数。这里定义一个函数<code>tap</code>，该函数接收一个实例和一个包含副作用的函数。该函数提供了副作用函数到实例的处理并返回实例。如下:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tap</span></span>[<span class="type">A</span>](a: <span class="type">A</span>)(sideEffect: <span class="type">A</span> =&gt; <span class="type">Unit</span>): <span class="type">A</span> = &#123;</span><br><span class="line">sideEffect(a)</span><br><span class="line">a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个<code>tap</code>函数，你的代码将获得某些结构:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="type">Person</span>(firstName, lastName)</span><br><span class="line">tap(x) &#123; p =&gt;</span><br><span class="line"><span class="keyword">import</span> p._</span><br><span class="line">setInfo(someInfo)</span><br><span class="line">println(<span class="string">&quot;log: new person is created&quot;</span>)</span><br><span class="line">mailer.mail(<span class="string">&quot;new person joined &quot;</span> + x)</span><br><span class="line">&#125;.firstName</span><br></pre></td></tr></table></figure>
<p>这正是你想要的，但你仍然可以通过隐式转化进行增强使用。因为它非常普遍，你需要使该函数对所有类型生效。下面给出它的完整实现例子。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Combinators</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">kestrel</span></span>[<span class="type">A</span>](a: <span class="type">A</span>) = <span class="keyword">new</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tap</span></span>(sideEffect: <span class="type">A</span> =&gt; <span class="type">Unit</span>): <span class="type">A</span> = &#123;</span><br><span class="line">      sideEffect(a)</span><br><span class="line">      a</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">firstName: <span class="type">String</span>, lastName: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Mailer</span>(<span class="params">mailAddress: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">mail</span></span>(body: <span class="type">String</span>) = &#123;</span><br><span class="line">    println(<span class="string">&quot;send mail here...&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> <span class="type">Combinators</span>._</span><br><span class="line"><span class="type">Person</span>(<span class="string">&quot;Nilanjan&quot;</span>, <span class="string">&quot;Raychaudhuri&quot;</span>).tap(p =&gt;&#123;</span><br><span class="line">  println(<span class="string">&quot;First name &quot;</span> + p.firstName)</span><br><span class="line">  <span class="type">Mailer</span>(<span class="string">&quot;some address&quot;</span>)</span><br><span class="line">&#125;).lastName</span><br></pre></td></tr></table></figure>
<p>比较先前的伪代码有所不同，现在代码更简洁和结构良好的，并且副作用不会泄漏。该模式设计最好的部分是可以让你不再依赖指令序列的组合。这同时也是一个常见的组合器(高阶函数)，在函数式编程中被称为Kestrel<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup> 。Kestrel是To Mock a Mockingbird书中定义的多个组合器中的一个。组合逻辑包含在本书范围，但是我更推荐To Mock a Mockingbird。我在这里强调，一旦你开始使用高阶函数，你将有机会提取可重用的代码，这在之前还认为是不可能的事情。让我们想一想，例如定义在Scala集合库中的<code>foldRight</code>和<code>foldLeft</code>提供的二元函数。高阶函数的应用程序让你编写不重复的代码(don’t-repeat-yourself DRY)并可以尽可能地使用。下一小节将讨论偏函数，以及它们如何在函数组合起到帮助。</p>
<h3 id="5-3-3-函数科里化"><a class="header-anchor" href="#5-3-3-函数科里化">¶</a>5.3.3 函数科里化</h3>
<p>函数科里化是一门技术，指的是将原来带多个参数的函数，转换为带一个参数的函数。如下面定义的接收两个参数的函数:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">trait TaxStrategy &#123; def taxIt(product: String): Double &#125;</span></span><br><span class="line">defined trait TaxStrategy</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val taxIt: (TaxStrategy, String) =&gt; Double = (s, p) =&gt; s.taxIt(p)</span></span><br><span class="line">taxIt: (TaxStrategy, String) =&gt; Double = &lt;function2&gt;</span><br></pre></td></tr></table></figure>
<p>函数<code>taxIt</code>接收<code>TaxStrategy</code>和<code>String</code>参数并返回<code>Double</code>。要将该函数科里化，你可以调用函数类型的<code>curried</code>方法:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">taxIt.curried</span></span><br><span class="line">res2: TaxStrategy =&gt; String =&gt; Double = &lt;function1&gt;</span><br></pre></td></tr></table></figure>
<p>它将<code>taxIt</code>函数转换为一个接收一个参数并返回另外一个接收第二个参数函数的函数:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">class TaxFree extends TaxStrategy &#123; override def taxIt(product:</span></span><br><span class="line">String) = 0.0 &#125;</span><br><span class="line">defined class TaxFree</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val taxFree = taxIt.curried(new TaxFree)</span></span><br><span class="line">taxFree: String =&gt; Double = &lt;function1&gt;</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">taxFree(<span class="string">&quot;someProduct&quot;</span>)</span></span><br><span class="line">res3: Double = 0.0</span><br></pre></td></tr></table></figure>
<p>使用函数科里化的好处是什么？它将一个普通的函数转换为一个特殊的。例如，将taxIt函数科里化后得到一个taxFree。这和OOP中的DI(Dependency injection，依赖注入)相似。这里我将<code>taxStrategy</code>作为依赖注入到科里化函数，并使用依赖创建一个新的函数。你也可以使用占位符<code>_</code>来转换为科里化函数。如下实现所示:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">def taxIt(s: TaxStrategy, product: String) = &#123; s.taxIt(product) &#125;</span></span><br><span class="line">taxIt: (s: TaxStrategy, product: String)Double</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val taxItF = taxIt _</span></span><br><span class="line">taxItF: (TaxStrategy, String) =&gt; Double = &lt;function2&gt;</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">taxItF.curried</span></span><br><span class="line">res4: TaxStrategy =&gt; String =&gt; Double = &lt;function1&gt;</span><br></pre></td></tr></table></figure>
<p>你也可以使用多参数集来定义科里化风格的方法:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">def taxIt(s: TaxStrategy)(product: String) = &#123; s.taxIt(product) &#125;</span></span><br><span class="line">taxIt: (s: TaxStrategy)(product: String)Double</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val taxFree = taxIt(new TaxFree) _</span></span><br><span class="line">taxFree: String =&gt; Double = &lt;function1&gt;</span><br></pre></td></tr></table></figure>
<p>你已经使用多参数集为高阶函数传递匿名函数，现在还学习了函数科里化的另一个内容:依赖注入。</p>
<h3 id="5-3-4-函数组合和偏函数"><a class="header-anchor" href="#5-3-4-函数组合和偏函数">¶</a>5.3.4 函数组合和偏函数</h3>
<p>一个偏函数是指，一个函数仅仅为输入值子串定义。它和一个纯函数的定义不同，纯函数为所有输入参数定义。如图5.3所示，一个偏函数<code>f: X-&gt;Y</code>，表示仅定义了<code>X=1</code>和<code>X=3</code>，不包含<code>X=2</code>。</p>
<p><img src="/img/scala-in-action/chapter5/partial-functions.png" alt="Function composition and partial functions"></p>
<p>在Scala中，偏函数通过<code>PartialFunction[-A,+B]</code>以及继承<code>scala.Function1</code>特质被定义。和所有函数类型一样，<code>PartialFunction</code>声明了apply方法以及一个额外的方法<code>def isDefinedAt(a:A):Boolean</code>。这个<code>isDefinedAt</code>方法决定了给定的偏函数是否为一个给定的参数定义。<br>
创建一个偏函数的最简单的方法是通过使用模式匹配定义一个匿名函数。如下代码例子定义了上图所述的偏函数:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intToChar</span></span>:<span class="type">PartialFunction</span>[<span class="type">Int</span>,<span class="type">Char</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> =&gt; &#x27;a&#x27;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span> =&gt; &#x27;c&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，Scala编译器会将前面的代码片段转换为如下内容:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">PartialFunction</span>[<span class="type">Int</span>,<span class="type">Char</span>]&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(i:<span class="type">Int</span>) = i <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> =&gt; &#x27;a&#x27;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span> =&gt; &#x27;c&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isDefinedAt</span></span>(i:<span class="type">Int</span>):<span class="type">Boolean</span> = i <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="literal">true</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span> =&gt; <span class="literal">true</span></span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特质<code>PartialFunction</code>提供了两个有趣的结合方法<code>orElse</code>和<code>andThen</code>。方法<code>orElse</code>可以将当前的偏函数和其他偏函数组合。它和if-else很相似，当当前的偏函数没有被定义时，则另外一个将被调用。你可以创建if-else if来匹配多项。另外一个<code>andThen</code>可以组合转换一个偏函数作用于一个由偏函数产生的结果。一个例子会证明函数组合的强大。</p>
<p><strong>注意：</strong><br>
<em><strong>理解偏函数的有用性是重要的。它让你编写更聪明的函数，记住单一职责原则，然后将它们组合在一起来创建一个完整的函数。小心性能的损耗。当组合偏函数时，要记住每个组合偏函数中的isDefinedAt可以被调用了多次。</strong></em></p>
<p>假设你要构建一个价格系统来为所有的病人提供发票。典型地，这个系统是复杂的，因此我将简化一些内容。价格由索票的类型和区域决定，此外，区域被分为state code或ZIP code。每个这些因素会影响最终发票的价格。同时，也不是所有的索票有具体的计价逻辑关联，因此你必须有一个捕获所有默认情况，以至于你可以总是能够计算得到发票的价钱。我可以肯定这听起来和你的业务逻辑很相似。让我们用偏函数来实现这个小问题。首先定义索票类型:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Claim</span> </span>&#123; <span class="keyword">val</span> claimId: <span class="type">Int</span> &#125;</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Full</span>(<span class="params">val claimId: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Claim</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Partial</span>(<span class="params">val claimId: <span class="type">Int</span>, percentage: <span class="type">Double</span></span>) <span class="keyword">extends</span> <span class="title">Claim</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>(<span class="params">val claimId: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Claim</span></span></span><br></pre></td></tr></table></figure>
<p>每一个claim包含一个claimId的唯一标识并有可选的某些属性关联claim。要索取发票，对方应该提供相应的索取信息，地址和标识。这里可以使用case classes实现:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Location</span>(<span class="params">stateCode: <span class="type">Option</span>[<span class="type">String</span>], zipCode: <span class="type">Option</span>[<span class="type">String</span>]</span>)</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Req</span>(<span class="params">productId: <span class="type">String</span>, location: <span class="type">Location</span>, claim: <span class="type">Claim</span></span>)</span></span><br></pre></td></tr></table></figure>
<p>处理Generic索赔，每个索赔的计价由具体的业务逻辑决定，以及所有的计价开始于一些基本的价格关联。为了决定最终的产品索赔价格，你需要提供请求信息和基本的价格。你可以捕获这个类型变量:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">PC</span> </span>= <span class="type">Tuple2</span>[<span class="type">Req</span>,<span class="type">Option</span>[<span class="type">Double</span>]]</span><br></pre></td></tr></table></figure>
<p>这个的<code>Option[Double]</code>表示产品价格的基础。下列代码则实现业务逻辑关联的每个<code>Full</code>和<code>Partial</code>索赔:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleFullClaim</span></span>: <span class="type">PartialFunction</span>[<span class="type">PC</span>, <span class="type">PC</span>] = &#123;</span><br><span class="line"><span class="keyword">case</span> (c<span class="meta">@Req</span>(id, l, <span class="type">Full</span>(claimId)), basePrice) =&gt;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handlePartialClaim</span></span>: <span class="type">PartialFunction</span>[<span class="type">PC</span>, <span class="type">PC</span>] = &#123;</span><br><span class="line"><span class="keyword">case</span> (c<span class="meta">@Req</span>(id, l, <span class="type">Partial</span>(claimId, percentage)), basePrice) =&gt;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似地，最终的价格受区域影响。区域基础的逻辑也可以用偏函数实现，如下:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleZipCode</span></span>: <span class="type">PartialFunction</span>[<span class="type">PC</span>, <span class="type">PC</span>] = &#123;</span><br><span class="line"><span class="keyword">case</span> (c<span class="meta">@Req</span>(id, <span class="type">Location</span>(_, <span class="type">Some</span>(zipCode)), _), price) =&gt;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleStateCode</span></span>: <span class="type">PartialFunction</span>[<span class="type">PC</span>, <span class="type">PC</span>] = &#123;</span><br><span class="line"><span class="keyword">case</span> (c<span class="meta">@Req</span>(id, <span class="type">Location</span>(<span class="type">Some</span>(stateCode), _), _), price) =&gt;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要为计价提供一个最终的解决方案，你可以组合这些偏函数来解决问题。根据商业规则，你应该首先决定索赔的价格基础，然后完善基于区域的价格计算。使用前面学习的<code>orElse</code>和<code>andThen</code>组合器，你可以非常容易的组合这些函数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">claimHandlers</span> </span>= handleFullClaim orElse handlePartialClaim</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">locationHandlers</span> </span>= handleZipCode orElse handleStateCode</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">priceCalculator</span></span>: <span class="type">PartialFunction</span>[<span class="type">PC</span>, <span class="type">PC</span>] =</span><br><span class="line">claimHandlers andThen locationHandlers</span><br></pre></td></tr></table></figure>
<p>上面的代码实现了你所描述的业务规则。计算索赔价格、然后完善区域的计算。当业务规则或新的索赔类型被添加到系统中，你可以容易地修改组合然后添加新的偏函数。例如，你还没有处理Generic索赔类型，你可以通过在claimHandlers中添加另外一个orElse块就很容易地将它添加到最终解决方案中。</p>
<p>偏函数可以被应用到更多你可能想到的场景中。例如，从一个函数或一个方法中抛出异常可以考虑偏函数。总之，在Scala中，使用了函数组合后的偏函数是强大的，在编写代码时要时刻记住。</p>
<h3 id="5-3-5-递归"><a class="header-anchor" href="#5-3-5-递归">¶</a>5.3.5 递归</h3>
<p>递归就是调用自身的函数。在函数式编程工具箱中递归是一个有用的工具。它可以让你将问题分解成子问题，子问题再分解成子问题。这样就可以将解决的子问题组合在一起并产生最终结果。可以认为递归是函数式编程语言的拼接。</p>
<p>递归的好处是可以让你创建不会变异的解决方案。在下面的小练习中，你需要计算出List中所有元素的和而不使用任何变异。你可以通过使用函数库得到许多方法来解决这个问题，但是让我们重新开始构建。这个问题的命令式解决方案如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">var <span class="built_in">sum</span> = 0</span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash"><span class="keyword">for</span>(e &lt;- List(1,2,3)) &#123; <span class="built_in">sum</span> += e &#125;</span></span><br></pre></td></tr></table></figure>
<p>你可以声明一个可变变量并对集合的元素结果进行迭代累加。因此递归的解决方案为:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(xs: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">Int</span> = xs <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="number">0</span></span><br><span class="line"><span class="keyword">case</span> x :: ys =&gt; x + sum(ys)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不同的是，基于递归的解决方案没有用到任何可变的临时变量，并将问题分解称为若干小块。在Scala中，典型的实现递归的方法就是使用模式匹配了。模式匹配可以实现将问题分解成为子问题，每个case就表示一个子问题。递归通常看起来容易，使用起来困难。下小节将介绍如何通过简单的步骤递归地思考问题。</p>
<h2 id="递归思想"><a class="header-anchor" href="#递归思想">¶</a>递归思想</h2>
<p>假设给你一个元素list，你需要将list中的重复元素去掉，例如，给你<code>List(0,1,2,3,2,1,0)</code>，那么输出的结果应该是<code>List(0,1,2,3)</code>。下面将一步一步来说明如何通过基于递归来解决<sup id="fnref:11"><a href="#fn:11" rel="footnote">11</a></sup> 。</p>
<p>第一步是确定类型。你需要根据输入参数和函数值返回类型类确定递归的类型。因此<code>removeDups</code>方法的类型应该是:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">removeDups: <span class="type">List</span>[<span class="type">Int</span>] =&gt; <span class="type">List</span>[<span class="type">Int</span>]</span><br></pre></td></tr></table></figure>
<p>下一步就是声明你需要处理的所有case，这里removeDups的case有:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">Nil</span> =&gt;</span><br><span class="line"><span class="keyword">case</span> x::ys <span class="keyword">if</span>(ys.contains(x)) =&gt;</span><br><span class="line"><span class="keyword">case</span> x::ys =&gt;</span><br></pre></td></tr></table></figure>
<p>第一个case为list空的情况，第二个为有重复的情况，第三个case表示没有重复的情况。<br>
下一步就是实现各个case案例，因为递归需要有两个必要条件，即迭代实现和终止条件，显然，第二个case案例为迭代实现，第三个case为终止条件。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="type">Nil</span></span><br><span class="line"><span class="keyword">case</span> x :: ys <span class="keyword">if</span>(ys.contains(x)) =&gt; removeDups(ys)</span><br><span class="line"><span class="keyword">case</span> x :: ys =&gt; removeDups(ys) :+ x</span><br></pre></td></tr></table></figure>
<p>加上类型声明后的完整代码为:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDups</span></span>[<span class="type">A</span>](xs: <span class="type">List</span>[<span class="type">A</span>]): <span class="type">List</span>[<span class="type">A</span>] = xs <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="type">Nil</span></span><br><span class="line"><span class="keyword">case</span> x :: ys <span class="keyword">if</span>(ys.contains(x)) =&gt; removeDups(ys)</span><br><span class="line"><span class="keyword">case</span> x :: ys =&gt; removeDups(ys) :+ x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>熟练使用递归的需要多进行练习，熟悉这些步骤后，便可自然地编写递归的解决方案了。</p>
<h3 id="5-4-1-尾递归"><a class="header-anchor" href="#5-4-1-尾递归">¶</a>5.4.1 尾递归</h3>
<p>在讨论尾递归之前，让我们解析一下头递归是如何工作的。<code>Head recursion</code>是大多数传统递归的实现方式，即方法中首先进行递归，然后接收返回值后再执行其他计算。<br>
尾递归(tail recursion)是先执行计算处理，然后再结果传递给递归操作处理。我会提供一个例子来证明你要如何编写递归函数，以及尾递归实现。<br>
一般地，当你调用一个函数时，一个实体被添加到了当前运行的线程堆栈中，堆栈的下限是它定义了大小，一旦超出了边界会抛出StackOverflowError异常。这就是为什么Java开发者更喜欢用迭代容器而不用递归。因为Scala运行在JVM上，Scala同样也有这样的问题。一个好消息是从Scala2.8.1开始，Scala通过尾部调用优化克服了这个限制。如下面是尾部调用优化的例子，代码片段将计算List的长度:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">length</span></span>[<span class="type">A</span>](xs: <span class="type">List</span>[<span class="type">A</span>]): <span class="type">Int</span> = xs <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="number">0</span></span><br><span class="line"><span class="keyword">case</span> x :: ys =&gt; <span class="number">1</span> + length(ys)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是个典型的头递归调用例子，当你执行的List较大时，你会获得一个StackOverflowError异常。现在用尾递归重写该方法:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">length2</span></span>[<span class="type">A</span>](xs: <span class="type">List</span>[<span class="type">A</span>]): <span class="type">Int</span> = &#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_length</span></span>(xs: <span class="type">List</span>[<span class="type">A</span>], currentLength: <span class="type">Int</span>): <span class="type">Int</span> = xs <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">Nil</span> =&gt; currentLength</span><br><span class="line"><span class="keyword">case</span> x :: ys =&gt; _length(ys, currentLength + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">_length(xs, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，计算操作不是在递归调用之后，计算处理发生在每一步，并向下一步传递。问题是，那个更好，在Scala中更推荐使用尾递归，因为Scala实现了尾递归函数的优化工作。Scala的尾部调用优化发生在编译时期，编译器会将一个尾递归转换为一个循环。这样就不需要添加额外的实体到堆栈中。但是Scala不能优化每一个尾递归 —— 只能优化函数不能优化类变量的方法。要知道Scala是否对你的尾递归进行了优化，最好的方法是在尾递归中使用@tailrec注解，因为当Scala编译器不能优化你的函数或者方法时，编译器会在此注解的方法中抛出一个异常。例如下面:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">length2</span></span>[<span class="type">A</span>](xs: <span class="type">List</span>[<span class="type">A</span>]): <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="meta">@tailrec</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_length</span></span>(xs: <span class="type">List</span>[<span class="type">A</span>], currentLength: <span class="type">Int</span>): <span class="type">Int</span> = xs <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Nil</span> =&gt; currentLength</span><br><span class="line">    <span class="keyword">case</span> x :: ys =&gt; _length(ys, currentLength + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  _length(xs, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现尾递归函数的常见方式是，使用上面如<code>_length</code>这样的本地函数来构建。本地函数访问允许你添加一个额外的参数来传递当前的结果到下一步操作。记住，实现一个调用优化的尾递归函数，你的递归操作总是在最后一步做处理。</p>
<h2 id="5-5-代数数据类型"><a class="header-anchor" href="#5-5-代数数据类型">¶</a>5.5 代数数据类型</h2>
<p>代数数据类型(Algebraic data type,ADT)是一种分类方法。通常地，一个数据类型是值的集合(例如Int类型作为所有整形值的标识)。你可以通过枚举集合中的所有值来定义一个代数类型，除非每个值都有它自己的数据结构。当然，你可以通过模式匹配来对类型进行解组。这听起来像是一个抽象的概念，我们来看看一个例子。不久你将学会ADT就是一种表示值集合的类型。ADTs可以表示一个有限的或无限的值集合。首先，让我们看看一个闭合ADT(有限值集合)的例子，以及探索为什么它们是有价值的。<br>
在Scala中，定义代数类型的最简单方式是使用case classes。如下例子代码定义了一个Account类型以及它的可能的值:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ADT</span> </span>&#123;</span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Account</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckingAccount</span>(<span class="params">accountId: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Account</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">SavingAccount</span>(<span class="params">accountId: <span class="type">String</span>, limit: <span class="type">Double</span></span>)</span></span><br><span class="line"><span class="keyword">extends</span> <span class="type">Account</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PremiumAccount</span>(<span class="params">corporateId: <span class="type">String</span>, accountHolder: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="keyword">extends</span> <span class="type">Account</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里定义了三个account类型，每个类型都带有自己的构造器以及接收不同的参数。同时也声明了Account特质是sealed的。这意味着不可以在trait外部创建一个新的Account类型，只能在Account的同一个文件中创建。你已经创建的一个有限的ADT，但是仍然不明白为什么case classes是ADTs实现的最好选择。原因是模式匹配。一旦你创建了ADTs，你在函数中使用。如果实现了case classes，ADTs将变得更容易处理，因为模式匹配工作在外部。下面代码片段printAccountDetails打印出每个account的详情:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ADT</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printAccountDetails</span></span>(account: <span class="type">Account</span>): <span class="type">Unit</span> = account <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">CheckingAccount</span>(accountId) =&gt;</span><br><span class="line">println(<span class="string">&quot;Account id &quot;</span> + accountId)</span><br><span class="line"><span class="keyword">case</span> <span class="type">SavingAccount</span>(accountId, limit) =&gt;</span><br><span class="line">println(<span class="string">&quot;Account id &quot;</span> + accountId + <span class="string">&quot; , &quot;</span> + limit)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>伴随着值和构造器，ADTs可以通过模式匹配进行解组，这样你可以在函数中更容易地使用他们。一个强大的概念:一旦你创建一个代数数据类型，你应该准备提供模式匹配来在函数中使用。</p>
<p>在函数<code>printAccountDetails</code>中，我有意地忽略<code>PremiumAccount</code>的代码，目的是让你在编译前面的代码时会发生什么。你将会看到如下警告:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[warn] missing combination PremiumAccount</span><br><span class="line">[warn] def printAccountDetails(account: Account): Unit = account match &#123;</span><br></pre></td></tr></table></figure>
<p>有限的代数数据类型的另外一个好处是，Scala编译器会检测函数是否对所有可能的case代数数据类型进行了处理，并提供提示。有两种方法让你避免这些告警:提供PremiumAccount的case实现，或者将Account类型为nonsealed不进行密封。但是移除sealed关键字的负面影响 —— 任何人都可以继承Account来创建一个新的类型。在这种情况，你应该如何编写像<code>printAccountDetails</code>一样处理所有account类型的实现？我喜欢有限的(闭合的)代数类型，并更推荐使用，因为我可以在Scala编译期走得更远。<br>
最大的一个好处是编写全函数(total functions)。全函数是指对一个代数数据类型的所有值进行处理，并总是产生返回的结果。这意味着在编译期函数可以处理所有输入。在本书，你将会使用ADT一段时间，而不仅仅是知道它。在Scala中两个最好的著名的例子是<code>scala.Either</code>和<code>scala.Option</code>。</p>
<h2 id="5-6-Why-does-functional-programming-matter"><a class="header-anchor" href="#5-6-Why-does-functional-programming-matter">¶</a>5.6 Why does functional programming matter?</h2>
<p>你已经探索了有关函数式编程的大量理论和例子。函数式编程，和命令式编程不同。这是另一种编程思想。为什么费心去学习这个新技术？这将给你带来什么？<br>
首先，学习一门新的编程范式是好事，因为可以让你成为更好的程序员。另外一个益处是函数式编程所带来的并发和多核编程。函数式编程可以让你编写更简单、更高效的并发程式。企业级软件开发者要处理复杂的业务问题和大规模的软件开发，并发是其重要的一部分。这或许不足以说服所有的开发者，但在剩余的小节将举例说明，为什么函数式编程这么重要，以及它如何帮助你处理复杂的问题。<br>
著名的计算机科学家John Hughes，在他的《Why Functional Programming Matters》一书中描述了函数式编程是如何帮助处理复杂问题。事实上，本小节的标题正是受该书的启发。<br>
以Unix的管道为例。Unix管道即指像管道一样当程序被链接成为一个管道(通过它们的输入输出流)  时。例如，下面命令接收来自通过URL的标识文件的大小:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s &quot;htttp://www.manning.com/raychaudhuri/&quot; | wc -c</span><br></pre></td></tr></table></figure>
<p>这里使用<code>curl</code>进程来获取来自服务器的数据，并通过<code>wc</code>进程来计算我从服务器获得的字节。符号 <code>|</code> 是Unix的管道命名，表示从一个进程得到的输出内容被作为管道输入到另外一个命令中执行。可以肯定，<code>curl</code>的作者和<code>w</code>c的作者不会想到某人会组合这两个进程来处理一个操作。事实上，你甚至可以使用任何多个Unix进程，组合这些进程来创建一个新的命令。这就是类Unix系统中最有用和最强大的思想。所有这些Unix程序背后的设计哲学是什么？所有Unix程序遵循下面两个简单的规则:</p>
<ol>
<li>Write programs that do one thing and do it well. 编写做一件事的程式并做好。</li>
<li>Write programs to work together. 编写程式来一起工作。</li>
</ol>
<p>从这简单的规则中你收获了什么？答案是 <strong>可组合性</strong> composability。Unix程序给我们展示了可组合性的强大。Unix程序就像乐高积木(LEGO blocks)。你可以以任意顺序组装它们，组合他们来创建新的程序，给这些新程序命名，在这些新程序之上再构建新的程序，…。那么这些内容如何映射到函数式编程上？一个Unix管道就像一个函数式编程语言一样。如果你把每个进程看作一个函数，一个Unix管道让你使用 <code>| </code>符号来组合这些函数；在Scala，它就是函数式组合。相似地，如下有一系列函数在你的Scala代码中:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">even</span></span>: <span class="type">Int</span> =&gt; <span class="type">Boolean</span> = _ % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">not</span></span>: <span class="type">Boolean</span> =&gt; <span class="type">Boolean</span> = !_</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>[<span class="type">A</span>](criteria: <span class="type">A</span> =&gt; <span class="type">Boolean</span>)(col: <span class="type">Traversable</span>[<span class="type">A</span>])=col.filter(criteria)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](f: <span class="type">A</span> =&gt; <span class="type">B</span>)(col: <span class="type">Traversable</span>[<span class="type">A</span>]) = col.map(f)</span><br></pre></td></tr></table></figure>
<p>这些函数就像Unix的进程一样，每个只处理一件事。函数<code>even</code>用于当给定的整数为偶数时返回true；<code>not</code>用于切换输入的Boolean参数；<code>filter</code>函数用于接收<code>Traversable</code>类型集合和<code>criteria</code>函数，并根据criteria函数的规则进行对Traversable参数的过滤；<code>map</code>函数则用于对给定的方法<code>f</code>对<code>Traversable</code>参数进行遍历。现在，假设你的问题是你需要查找给定集合中的所有偶数并对其乘2。用这些给定的函数，你可以组合这些函数多步处理，就可以容易地构建问题的解决方案。首先，构建一个filter来处理偶数，以及构建一个double函数:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evenFilter</span> </span>= filter(even) _</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span></span>: <span class="type">Int</span> =&gt; <span class="type">Int</span> = _ * <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这里的evenFilter我使用了函数科里化来创建一个指定的filter版本。为了将这两个函数组合在一起，Scala提供了一个<code>andThen</code>方法，可以作用于所有函数类型，但不包含参数的函数除外。这个<code>andThen</code>方法行为和Unix管道相似——结合了两种函数序列并创建一个函数。因为所有Scala函数被编译为一个<code>scala.  Function</code>特质，你可以使用这个组合方法来合并两个函数。为了过滤掉奇元素并乘2，创建下面函数:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doubleAllEven</span> </span>= evenFilter andThen map(double)</span><br></pre></td></tr></table></figure>
<p>evenFilter函数过滤后，map函数接着遍历结果内容并进行double处理。任务完成。但是如果你需要对所有的奇数乘2呢？你有现成的可以用了，只需要对其进行不一样的组合:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">odd</span></span>: <span class="type">Int</span> =&gt; <span class="type">Boolean</span> = not compose even</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oddFilter</span> </span>= filter(odd) _</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doubleAllOdd</span> </span>= oddFilter andThen map(double)</span><br></pre></td></tr></table></figure>
<p>这里提供给<code>odd</code>的组合方法是<code>compose</code>。<code>andThen</code>和<code>compose</code>的唯一不同的是执行顺序，<code>compose</code>是从右往左的。<code>odd</code>函数会找到所有的偶元素并去掉。<br>
手头上的这个例子是幼稚的、简单的。但是目标明确: 可组合性允许你从小小的功能块组合构成解决方案，而这些小块的功能正是你解决复杂问题的关键。反过来，当你设计一个大型的、复杂的问题解决方案时，你将问题分解成各个小问题，又甚至将小问题再分解成更小的问题，直到你到达可以更容易理解这个问题的点上。解决这些独立的小块，再收集在一起构建最终的大块，这是一个古老的技术。</p>
<p>这种分解、消化问题跨越软件开发的所有层面。函数式组合让你在你的应用中构建了数学微观世界。在这些数学微观世界中你能够明确问题，因为他们都是由纯函数创建，你可以轻易地使用函数组合构建。在微观世界中，你可以实现大部分应用程序的复杂性，以及函数组合给你一个清晰的、定义明确的方式来将问题分解成小块的函数，并之后对其组合。</p>
<p>在今天的企业，软件分离已经不足够。你需要尽可能分离得更快。这就是抽象(abstraction)和组合(composability)的益处所在。你作为一名开发者可以不通过改造和复制的实现组合小函数，从而节省时间。</p>
<p>纯函数世界的另外一个益处是调试。你不再需要担心事件序列问题的发生，因为纯函数没有副作用(side effect)。你也不用担心序列中哪个函数被执行了，因为函数的行为只通过输入参数集合驱动，即惰性执行。和命令式编程相比，函数式编程微观世界更容易找到瑕疵。为了使所有这些可能，遵循Unix的设计哲学:</p>
<ol>
<li>Write pure functions that do one thing and do it well.</li>
<li>Write functions that can compose with other functions.</li>
</ol>
<p>第一条规则是单一职责原则。第二条规则作为第一条的附加补充。所以在设计时，应当使函数功能尽量小、纯，这样组合就更容易。实现函数尽量小的一个方法就是使其只接收一个参数，如上面使其实现科里化(尽管事实上你会接收很多参数来实现组合多样性的事情)。</p>
<p>第二条规则是编写函数时，应当时刻记住使其实现科里化(currying)，或者使用偏函数。当声明函数时，要确保你的参数顺序从更具体的，到更通用的。它可以帮助其他人需要用到其他地方的场景，替换为通用的参数，或者最好使其只包含一个参数。</p>
<p>作为一门面向对象语言，函数式编程在处理核心和复杂部分时也使得你的应用更容易编写和维护。<br>
那么，函数的副作用(side effects)部分怎么办？难道它们在组合方面毫无希望？不，在下一小节，将展示如何围绕副作用部分内容创建抽象，以使得它们可以参与到组合(composition)中来。</p>
<h2 id="5-7-基于Monad的高级抽象构建"><a class="header-anchor" href="#5-7-基于Monad的高级抽象构建">¶</a>5.7 基于Monad的高级抽象构建</h2>
<p>如果你从OOP背景走来，你可能涉足过设计模式。本小节将讲解一个函数式编程设计模式，monads。monads的出现有点神秘。关于monads的通常误解来源于难理解，你需要有足够好的数学底子才能完全适应它们。的确，monads来源于范畴论<sup id="fnref:14"><a href="#fn:14" rel="footnote">14</a></sup> (category theory)的一个分支，范畴论正式化抽象数学概念为集合(collections)和态射(arrows)。但它提供了一个好的抽象层来帮助结构化你的代码。<br>
有许多实现monads的例子，并且每个用于解决一类具体的问题。事实上，你已经用过了monads，两个最常见的就是<code>List</code>和<code>Option</code>。List monad抽象了计算可能返回0，1，或者更多可能结果的情况。Option monad则抽象了计算可能不返回的情况(Some or None)。Monads通常被认为是一个先进的函数式编程概念。作为一名开发者，我强烈认为有必要将它引入到本书内容中，因为它有足够的使用益处。</p>
<ol>
<li>Monads可以让你组合你那些组合不好的函数，如有副作用的函数。</li>
<li>Monads可以让你不用函数式编程就可以模拟动作队列的计算顺序。</li>
</ol>
<p>使用函数式编程技术设计应用程序时，这两点是重要的、强大的，应当一起关注。我会先从第二点入手，因为它经常被用到，甚至即使你的数学微观世界中没有副作用。在最后这个小节，我会向你展示如何在函数式编程风格中组合包含副作用的函数。</p>
<h3 id="5-7-1-Managing-state-using-monads"><a class="header-anchor" href="#5-7-1-Managing-state-using-monads">¶</a>5.7.1 Managing state using monads</h3>
<p>当我介绍函数式编程时，我提及到不用关心函数或操作的顺序，因为函数都是纯的。让我们挑战另外一个零售价格的例子。这个应用需要计算一个产品的售价，计算按如下要求:</p>
<ul>
<li>找到产品的原价。</li>
<li>提供对原价特定代码的打折。</li>
<li>提供对上一步操作中，进行指定产品的折扣打折。</li>
<li>基于以上步骤后，提供扣税得到最终价格。</li>
</ul>
<p>这个模式在企业软件中比较普遍。你需要在序列中通过每个步骤操作的结果传递到下一个操作，怎么做？命令式的回答是使用一个可变变量在每个动作之间进行共享，这是一个差的想法，原因我已经在通篇全书中提及到。那试试将所有动作在一个函数中实现怎么样？是的，这个可以在一个大的函数中得到结果，因为每个步骤可能有10到20行代码。所以，一个最好的回答是将每个步骤以函数的形式实现，并以管道将当前动作的结果传递到下一个动作。下面列出这些实现。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PriceCalculatorWithoutMonad</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">Stubs</span>._</span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PriceState</span>(<span class="params">productId:<span class="type">String</span>,stateCode:<span class="type">String</span>,price:<span class="type">Double</span></span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findBasePrice</span></span>(productId:<span class="type">String</span>,stateCode:<span class="type">String</span>):<span class="type">PriceState</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> basePrice = findTheBasePrice(productId)</span><br><span class="line">    <span class="type">PriceState</span>(productId,stateCode,basePrice)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">applyStateSpecificDiscount</span></span>(ps:<span class="type">PriceState</span>):<span class="type">PriceState</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> discount = findStateSpecificDiscount(ps.productId,ps.stateCode)</span><br><span class="line">    ps.copy(price = ps.price - discount)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">applyProductSpecificDiscount</span></span>(ps:<span class="type">PriceState</span>):<span class="type">PriceState</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> discount = findProductSpecificDiscount(ps.productId)</span><br><span class="line">    ps.copy(price = ps.price - discount)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">applyTax</span></span>(ps:<span class="type">PriceState</span>):<span class="type">PriceState</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> tax = calculateTax(ps.productId,ps.price)</span><br><span class="line">    ps.copy(price = ps.price + tax)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">calculatePrice</span></span>(productId:<span class="type">String</span>,stateCode:<span class="type">String</span>):<span class="type">Double</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> a = findBasePrice(productId,stateCode)</span><br><span class="line">    <span class="keyword">val</span> b = applyStateSpecificDiscount(a)</span><br><span class="line">    <span class="keyword">val</span> c = applyProductSpecificDiscount(b)</span><br><span class="line">    <span class="keyword">val</span> d = applyTax(c)</span><br><span class="line">    d.price</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我将无关紧要的Stubs代码部分放置到另外一个文件中，下面是该文件的硬编码:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Stubs</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findTheBasePrice</span></span>(productId: <span class="type">String</span>) = <span class="number">10.0</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findStateSpecificDiscount</span></span>(productId: <span class="type">String</span>, stateCode: <span class="type">String</span>) = <span class="number">0.5</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findProductSpecificDiscount</span></span>(productId: <span class="type">String</span>) = <span class="number">0.5</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">calculateTax</span></span>(productId: <span class="type">String</span>, price: <span class="type">Double</span>) = <span class="number">5.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，最有趣的部分是<code>calculatePrice</code>方法，他调用了每一个独立函数，每一个方法的结果传递到下一个方法中，形成一个队列。命名变量<code>a,b,c</code>不是一个好的想法，但是它很好的展示了<code>PriceState</code>实例的传递。这种解决方法的实现使用了函数式编程风格，但是每个独立函数的API则显得丑陋。为了返回唯一个price价格，方法<code>applyStateSpecificDiscount</code>，<code>applyProductSpecificDiscount</code>和<code>applyTax</code>就必须返回PriceState的实例。每个方法的最后一行方法apply显示了问题。<br>
另外一个问题是方法<code>calculatePrice</code>。它容易在处理PriceState时出错，在更复杂的问题中，这种方式变得十分混乱。当然一个高阶的抽象或许对这种状态管理会有所帮助。这就出现了<code>State monad</code>。之所以被称为<code>State monad</code>是因为它在多个操作状态改变时实现了透明。在这个例子中，你将实现一个<code>State monad</code>，这样你就不需要在多个方法调用PriceState时对其进行管理。但是你需要有足够的通用实现以使得它可以在其它相似问题的地方被使用。<br>
在Scalaz库中实现了大量的这些monads，考虑到直接使用不会达到学习的效果。让我们自己实现一个State monad。<br>
在实现State monad之前，先将原来的Stubs中的方法改一下，让API看起来更清晰一些:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Stubs</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findBasePrice</span></span>(ps: <span class="type">PriceState</span>): <span class="type">Double</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">applyStateSpecificDiscount</span></span>(ps: <span class="type">PriceState</span>): <span class="type">Double</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">applyProductSpecificDiscount</span></span>(ps: <span class="type">PriceState</span>): <span class="type">Double</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">applyTax</span></span>(ps: <span class="type">PriceState</span>): <span class="type">Double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有这些方法将接收一个PriceState实例参数，并返回计算结果。你的工作就是实现一个State monad来序列这些方法，并计算出最终价格。<br>
这个State monad封装一个转换函数，将初始状态转换为一个(newState,value)对。这在Scala中很容易表示:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">State</span>[<span class="type">S</span>, +<span class="type">A</span>] </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(s: <span class="type">S</span>): (<span class="type">S</span>, <span class="type">A</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法apply表示函数转换，为了实现这个特质，你需要提供一个方法，用于接收S并返回(S,A)。你可以很容易就实现</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">state</span></span>[<span class="type">S</span>, <span class="type">A</span>](f: <span class="type">S</span> =&gt; (<span class="type">S</span>, <span class="type">A</span>)) = <span class="keyword">new</span> <span class="type">State</span>[<span class="type">S</span>, <span class="type">A</span>] &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(s: <span class="type">S</span>) = f(s)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个对象将用在你需要使用State monad的地方。在这里，添加两个方法使生命周期更易于管理:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">state</span></span>[<span class="type">S</span>, <span class="type">A</span>](f: <span class="type">S</span> =&gt; (<span class="type">S</span>, <span class="type">A</span>)) = <span class="keyword">new</span> <span class="type">State</span>[<span class="type">S</span>, <span class="type">A</span>] &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(s: <span class="type">S</span>) = f(s)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>[<span class="type">S</span>]: <span class="type">State</span>[<span class="type">S</span>, <span class="type">S</span>] = state[<span class="type">S</span>, <span class="type">S</span>](s =&gt; (s, s))</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">modify</span></span>[<span class="type">S</span>](f: <span class="type">S</span> =&gt; <span class="type">S</span>) =init[<span class="type">S</span>] flatMap (s =&gt; state(_ =&gt; (f(s), ())))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法<code>init</code>为State monads的创建提供了转换函数<code>(s =&gt; (S,S))</code>骨骼。可以把它认为是State monad的默认构造器。方法<code>modify</code>则让你在monad的内容对当前的状态进行修改，它用一个新的状态修改并用Unit返回给定函数和值的<code>(S,A)</code>对。你可以使用这个方法来实现你的解决方案。<br>
为了把State特质看作是第一类的monad，你要实现<code>map</code>方法和<code>flatMap</code>方法。记住<code>map</code>和<code>flatMap</code>是monad接口至关重要的部分，没有它们，Scala中任何函数都不可能成为monad。<br>
实现map和flatMap方法是容易的，因为你知道如何创建一个State monad的实例。下面为表示State moand的特质</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StateMonad</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">State</span>._</span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">State</span>[<span class="type">S</span>, +<span class="type">A</span>] </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(s: <span class="type">S</span>): (<span class="type">S</span>, <span class="type">A</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">State</span>[<span class="type">S</span>, <span class="type">B</span>] = state(f = apply(_) <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> (s, q) =&gt; (s, f(q))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](f: <span class="type">A</span> =&gt; <span class="type">State</span>[<span class="type">S</span>, <span class="type">B</span>]): <span class="type">State</span>[<span class="type">S</span>, <span class="type">B</span>] =</span><br><span class="line">      state(apply(_) <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> (s, q) =&gt; f(q)(s)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">state</span></span>[<span class="type">S</span>, <span class="type">A</span>](f: <span class="type">S</span> =&gt; (<span class="type">S</span>, <span class="type">A</span>)) = <span class="keyword">new</span> <span class="type">State</span>[<span class="type">S</span>, <span class="type">A</span>] &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(s: <span class="type">S</span>) = f(s)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span></span>[<span class="type">S</span>]: <span class="type">State</span>[<span class="type">S</span>, <span class="type">S</span>] = state[<span class="type">S</span>, <span class="type">S</span>](s =&gt; (s, s))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">modify</span></span>[<span class="type">S</span>](f: <span class="type">S</span> =&gt; <span class="type">S</span>) =</span><br><span class="line">      init[<span class="type">S</span>] flatMap (s =&gt; state(_ =&gt; (f(s), ())))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法map用于在State monad内部实现值的转换。另一方面，flatMap则用于从一个状态，到另一个状态的转换。如果所有这些感到有些抽象，不用担心，当你使用这些结构时便会觉得很有意义。<br>
不久你将学习到State monad通过方法调用来处理线程状态的变化，这样你就不用担心线程调用的问题。但是具体的业务规则中你仍然要在序列中调用individual pricing方法。序列一系列方法调用的最好地方是一个for-comprehension。这保证了每步特定的进入都会执行；同时也可以将每个需要运行的内容独立起来。在这个案例中，会像如下代码所示:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">PriceCalculatorWithMonad</span>._</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modifyPriceState</span></span>(f: <span class="type">PriceState</span> =&gt; <span class="type">Double</span>) = modify[<span class="type">PriceState</span>](s =&gt; s.copy(price = f(s)))</span><br><span class="line"><span class="keyword">val</span> stateMonad = <span class="keyword">for</span> &#123;</span><br><span class="line">  _ &lt;- modifyPriceState(findBasePrice)</span><br><span class="line">  _ &lt;- modifyPriceState(applyStateSpecificDiscount)</span><br><span class="line">  _ &lt;- modifyPriceState(applyProductSpecificDiscount)</span><br><span class="line">  _ &lt;- modifyPriceState(applyTax)</span><br><span class="line">&#125; <span class="keyword">yield</span> ()</span><br></pre></td></tr></table></figure>
<p>许多事情都在这段小代码中开始，让我们从头到尾看看。方法modifyPriceState是一段极好的方法，它接收一个有关pricing的方法，并将该方法搬运入箱成为一个新的方法，这样你就可以调用对象State内部的方法modify。<br>
每个modifyPriceState方法创建一个State monad实例。当你在for-comprehension内部调用时，你获得一个State monad返回，该返回封装了方法被调用的序列以及知道如何创建一个最终的价格状态。注意现在stateMonad持有一个转换函数，它是一个被定义在for-comprehension中的所有计价方法的组合函数。这种方式的好处是，在应用编码中线程的状态总是不可见的，它隐藏在monad内部。通过State monad实例，当你的程式执行至此时，可以通过初始状态得到最终计算的价格:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> initialPriceState = <span class="type">PriceState</span>(productId, stateCode, <span class="number">0.0</span>)</span><br><span class="line"><span class="keyword">val</span> finalPriceState = stateMonad.apply(initialPriceState)._1</span><br><span class="line"><span class="keyword">val</span> finalPrice = finalPriceState.price</span><br></pre></td></tr></table></figure>
<p>它是如何工作的？秘密在map和flatMap。for-comprehension不是别的而是<code>map/flatMap</code>的语法糖。你已经在List和Option用过了for-comprehension表达式 —— 因为它们都实现了map和flatMap。第四章可以获得更多详细的内容，而在本章我将仔细剖析上面的for-comprehension，并向你展示它是如何转换成为map/flatMap组合。<br>
注意上面代码for-comprenhension中左边的下划线<code>_</code>。它表示键值对中的值，这个例子中你不需要关心它们。我将会用另外一个例子来说明这个key-value中的value将被更高效地使用——下面的代码列表展示了完整的使用StateMonad重新实现的零售计价。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PriceCalculatorWithMonad</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> <span class="type">Stubs</span>._</span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PriceState</span>(<span class="params">productId: <span class="type">String</span>, stateCode: <span class="type">String</span>, price: <span class="type">Double</span></span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findBasePrice</span></span>(ps: <span class="type">PriceState</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">    findTheBasePrice(ps.productId)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">applyStateSpecificDiscount</span></span>(ps: <span class="type">PriceState</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">    findStateSpecificDiscount(ps.productId, ps.stateCode)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">applyProductSpecificDiscount</span></span>(ps: <span class="type">PriceState</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">    ps.price - findProductSpecificDiscount(ps.productId)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">applyTax</span></span>(ps: <span class="type">PriceState</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">    ps.price + calculateTax(ps.productId, ps.price)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">calculatePrice</span></span>(productId: <span class="type">String</span>, stateCode: <span class="type">String</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">modifyPriceState</span></span>(f: <span class="type">PriceState</span> =&gt; <span class="type">Double</span>) = modify[<span class="type">PriceState</span>](s =&gt; s.copy(price = f(s)))</span><br><span class="line">    <span class="keyword">val</span> stateMonad = <span class="keyword">for</span> &#123;</span><br><span class="line">      _ &lt;- modifyPriceState(findBasePrice)</span><br><span class="line">      _ &lt;- modifyPriceState(applyStateSpecificDiscount)</span><br><span class="line">      _ &lt;- modifyPriceState(applyProductSpecificDiscount)</span><br><span class="line">      _ &lt;- modifyPriceState(applyTax)</span><br><span class="line">    &#125; <span class="keyword">yield</span> ()</span><br><span class="line">    <span class="keyword">val</span> initialPriceState = <span class="type">PriceState</span>(productId, stateCode, <span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">val</span> finalPriceState = stateMonad.apply(initialPriceState)._1</span><br><span class="line">    <span class="keyword">val</span> finalPrice = finalPriceState.price</span><br><span class="line">    finalPrice</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StateMonad是一个通用的抽象层，它允许你为需要共享状态的动作序列构建计算。<br>
你可以看到状态键-值对 和 值在State monad中的实现具有一定的相关性。尽管你不总是需要它们，当你的计算需要依赖当前的monad状态时，你可以用状态的值来处理你的计算。假设你需要为零售计价实现日志，以及为每一步的结果输出日志。<br>
为了实现logging，你需要暴露State对象超过一个的方法，该方法称为<code>gets</code>。这个方法让你方法当前的state，因此你可以创建log message，并作为value存储到monad的内部。下面为它的实现:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gets</span></span>[<span class="type">S</span>,<span class="type">A</span>](f: <span class="type">S</span> =&gt; <span class="type">A</span>): <span class="type">State</span>[<span class="type">S</span>, <span class="type">A</span>] =</span><br><span class="line">init[<span class="type">S</span>] flatMap (s =&gt; state(_ =&gt; (s, f(s))))</span><br></pre></td></tr></table></figure>
<p>和方法modify相似，但允许你提供一个接收<code>S</code>和放回<code>A</code>的函数。方法gets同时也使用value和返回给定的函数 <code>f</code> 创建了一个新的State monad实例。现在你可以序列这些计价步骤操作，并记录。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculatePriceWithLog</span></span>(productId: <span class="type">String</span>, stateCode: <span class="type">String</span>): <span class="type">Double</span> = &#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modifyPriceStateWithLog</span></span>(f: <span class="type">PriceState</span> =&gt; <span class="type">Double</span>) = modify[<span class="type">PriceState</span>](s =&gt; s.copy(price = f(s)))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logStep</span></span>(f: <span class="type">PriceState</span> =&gt; <span class="type">String</span>) = gets(f)</span><br><span class="line"><span class="keyword">val</span> stateMonad = <span class="keyword">for</span> &#123;</span><br><span class="line">  _ &lt;- modifyPriceStateWithLog(findBasePrice)</span><br><span class="line">  a &lt;- logStep(s =&gt; <span class="string">&quot;Base Price &quot;</span> + s)</span><br><span class="line">  _ &lt;- modifyPriceStateWithLog(applyStateSpecificDiscount)</span><br><span class="line">  b &lt;- logStep(s =&gt; <span class="string">&quot;After state discount &quot;</span> + s)</span><br><span class="line">  _ &lt;- modifyPriceStateWithLog(applyProductSpecificDiscount)</span><br><span class="line">  c &lt;- logStep(s =&gt; <span class="string">&quot;After product discount &quot;</span> + s)</span><br><span class="line">  _ &lt;- modifyPriceStateWithLog(applyTax)</span><br><span class="line">  d &lt;- logStep(s =&gt; <span class="string">&quot;After tax &quot;</span> + s)</span><br><span class="line">&#125; <span class="keyword">yield</span> a :: b :: c :: d :: <span class="type">Nil</span></span><br><span class="line"><span class="keyword">val</span> (finalPriceState, log) = stateMonad.apply(<span class="type">PriceState</span>(productId,</span><br><span class="line">  stateCode, <span class="number">0.0</span>))</span><br><span class="line">finalPriceState.price</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先你创建了一个logStep方法来封装gets方法，然后你在每个状态被修改后序列这个logStep，这样你就可以跟踪状态的改变。最后你将每个步骤的信息组合成为一个List。可以看到使用State mond来添加依赖于状态改变的行为是如此的简单。</p>
<h3 id="5-7-2-Building-blocks-for-monads"><a class="header-anchor" href="#5-7-2-Building-blocks-for-monads">¶</a>5.7.2 Building blocks for monads</h3>
<p>在Scala中，Monads的构建块即是<code>flatMap</code> 和 <code>map</code>的组合。如果你把一个Monad看作是一个容器，那么flatMap 和 map 就是唯一两个可能的存储当前值的内部容器。flatMap 和 map 都接收一个函数参数，并通过提供函数组合创建一个新的monad实例，两者最终得到另外一个monad实例。为了从monad中接收值，你需要用不同的技术。在我们的例子中，我使用了apply方法来定义StateMonad。在有些类型monad中，你可以使用模式匹配。例如，<code>scala.Option</code>是一个monad，你可以使用模式匹配来接收来自Some实例的值。<br>
现在，最重要的部分是要理解为什么需要flatMap 和 map 方法。两者看起来有相似的行为。为了阐明为什么，我们试试将calculatePrice改为不用for-comprehension实现:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculatePrice2</span></span>(productId: <span class="type">String</span>, stateCode: <span class="type">String</span>): <span class="type">Double</span> = &#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modifyPriceState</span></span>(f: <span class="type">PriceState</span> =&gt; <span class="type">Double</span>) =</span><br><span class="line">  modify[<span class="type">PriceState</span>](s =&gt; s.copy(price = f(s)))</span><br><span class="line"><span class="keyword">val</span> stateMonad = modifyPriceState(findBasePrice) flatMap &#123; a =&gt;</span><br><span class="line">  modifyPriceState(applyStateSpecificDiscount) flatMap &#123; b =&gt;</span><br><span class="line">    modifyPriceState(applyProductSpecificDiscount) flatMap &#123; c =&gt;</span><br><span class="line">      modifyPriceState(applyTax) map &#123; d =&gt; () &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> initialPriceState = <span class="type">PriceState</span>(productId, stateCode, <span class="number">0.0</span>)</span><br><span class="line"><span class="keyword">val</span> finalPriceState = stateMonad.apply(initialPriceState)._1</span><br><span class="line"><span class="keyword">val</span> finalPrice = finalPriceState.price</span><br><span class="line">finalPrice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的价格状态使用flatMap来进行链接，而不是for-comprehension语法糖。你可以看到，我这里同时使用了flatMap 和 map。这实际上就是Scala对for-comprehension表达式如何转换的一种替代。我们现在比较一下map 和 flatMap的方法签名:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">State</span>[<span class="type">S</span>, <span class="type">B</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](f: <span class="type">A</span> =&gt; <span class="type">State</span>[<span class="type">S</span>, <span class="type">B</span>]): <span class="type">State</span>[<span class="type">S</span>, <span class="type">B</span>]</span><br></pre></td></tr></table></figure>
<p>方法map让你创建一个StateMonad实例；方法flatMap让你遍历这个嵌套状态。没有flatMap你最终会得到一个嵌套的State monad，因为每个modifyPriceState的调用会返回一个State monad的实例。可以改变上面的代码，用map 来代替 flatMap 看看效果的不同。</p>
<p>这里有一些创建一个monad的诀窍:</p>
<ul>
<li>为接口同时定义flatMap 和 map。</li>
<li>设计一个获取monad值的方式(模式匹配或者apply)。</li>
<li>符合<a target="_blank" rel="noopener" href="https://wiki.haskell.org/Monad_laws">一元法则,monadic laws</a>。</li>
</ul>
<p>Monads几乎无处不在——可能用了也不知道。一个最常的monad你未有见过的 I/O monad。它可以让你组合带有副作用的函数。可以在Scalaz库中一探它的实现。现在你知道如何创建monads，以及在外面认出monad。Moands是一个很好的提升抽象层次的方式。你可以发明monads。</p>
<h2 id="5-8-Summary"><a class="header-anchor" href="#5-8-Summary">¶</a>5.8 Summary</h2>
<p>本章介绍了Scala的函数式编程。尽管你已经在前面的章节中使用函数式编程，这章则着重解析函数式编程的详细内容。可以从本书开始到本章看到函数式编程以及一些纯函数编程的例子。<br>
企业开发者很难会不担心副作用的发生，因为任何业务编程之外都有或多或少讨论到外界接触。你已经学会了如何在代码中构建纯函数的模块，并尽可能将副作用放置离核心代码更远的地方，这将有助于你构建充满自信的、正确的应用程式。以及更少时间的debugging调试、必要的孤立可变状态避免更多的错误发生。<br>
函数式编程最至关重要的得益之处是组合，即你通过提供基础属性构建大的编程。通过Scala的强大的抽象类型，最终你可以构建一个代码复用的组件。<br>
同时，我们还学习了函数式编程的一种设计模式——Monad。它可以让你的组合直面副作用。最初它们看起来是复杂的，当你使用时，你会发现在很多地方都用到了这种设计模式，包括标准Scala库。使用Monads，你仅仅接触了函数式编程设计模式、概念的表面。我强烈推荐更进一步探索函数式编程的概念。最好的一个开始是阅读《Scala in Depth》。<br>
函数式编程并不仅局限于Scala。你可以在你学过的任何编程语言中使用。时刻记住函数式编程的关键是创建一个引用透明的表达式，如果在你的语言中可以实现，那么go for it。函数式编程也应该能够组合。简言之，一门语言比其他编程语言更加函数式在于它比其它编程语言更容易组合。<br>
第六章将会探索Java代码基于集成Scala的更多优势。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a target="_blank" rel="noopener" href="http://www.defmacro.org/ramblings/fp.html">Slava Akhmechet, “Functional Programming for the Rest of Us,” June 19, 2006,</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a target="_blank" rel="noopener" href="http://mng.bz/tWaV">Lloyd Anderson, “Lambda Calculus</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:5"><a target="_blank" rel="noopener" href="http://mng.bz/b27e">Michael Feathers, “The Successor Value Pattern, March 22, 2009</a><a href="#fnref:5" rev="footnote"> ↩</a></li><li id="fn:6"><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Strategy_pattern">“Strategy pattern,” February 2011</a><a href="#fnref:6" rev="footnote"> ↩</a></li><li id="fn:7"><a target="_blank" rel="noopener" href="https://wiki.scala-lang.org/display/SYGN/Loan">Kevin Wright (added), “Loan pattern,” last edited May 25, 2011</a><a href="#fnref:7" rev="footnote"> ↩</a></li><li id="fn:8"><a target="_blank" rel="noopener" href="http://mng.bz/WKns">Reg Braithwaite, “Kestrels”</a><a href="#fnref:8" rev="footnote"> ↩</a></li><li id="fn:11"><a target="_blank" rel="noopener" href="http://www.cs.nott.ac.uk/~gmh/book.html">Graham Hutton, Programming in Haskell (Cambridge University Press, 2007)</a>.<a href="#fnref:11" rev="footnote"> ↩</a></li><li id="fn:14"><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Category_theory">“Category Theory”</a><a href="#fnref:14" rev="footnote"> ↩</a></li></ol></div></div></div></article><nav class="article-nav"><div class="article-nav-prev">🔙<a href="/2016/10/27/scala/06-functional-webapp/">第六章：构建函数式风格的Web应用</a></div><div class="article-nav-next">🔜<a href="/2016/10/27/scala/04-fp-structure/">第四章：函数数据结构</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2016/10/27/scala/05-fp-practise/';
var disqus_title = '第五章：函数式编程';
var disqus_url = 'https://galudisu.info/2016/10/27/scala/05-fp-practise/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>