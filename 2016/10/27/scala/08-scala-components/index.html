<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>第八章：构建可伸缩的、可扩展的组件</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">第八章：构建可伸缩的、可扩展的组件</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2016-10-27</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/scala/">scala</a></p><p class="meta-item meta-category"><span class="meta-item-title"></span><i class="icon-bookmark"> </i><a class="category-link" href="/categories/learning/">learning</a></p></div><div class="article-content"><h4 id="主要内容："><a class="header-anchor" href="#主要内容：">¶</a>主要内容：</h4>
<ol>
<li>构建组件。</li>
<li>丰富的类型系统。</li>
<li>即时-多态(Ad hoc polymorphism)。</li>
<li>解决表述问题。</li>
</ol>
<p>我们有一段时间没有把专注力放在Scala的类型系统(type system)上。The type system is a tractable syntactic method for proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>.(类型系统是一个易于处理的语法方法，它通过计算得出的分类词汇，为该方法提供正确的缺省的编程处理)。</p>
<p>本章学习类型系统的要点是 理解其背后理论。这对学习类型系统基础很有帮助，本章不会过多在练习上关于理论内容。这里，将探索Scala提供给我们的各种各样的类型，并带有例子让我们更好理解。为什么类型系统如此重要？它提供了一下几点特性：</p>
<ul>
<li>Error detection：就像编译器编译单元测试，可以探测普通类型和其它编程错误。</li>
<li>Abstractions：本章重点。你将学习类型系统是如何提供抽象给构建组件。</li>
<li>Documentation：函数或方法签名，告诉你它是做什么的。</li>
<li>Efficiency：类型系统帮助编译器生成优化的二进制码。</li>
</ul>
<p>本章的主要目的是告诉你，Scala类型系统是如何构建重用组件的。这里的 <strong>组件(component)</strong> 是一个 涵盖性术语(umbrella term)，如重用的库、类、模组、框架、web service。</p>
<p>构建重用的组件并不简单。通过可装配组件(assembling components)来构建软件的目标仍然是梦一般的存在，甚至不能扩展成为我们想要的。构建可重用组件的挑战是，还要它所引用的上下文环境。典型地，修改组件以适应当前的需求，最终带来的是一个组件的多个版本。这导致了维护上的问题。在本章的第一小节，你会学习使用Scala类型系统来构建简单的、可重用的组件。</p>
<span id="more"></span>
<p>接下来你将学习Scala给我们提供的不同类型的Scala类型，以使得你的代码更有表现力和可重用。</p>
<p>你也将学习一个新的 polymorphism类型，多态(polymorphism)使用类型类(type classes)，允许你创建的抽象更容易扩展和缩放(scale)——一个强大的构造器来解决你日复一日的编程问题。</p>
<p>我们要清楚一个好的类型系统，并不仅仅为你服务，这点很重要。甚至，它可以提供足够的灵活性，以实现尽可能的创造性。带着你的咖啡坐下了，不用担心路途的颠簸。我相信，学完这章内容，将会有更大的收获。</p>
<h3 id="8-1〖Building-your-first-component-in-Scala〗P225"><a class="header-anchor" href="#8-1〖Building-your-first-component-in-Scala〗P225">¶</a>8~1〖Building your first component in Scala〗P225</h3>
<p>如我所说，构建一个可伸缩的、可重用的组件是困难的。可伸缩的(scalable)意指小的或大的组件——特别是当你尝试使用一个类型安全的、面向对象的语言来构建时。Table 8.1展示了由Scala提供的三种抽象技术。</p>
<p>曾在第三章介绍过混入组件(mixin)。Scala特质允许你构建小的组件，并将它们组合成为大的组件。在开始构建组件之前，让我们探索一下抽象类型成员和自类型(self type)，因为它们是重要的构建模块。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Technique</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>Modular mixin composition</code></td>
<td style="text-align:left">Scala特性中提供了一个机制——组合特质在设计可重用组件时不会带来继承上的问题。你按照约定使用它，并可以继承多个，或者你可以使用具体的方法来实现。</td>
</tr>
<tr>
<td style="text-align:left"><code>Abstract type members</code></td>
<td style="text-align:left">Scala中可以为类、特质、子类声明抽象类型成员， 类似于抽象方法和字段。</td>
</tr>
<tr>
<td style="text-align:left"><code>Self type</code></td>
<td style="text-align:left">混入类(mixin)不依赖于它所混入的类的任何方法或字段。但有时它所混入类的字段或方法是非常有用的。这种特性在Scala中被称之为 自类型(self type)。</td>
</tr>
</tbody>
</table>
<h3 id="811〖Abstract-type-members〗P226"><a class="header-anchor" href="#811〖Abstract-type-members〗P226">¶</a>8<sub>1</sub>1〖Abstract type members〗P226</h3>
<p>Scala将抽象的思想超越了方法和字段的层面。你也可以在一个类或特质内声明一个抽象类型成员。抽象类型，就是在声明的时候，类型还不确切、不知道的。和具体的类型不同，抽象类型成员由具体的封闭类指定。下面例子在中，在特质Calculator内部声明了一个抽象类型成员：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Calculator</span> </span>&#123; <span class="class"><span class="keyword">type</span> <span class="title">S</span> &#125;</span></span><br></pre></td></tr></table></figure>
<p>任何具体的类混入这个特质，都必须为 S type member 提供一个类型：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeCalculator</span> <span class="keyword">extends</span> <span class="title">Calculator</span> </span>&#123; <span class="class"><span class="keyword">type</span> <span class="title">S</span> </span>= <span class="type">String</span> &#125;</span><br></pre></td></tr></table></figure>
<p>抽象类型成员的好处是，它可以隐藏一个组件的内部信息。我会用一个例子来证明这个事实。假设你准备构建一个价格计算器，它接收一个产品ID，返回该ID的价钱。有很多种方式计算这个价钱，以及每种方式可以使用不同的数据资源类型来接收这个价格。你可以为零售公司出售的各种产品构建各种各样的类型，这些产品分别来自于不同的制造商(manufacturers)。常规的计算步骤如下：</p>
<ul>
<li>连接数据源(有多种类型)</li>
<li>使用该数据源计算价钱</li>
<li>关闭所连接的数据源</li>
</ul>
<p>编码这些步骤和架构，一个相当成功的做法是模版方法模式(Template Method pattern)，即根据多个子类实现一个通用算法。下面是父类Calculator特质使用模版方法模式的实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span>: <span class="type">DbConnection</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(s: <span class="type">DbConnection</span>): <span class="type">Unit</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(productId: <span class="type">String</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> s = initialize</span><br><span class="line">    <span class="keyword">val</span> price = calculate(s, productId)</span><br><span class="line">    close(s)</span><br><span class="line">    price</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(s: <span class="type">DbConnection</span>, productId: <span class="type">String</span>): <span class="type">Double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，DbConnection是一个用于从数据库接收数据的组件。因为所有需要的步骤都已经实现，每个计算器可以重载 <code>calculate(s: DAO, productId: String)</code> 方法。当前实现的问题是DAO是硬连接的，使用不同类型的数据库会导致该计算不可用。</p>
<p>你可以修改DbConnection的硬连接问题，通过创建一个抽象类型成员，并隐藏组件从数据库接收的类型。下面为带有抽象类型成员的Calculator特质：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abstractMember &#123;</span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">S</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span>: <span class="type">S</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(s: <span class="type">S</span>): <span class="type">Unit</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(productId: <span class="type">String</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> s = initialize</span><br><span class="line">      <span class="keyword">val</span> price = calculate(s, productId)</span><br><span class="line">      close(s)</span><br><span class="line">      price</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(s: <span class="type">S</span>, productId: <span class="type">String</span>): <span class="type">Double</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Calculator特质将数据库的连接作为类型抽象出来，方法<code>initialize</code>用于连接数据库，<code>close</code>方法用于关闭数据库。现在没有任何具体的计算实现，要实现所有抽象方法，需要为类型S提供类型信息。下面是使用MongoDB作为数据库的实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CostPlusCalculator</span> <span class="keyword">extends</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">S</span> </span>= <span class="type">MongoClient</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span> </span>= <span class="keyword">new</span> <span class="type">MongoClient</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(dao: <span class="type">MongoClient</span>) = dao.close</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">calculate</span></span>(source: <span class="type">MongoClient</span>, productId: <span class="type">String</span>) = &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">close</span> </span>= ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象类型成员的概念对于模拟类型家族多样性特别有帮助，下一小节介绍自类型，它可以帮助构建更小的组件。</p>
<h3 id="812〖Self-type-members〗P228"><a class="header-anchor" href="#812〖Self-type-members〗P228">¶</a>8<sub>1</sub>2〖Self type members〗P228</h3>
<p>自类型注解允许你访问一个特质或类的成员，Scala编译器会确保在实例化这些类时，所有依赖已经被正确装载。自类型使得混入组件更加强大，因为它允许你通过其它类或特质静态地定义依赖。在下面例子，特质A定义了特质B的一个依赖：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">b</span></span>():<span class="type">Unit</span> = ???</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  self: <span class="type">B</span> =&gt; <span class="function"><span class="keyword">def</span> <span class="title">a</span></span>():<span class="type">Unit</span> = b()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特质<code>A</code>不能被混入到其它不是继承自<code>B</code>的具体类中。由于类型安全，你可以在<code>A</code>中访问<code>B</code>的成员，如上述代码。注意<code>self</code>是一个名称，它可以是任何有效的参数名。自类型注解常见名称有<code>this</code>、<code>self</code>。</p>
<p>这里使用一个例子来证明自类型(self type)如何在真实应用中工作。这个例子中，你构建一个产品搜索，它依赖于两个必须服务：一个数据库访问和一个日志记录。因为特质可以让你更容易地组合特性，可以把这两个必要服务分离成特质。下面是服务特质：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">query</span></span>(q: <span class="type">String</span>): <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">info</span></span>(l: <span class="type">String</span>): <span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">RequiredServices</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">makeDatabaseConnection</span></span>: <span class="type">Connection</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>: <span class="type">Logger</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RequiredServices特质声明了可能会被product finder用到的所有服务：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ProductFinder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>: <span class="type">RequiredServices</span> =&gt; <span class="function"><span class="keyword">def</span> <span class="title">findProduct</span></span>(productId: <span class="type">String</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> c = makeDatabaseConnection</span><br><span class="line">    c.query(productId)</span><br><span class="line">    log.info(<span class="string">&quot;querying database...&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为RequiredServices用自类型注解this，你仍然可以访问这些服务，Scala编译器会确保最终混入的类中是否实现了RequiredServices。下面列出其实现复杂代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">query</span></span>(q: <span class="type">String</span>): <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">info</span></span>(l: <span class="type">String</span>): <span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">RequiredServices</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">makeDatabaseConnection</span></span>: <span class="type">Connection</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>: <span class="type">Logger</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TestServices</span> <span class="keyword">extends</span> <span class="title">RequiredServices</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">makeDatabaseConnection</span> </span>= <span class="keyword">new</span> <span class="type">Connection</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span></span>(q: <span class="type">String</span>) = <span class="string">&quot;test&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">log</span> </span>= <span class="keyword">new</span> <span class="type">Logger</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span></span>(l: <span class="type">String</span>) = logger info l</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ProductFinder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>: <span class="type">RequiredServices</span> =&gt; <span class="function"><span class="keyword">def</span> <span class="title">findProduct</span></span>(productId: <span class="type">String</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> c = makeDatabaseConnection</span><br><span class="line">    c.query(productId)</span><br><span class="line">    log.info(<span class="string">&quot;querying database...&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终对象需要组合所有的trait</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FinderSystem</span> <span class="keyword">extends</span> <span class="title">ProductFinder</span> <span class="keyword">with</span> <span class="title">TestServices</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">FinderSystem</span>.findProduct(<span class="string">&quot;1L&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这个例子展示了如何通过使用自类型注解和混入组合来构建一个大型的组件。我们会在第十章单元测试部分在再一次介绍自类型。现在，我们进入到构建我们的第一个可重用组件——一个通用订单系统。</p>
<h3 id="813〖Building-a-scalable-component〗P229"><a class="header-anchor" href="#813〖Building-a-scalable-component〗P229">¶</a>8<sub>1</sub>3〖Building a scalable component〗P229</h3>
<p>让我们构建一个通用产品订单系统，来看看如何构建一个可重用的组件。它将在任何类型的产品中重用。一个通用的订单系统将构建下面这些组件：</p>
<p><img src="/img/scala-in-action/chapter8/Figure_8_1.png" alt="Figure 8.1"></p>
<ul>
<li>一个订单组件，表示客户提供的。</li>
<li>一个产品库存清单组件，用于检查库存是否有产品，以提供订单。</li>
<li>一个航运组件，表示如何向客户运送的清单。</li>
</ul>
<p>真实世界里面的订单系统比这更加复杂，但这里附上简单的系统，因为你可以很容易将它扩展成一个大的环境。</p>
<p>你可以使用抽象类型成员来抽象出这些组件：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">OrderingSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">O</span> <span class="title">&lt;</span></span>: <span class="type">Order</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">I</span> <span class="title">&lt;</span></span>: <span class="type">Inventory</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">S</span> <span class="title">&lt;</span></span>: <span class="type">Shipping</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OrderingSystem声明了三个抽象成员——<code>O</code>，<code>I</code>，和<code>S</code>——同时为每个类型设置了上边界。类型<code>O</code>表示Order类型的子类型。类似地，<code>I</code>和<code>S</code>分别是Inventory和Shipping的子类型。以及为Order，Inventory，and Shipping的每个组件定义构造器：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">OrderingSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">O</span> <span class="title">&lt;</span></span>: <span class="type">Order</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">I</span> <span class="title">&lt;</span></span>: <span class="type">Inventory</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">S</span> <span class="title">&lt;</span></span>: <span class="type">Shipping</span></span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Order</span> </span>&#123;<span class="function"><span class="keyword">def</span> <span class="title">placeOrder</span> </span>(i: <span class="type">I</span>):<span class="type">Unit</span> &#125;</span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Inventory</span> </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">itemExists</span></span>(order: <span class="type">O</span>): <span class="type">Boolean</span> &#125;</span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Shipping</span> </span>&#123;<span class="function"><span class="keyword">def</span> <span class="title">scheduleShipping</span></span>(order: <span class="type">O</span>): <span class="type">Long</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有这些组件嵌入在特质(trait)下的好处是，它们都是聚合的并封装在同一个地方。现在你为每个组件提供了接口，但需要为其提供实现步骤，如下：</p>
<ul>
<li>检查订单条目是否存在于库存。</li>
<li>对库存订货。</li>
<li>安排订单发货。</li>
<li>如果条目不存在库存中，发货没有对上订货，尽快通知库存补充上产品。</li>
</ul>
<p>让我们在OrderingSystem内实现这些步骤的一个部分Ordering：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Ordering</span> </span>&#123;<span class="keyword">this</span>: <span class="type">I</span> <span class="keyword">with</span> <span class="type">S</span> =&gt;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">placeOrder</span></span>(o: <span class="type">O</span>): <span class="type">Option</span>[<span class="type">Long</span>] = &#123;</span><br><span class="line">    <span class="keyword">if</span>(itemExists(o)) &#123;</span><br><span class="line">      o.placeOrder (<span class="keyword">this</span>)</span><br><span class="line">      <span class="type">Some</span>(scheduleShipping(o))</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="type">None</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了自类型注解的帮助，方法placeOrder实现了所有的步骤。订单现在依赖于库存方法<code>itemExists</code>和航运方法<code>scheduleShipping</code>。注意，你可以用<code>with</code>关键字指明多个自类型注解，这个特质的混入(mix in)类似。所有这些代码块合在一起组成了一个订单系统组件。下列为完整的代码清单：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">OrderingSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">O</span> <span class="title">&lt;</span></span>: <span class="type">Order</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">I</span> <span class="title">&lt;</span></span>: <span class="type">Inventory</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">S</span> <span class="title">&lt;</span></span>: <span class="type">Shipping</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Ordering</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>: <span class="type">I</span> <span class="keyword">with</span> <span class="type">S</span> =&gt;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">placeOrder</span></span>(o: <span class="type">O</span>): <span class="type">Option</span>[<span class="type">Long</span>] = &#123;</span><br><span class="line">      <span class="keyword">if</span> (itemExists(o)) &#123;</span><br><span class="line">        o.placeOrder(<span class="keyword">this</span>)</span><br><span class="line">        <span class="type">Some</span>(scheduleShipping(o))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="type">None</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Order</span> </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">placeOrder</span></span>(i: <span class="type">I</span>): <span class="type">Unit</span> &#125;</span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Inventory</span> </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">itemExists</span></span>(order: <span class="type">O</span>): <span class="type">Boolean</span> &#125;</span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Shipping</span> </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">scheduleShipping</span></span>(order: <span class="type">O</span>): <span class="type">Long</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象类型成员OrderingSystem表示需求业务，它可以在不同的上下文中重用。混入的特性使得可以通过组合Inventory和Shipping来构建特质。最后，自类型使得Ordering可以使用混入提供了的方法。如果你想要实现的具体的订单系统，你可以继承OrderingSystem实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">BookOrderingSystem</span> <span class="keyword">extends</span> <span class="title">OrderingSystem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="class"><span class="keyword">type</span> <span class="title">O</span> </span>= <span class="type">BookOrder</span></span><br><span class="line">  <span class="keyword">override</span> <span class="class"><span class="keyword">type</span> <span class="title">S</span> </span>= <span class="type">UPS</span></span><br><span class="line">  <span class="keyword">override</span> <span class="class"><span class="keyword">type</span> <span class="title">I</span> </span>= <span class="type">AmazonBookStore</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">BookOrder</span> <span class="keyword">extends</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">placeOrder</span></span>(i: <span class="type">AmazonBookStore</span>): <span class="type">Unit</span> = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">AmazonBookStore</span> <span class="keyword">extends</span> <span class="title">Inventory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">itemExists</span></span>(order: <span class="type">BookOrder</span>): <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">UPS</span> <span class="keyword">extends</span> <span class="title">Shipping</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">scheduleShipping</span></span>(order: <span class="type">BookOrder</span>): <span class="type">Long</span> = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">BookOrdering</span> <span class="keyword">extends</span> <span class="title">Ordering</span> <span class="keyword">with</span> <span class="title">AmazonBookStore</span> <span class="keyword">with</span> <span class="title">UPS</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BookOrderingSystem为BookOrdering提供了一个具体的实现。现在你通过导入进行使用：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">BookOrderingSystem</span>._</span><br><span class="line"><span class="keyword">val</span> place = <span class="type">BookOrdering</span>.placeOrder(<span class="keyword">new</span> <span class="type">BookOrder</span>)</span><br><span class="line">logger info <span class="string">f&quot;<span class="subst">$place</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>下一小节将为你展示如何使用你所学习的概念来解决表述问题。</p>
<h3 id="814〖Building-an-extensible-component〗P232"><a class="header-anchor" href="#814〖Building-an-extensible-component〗P232">¶</a>8<sub>1</sub>4〖Building an extensible component〗P232</h3>
<p>软件工程的根本挑战是，在不改变已存在的代码的前提下，扩展一个软件组件，并把它集成到一个已存在的系统中。许多人用 表述问题(expression problem)来证明在一个软件组件的可扩展性下， 面向对象继承的失败。表述问题指的是，在不用编译和维护静态的类型安全前提下，使用case来定义数据类型，并可以为case添加一个新的类型，以及操作这个类型。通常它用来证明编程语言的优势和劣势。接下来，将为你展示Scala如何解决这个表述问题。但是接下来先看看表述问题具体是什么：</p>
<p><strong>THE EXPRESSION PROBLEM AND THE EXTENSIBILITY CHALLENGE</strong></p>
<p>目标是在该数据类型上定义一个数据类型和操作，它可以添加一个新的数据类型和操作，而不用编译已存在的代码，但仍然保留静态类型安全。<br>
任何实现表述问题的，都应该满足一下这些要求：</p>
<ul>
<li>两个维度的可扩展性。你可以所有类型添加新的类型和操作。</li>
<li>强大的静态类型安全。类型转换和反射是不可能的。</li>
<li>不修改已存在的代码， 不能存在重复的代码。</li>
<li>单独编译。</li>
</ul>
<p>让我们用一个练习例子来探索该问题。你有一个为全职员工处理薪资的工资系统：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span>(<span class="params">name: <span class="type">String</span>, id: <span class="type">Long</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Payroll</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employees: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USPayroll</span> <span class="keyword">extends</span> <span class="title">Payroll</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employees: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = ???</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CanadaPayroll</span> <span class="keyword">extends</span> <span class="title">Payroll</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employees: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Payroll特质声明了processEmployees方法用于接收一个employee集合，并处理它们的薪资。它的返回值是Either，因为它可能是成功或失败。USPayroll和CanadaPayroll都实现了processEmployees方法，用于处理不同地区的薪资。</p>
<p>在当前业务处理中，你也需要为日本地区的全职工作者处理薪资。那很简单——再添加一个Payroll的实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JapanPayroll</span> <span class="keyword">extends</span> <span class="title">Payroll</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employees: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是我们需要讨论的表述问题(expression problem)。解决方案是类型安全，你可以将JapanPayroll单独编译，作为扩展或插件添加到已有的payroll系统中。</p>
<p>如果添加一个新的操作，会发生什么？在这种情况下,业务已经决定雇佣承包商了，你还要处理他们每月的薪资。新的Payroll接口看起来像：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Contractor</span>(<span class="params">name: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Payroll</span> <span class="keyword">extends</span> <span class="title">super</span>.<span class="title">Payroll</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employees: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">processContractors</span></span>(contractors: <span class="type">Vector</span>[<span class="type">Contractor</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题是你不能从头修改Payroll，它会强制你修改更多的东西，你受到表述问题的约束。这段练习的问题是：如何在已存在的系统中增量地添加新特性，而不用做任何修改。为了理解处理表述问题有多难，让我们尝试另外一种方式：使用访问者模式来处理该问题。你会有一个处理雇员薪资的访问者：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">USPayroll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(v: <span class="type">PayrollVisitor</span>) = v.visit(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CanadaPayroll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(v: <span class="type">PayrollVisitor</span>) = v.visit(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PayrollVisitor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(payroll: <span class="type">USPayroll</span>): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(payroll: <span class="type">CanadaPayroll</span>): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeePayrollVisitor</span> <span class="keyword">extends</span> <span class="title">PayrollVisitor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(payroll: <span class="type">USPayroll</span>): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = ???</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(payroll: <span class="type">CanadaPayroll</span>): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型USPayroll和CanadaPayroll都接收一个payroll观察者。为了处理雇员的薪资，使用接口EmployeePayrollVisitor。为了处理承包商(contractors)每月的支出，你可以创建一个新的类ContractorPayrollVisitor，代码如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContractorPayrollVisitor</span> <span class="keyword">extends</span> <span class="title">PayrollVisitor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(payroll: <span class="type">USPayroll</span>): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = ???</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(payroll: <span class="type">CanadaPayroll</span>): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用访问者模式，可以容易地添加一个新的操作，但怎么添加一个新的类型？如果你尝试添加一个新的类型JapanPayroll，这就有问题了。你需要重新修改访问者(visitor)，以允许它接收JapanPayroll类型。第一种方法中容易添加类型、第二种方法容易添加操作。那么有没有方法可以让我们改变这两个层面。下面将介绍使用Scala的抽象类型成员和特质混入来解决这个问题。</p>
<p><strong>SOLVING THE EXPRESSION PROBLEM</strong></p>
<p>你将使用Scala特质以及抽象类型成员(abstract type members)来解决表述问题(expression problem)。还是以payroll系统为例，我将展示如何轻松地添加新的操作到payroll系统中，同时添加一个新的类型，而不会打破类型安全。</p>
<p>首先，为payroll系统使用抽象类型成员来定义它的基础系统原型：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ImprovedPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span>(<span class="params">name: <span class="type">String</span>, id: <span class="type">Long</span></span>)</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">P</span> <span class="title">&lt;</span></span>: <span class="type">Payroll</span></span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Payroll</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employee: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(p: <span class="type">P</span>): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里再一次把所有东西嵌套进trait中，这样我们可以把它当作一个模组。类型<code>P</code>表示特质Payroll的子类型，它声明了一个抽象方法用于处理雇员的工资。方法processPayroll需要实例化，以处理一个给定的Payroll类型。下面是U.S.和Canada的payroll实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">USPayrollSystem</span> <span class="keyword">extends</span> <span class="title">ImprovedPayrollSystem</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">USPayroll</span> <span class="keyword">extends</span> <span class="title">Payroll</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employee: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;US payroll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">CanadaPayrollSystem</span> <span class="keyword">extends</span> <span class="title">ImprovedPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CanadaPayroll</span> <span class="keyword">extends</span> <span class="title">Payroll</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employee: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;Canada payroll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里省略了工资处理的具体操作，因为这不是重点。为了处理U.S.地区雇员的薪资，你可以实例化USPayrollSystem，并实现里面的processPayroll方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">USPayrollInstance</span> <span class="keyword">extends</span> <span class="title">USPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="class"><span class="keyword">type</span> <span class="title">P</span> </span>= <span class="type">USPayroll</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(p: <span class="type">USPayrollInstance</span>.<span class="type">USPayroll</span>): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> employees: <span class="type">Vector</span>[<span class="type">Employee</span>] = <span class="type">Vector</span>(<span class="type">Employee</span>(<span class="string">&quot;emp1&quot;</span>,<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">val</span> result = p.processEmployees(employees)</span><br><span class="line">    <span class="type">Left</span>(<span class="string">&quot;Process successful&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里设置中，可以容易地为Payroll添加新的类型，创建一个特质继承自PayrollSystem：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">JapanPayrollSystem</span> <span class="keyword">extends</span> <span class="title">ImprovedPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">JapanPayroll</span> <span class="keyword">extends</span> <span class="title">Payroll</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employees: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;Japan payroll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在向Payroll添加一个新的特质，而不用编译所有的东西，使用Scala的影子特性：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ContractorPayrollSystem</span> <span class="keyword">extends</span> <span class="title">ImprovedPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">p</span> <span class="title">&lt;</span></span>: <span class="type">Payroll</span></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Contractor</span>(<span class="params">name: <span class="type">String</span></span>)</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Payroll</span> <span class="keyword">extends</span> <span class="title">super</span>.<span class="title">Payroll</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processContractors</span></span>(contractors: <span class="type">Vector</span>[<span class="type">Contractor</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义在ContractorPayrollSystem内的Payroll并没有重构来自于PayrollSystem里面的定义的Payroll，它作为影子替代。前者定义的Payroll在ContractPayrollSystem上下文环境中使用了super关键字，使其可访问。影子效应在代码中会产生不可预料的错误，但这里却扩展了原来的Payroll，而不用重构它。</p>
<p>另外一个需要注意的事情是，你重新定义了抽象类型成员<code>P</code>。<code>P</code>需要被Payroll的子类型识别，包括processEmployees和processContractors方法。为了处理U.S.和Canada的承包商(contractors)，继承ContractPayrollSystem特质：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">USContractorPayrollSystem</span> <span class="keyword">extends</span> <span class="title">USPayrollSystem</span> <span class="keyword">with</span> <span class="title">ContractorPayrollSystem</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">USPayroll</span> <span class="keyword">extends</span> <span class="title">super</span>.<span class="title">USPayroll</span> <span class="keyword">with</span> <span class="title">Payroll</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processContractors</span></span>(contractors: <span class="type">Vector</span>[<span class="type">Contractor</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;US Contractor Payroll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">CanadaContractorPayrollSystem</span> <span class="keyword">extends</span> <span class="title">CanadaPayrollSystem</span> <span class="keyword">with</span> <span class="title">ContractorPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CanadaPayroll</span> <span class="keyword">extends</span> <span class="title">super</span>.<span class="title">CanadaPayroll</span> <span class="keyword">with</span> <span class="title">Payroll</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processContractors</span></span>(contractors: <span class="type">Vector</span>[<span class="type">Contractor</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;Canada Contractor Payroll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>影子定义了USPayroll和CanadaPayroll。同时混入了Payroll特质以实现processContractors方法。类型安全要求：如果你不混入Payroll，当你为USContractorPayrollSystem或CanadaContractorPayrollSystem实现具体类时，会发生一个错误。类似地，你可以添加processContractors操作到JapanPayrollSystem中：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">JapanContractorPayrollSystem</span> <span class="keyword">extends</span> <span class="title">JapanPayrollSystem</span> <span class="keyword">with</span> <span class="title">ContractorPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">JapanPayroll</span> <span class="keyword">extends</span> <span class="title">super</span>.<span class="title">JapanPayroll</span> <span class="keyword">with</span> <span class="title">Payroll</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processContractors</span></span>(contractors: <span class="type">Vector</span>[<span class="type">Contractor</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;Japan Contractor Payroll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，你已经成功地解决了表述问题(expression problem)。下面列出完整的代码实例：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ImprovedPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span>(<span class="params">name: <span class="type">String</span>, id: <span class="type">Long</span></span>)</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">P</span> <span class="title">&lt;</span></span>: <span class="type">Payroll</span></span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Payroll</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employee: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(p: <span class="type">P</span>): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">USPayrollSystem</span> <span class="keyword">extends</span> <span class="title">ImprovedPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">USPayroll</span> <span class="keyword">extends</span> <span class="title">Payroll</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employee: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;US payroll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">CanadaPayrollSystem</span> <span class="keyword">extends</span> <span class="title">ImprovedPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CanadaPayroll</span> <span class="keyword">extends</span> <span class="title">Payroll</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employee: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;Canada payroll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">USPayrollInstance</span> <span class="keyword">extends</span> <span class="title">USPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="class"><span class="keyword">type</span> <span class="title">P</span> </span>= <span class="type">USPayroll</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(p: <span class="type">USPayrollInstance</span>.<span class="type">USPayroll</span>): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> employees: <span class="type">Vector</span>[<span class="type">Employee</span>] = <span class="type">Vector</span>(<span class="type">Employee</span>(<span class="string">&quot;emp1&quot;</span>, <span class="number">1</span>))</span><br><span class="line">    p.processEmployees(employees)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">JapanPayrollSystem</span> <span class="keyword">extends</span> <span class="title">ImprovedPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">JapanPayroll</span> <span class="keyword">extends</span> <span class="title">Payroll</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processEmployees</span></span>(employees: <span class="type">Vector</span>[<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;Japan payroll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ContractorPayrollSystem</span> <span class="keyword">extends</span> <span class="title">ImprovedPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">p</span> <span class="title">&lt;</span></span>: <span class="type">Payroll</span></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Contractor</span>(<span class="params">name: <span class="type">String</span></span>)</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Payroll</span> <span class="keyword">extends</span> <span class="title">super</span>.<span class="title">Payroll</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processContractors</span></span>(contractors: <span class="type">Vector</span>[<span class="type">Contractor</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">USContractorPayrollSystem</span> <span class="keyword">extends</span> <span class="title">USPayrollSystem</span> <span class="keyword">with</span> <span class="title">ContractorPayrollSystem</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">USPayroll</span> <span class="keyword">extends</span> <span class="title">super</span>.<span class="title">USPayroll</span> <span class="keyword">with</span> <span class="title">Payroll</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processContractors</span></span>(contractors: <span class="type">Vector</span>[<span class="type">Contractor</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;US Contractor Payroll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">CanadaContractorPayrollSystem</span> <span class="keyword">extends</span> <span class="title">CanadaPayrollSystem</span> <span class="keyword">with</span> <span class="title">ContractorPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CanadaPayroll</span> <span class="keyword">extends</span> <span class="title">super</span>.<span class="title">CanadaPayroll</span> <span class="keyword">with</span> <span class="title">Payroll</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processContractors</span></span>(contractors: <span class="type">Vector</span>[<span class="type">Contractor</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;Canada Contractor Payroll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">JapanContractorPayrollSystem</span> <span class="keyword">extends</span> <span class="title">JapanPayrollSystem</span> <span class="keyword">with</span> <span class="title">ContractorPayrollSystem</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">JapanPayroll</span> <span class="keyword">extends</span> <span class="title">super</span>.<span class="title">JapanPayroll</span> <span class="keyword">with</span> <span class="title">Payroll</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processContractors</span></span>(contractors: <span class="type">Vector</span>[<span class="type">Contractor</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;Japan Contractor Payroll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">JapanContractorPayrollInstance</span> <span class="keyword">extends</span> <span class="title">JapanContractorPayrollSystem</span></span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="class"><span class="keyword">type</span> <span class="title">P</span> </span>= <span class="type">JapanPayroll</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(p: <span class="type">JapanContractorPayrollInstance</span>.<span class="type">JapanPayroll</span>): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = &#123;</span><br><span class="line">    p.processContractors(<span class="type">Vector</span>(<span class="type">Contractor</span>(<span class="string">&quot;con1&quot;</span>)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Scala的第一类对象模块支持，你可以转换一个对象内的所有特质和类，并扩展一个存在的软件组件，而不用强制重新编译所有东西，以及维护类型安全。注意新的和旧的Payroll接口都是可用的，实际使用了哪个取决于你传递了那个特质组件。要使用新的Payroll，你可处理employees和contractors，你必须混入ContractorPayrollSystem特质。下面例子阐述如何创建一个USContractorPayrollSystem，以及如何使用：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">RunNewPayroll</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">USNewPayrollInstance</span> <span class="keyword">extends</span> <span class="title">USContractorPayrollSystem</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">type</span> <span class="title">p</span> </span>= <span class="type">USPayroll</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(p: <span class="type">USNewPayrollInstance</span>.<span class="type">USPayroll</span>): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = &#123;</span><br><span class="line">      p.processEmployees(<span class="type">Vector</span>(<span class="type">Employee</span>(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>)))</span><br><span class="line">      p.processContractors(<span class="type">Vector</span>(<span class="type">Contractor</span>(<span class="string">&quot;b&quot;</span>)))</span><br><span class="line">      <span class="type">Left</span>(<span class="string">&quot;payroll processed successful&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法processPayroll同时调用了Payroll特质的processEmployees和processContractors方法，这个仍然保留了USPayrollSystem的实现，你仍然可以继承它并使用里面的processPayroll方法。</p>
<p>这个例子足够证明了Scala类型系统的强大，抽象可用地构建可伸缩的、可扩展的组件。我们使用了Scala面向对象的抽象解决了该问题。在8.3小节，我将介绍用函数式编程的方式来解决该问题。但接下来我们继续讨论Scala另一个强大的类型抽象。</p>
<h3 id="8-2〖Types-of-types-in-Scala〗P238"><a class="header-anchor" href="#8-2〖Types-of-types-in-Scala〗P238">¶</a>8~2〖Types of types in Scala〗P238</h3>
<p>Scala独有的一个特性是它的丰富的类型系统。和其它优秀类型系统一样，它提供了必要的抽象来构建可重用组件。本小节一起探讨Scala类型系统提供的丰富类型。</p>
<h3 id="821〖Structural-types〗P238"><a class="header-anchor" href="#821〖Structural-types〗P238">¶</a>8<sub>2</sub>1〖Structural types〗P238</h3>
<p>在Scala中，结构类型(structural type)是一种通过自身结构描述类型的一种方式，不通过自身名称，就如其它类型一样。如果你学习过动态类型语言，一个结构类型(structural type)会让你感觉像是一个类型安全的 鸭子类型(duck typing，动态类型的一种)。假设你想要关闭任何想要关闭的资源。实现方式是定义一个特质并声明一个close方法，并让所有资源实现类继承该特质。但使用一个结构类型，你可以容易地通过指定它的结构来定义一个新的类型，如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(closable: &#123;<span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(): <span class="type">Unit</span>&#125;): <span class="type">Unit</span> = &#123;</span><br><span class="line">  closable.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里参数的类型由 <code>&#123;def close: Unit &#125;</code> 结构被定义。这种方式的灵活性在于，你可以传递任何类型的实例给该方法，只要它实现了 <code>def close: Unit</code>方法。当前这个新的类型没有任何名字，你可以使用 <code>type</code> 关键字为它提供一个名字(即类型别名)：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Closable</span> </span>= &#123;<span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(): <span class="type">Unit</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(closable: &#123;<span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(): <span class="type">Unit</span>&#125;): <span class="type">Unit</span> = &#123;</span><br><span class="line">  closable.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构类型并不局限于一个单一的方法，当定义多个方法时，要确保你使用了 <code>type</code> 关键字为其给定一个名字，否则，你的函数签名会看起来令人费解：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Profile</span> </span>= &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">name</span></span>: <span class="type">String</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">address</span></span>: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以使用 <code>new</code> 关键字创建结构类型的新的值。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> nilanjanProfile = <span class="keyword">new</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">name</span> </span>= “<span class="type">Nilanjan</span>”</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">address</span> </span>= “<span class="type">Boulder</span>, <span class="type">CO</span>”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以使用结构类型来减少类层次结构，并简化基础代码。比如有下面类层次结构，表示百货商店工作者的多种类型：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">salary</span></span>: <span class="type">BigDecimal</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bonusPercentage</span></span>: <span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">HourlyWorker</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hours</span></span>: <span class="type">Int</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">salary</span></span>: <span class="type">BigDecimal</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">FullTimeWorker</span>(<span class="params">val salary: <span class="type">BigDecimal</span>, val bonusPercentage: <span class="type">Double</span></span>) <span class="keyword">extends</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PartTimeWorker</span>(<span class="params">val hours: <span class="type">Int</span>, val salary: <span class="type">BigDecimal</span></span>) <span class="keyword">extends</span> <span class="title">HourlyWorker</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentWorker</span>(<span class="params">val hours: <span class="type">Int</span>, val salary: <span class="type">BigDecimal</span></span>) <span class="keyword">extends</span> <span class="title">HourlyWorker</span></span></span><br></pre></td></tr></table></figure>
<p>这是小的层次结构，但你有了想法。每个worker的类型都是不同的；有全职的、兼职的。他们唯一共通的一点是都需要付薪。如果你需要在给定的月份中为工作者计算支付薪酬，你需要定义另外一个通用的类型来表示薪酬工作者：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">SalariedWorker</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">salary</span></span>: <span class="type">BigDecimal</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">SalariedWorker</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bonusPercentage</span></span>: <span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">HourlyWorker</span> <span class="keyword">extends</span> <span class="title">SalariedWorker</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hours</span></span>: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">FullTimeWorker</span>(<span class="params">val salary: <span class="type">BigDecimal</span>, val bonusPercentage: <span class="type">Double</span></span>) <span class="keyword">extends</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PartTimeWorker</span>(<span class="params">val hours: <span class="type">Int</span>, val salary: <span class="type">BigDecimal</span></span>) <span class="keyword">extends</span> <span class="title">HourlyWorker</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentWorker</span>(<span class="params">val hours: <span class="type">Int</span>, val salary: <span class="type">BigDecimal</span></span>) <span class="keyword">extends</span> <span class="title">HourlyWorker</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">amountPaidAsSalary</span></span>(workers: <span class="type">Vector</span>[<span class="type">SalariedWorker</span>]) = &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>鸭子类型的好处是，它可以抽象出共性(commonalities)，而不用作为同一个类型的一部分。使用结构类型(structural type)可以容易地重写一个函数，而不用声明一个新的类型：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">amountPaidAsSalary2</span></span>(workers: <span class="type">Vector</span>[&#123;<span class="function"><span class="keyword">def</span> <span class="title">salary</span></span>: <span class="type">BigDecimal</span> &#125;]) = &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你可以传递任何工作者的实例，并且不用考虑具体的类型。结构类型的好处是，去除了结构层次中不需要的类型定义，不好的方面是它相对比较慢，因为它底层使用了反射。</p>
<h3 id="822〖Higher-kinded-types〗P240"><a class="header-anchor" href="#822〖Higher-kinded-types〗P240">¶</a>8<sub>2</sub>2〖Higher-kinded types〗P240</h3>
<p>高级类类型(Higher-kinded types)是指为类型参数创建一个新的类型。因此高级类类型也称为类型构造器，type constructors——接收另一个类型作为参数，并创建一个新的类型。<code>scala.collections.immutable.List[+A]</code>为高级类类型的一个例子。它接收一个类型参数，并创建一个新的具体的类型。<code>List[String]</code>和<code>List[Int]</code>为List所创建的具体类型。种类之于类型，正如类型之于值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[Kinds] --&gt; B[Types]</span><br><span class="line">    B --&gt; C[Values]</span><br></pre></td></tr></table></figure>
<blockquote><p><strong>MODULARIZING LANGUAGE FEATURES</strong></p>
<p>Scala定义了一大堆功能强大的特性，但并不是每个程序员都要全部运用这些特性。</p>
<p>从Scala 2.10 开始，你必须先使其高级特性可用，这归功于Scala语言特性模块化的思想。</p>
<p>scala.language为编程人员提供了语言特性可用操作。进入到scala.language文档，可以找到所有你可以操作的特性。例如，对于大型项目，你可以禁用掉一些滥用的Scala高级特性。如果被禁用的特性在代码中被使用到，编译器会生成一段警告(使用 -feature 显示警告信息)。例如，一个高级类类型(higher-kinded)作为一个高级特性，你需要显式地导入 import scala.language.higherKinds 使其可用。你也可以在编译时，使用 -language:higherKinds 完成同样的事情。</p>
<p>要启用所有高级特性，使用 <code>-language:_ parameter</code>传递给编译器。</p>
</blockquote>
<p>大部分集合类都很好地说明了为什么类型是如此强大的抽象工具。在第5章出现过高级类类型(higher-kinded types)的例子。下面看看更多的例子以了解其实用性。你尝试构建一个函数，它接收另外一个函数作为参数，并提供函数的一个指定类型。如，有一个vector参数，处理vector里面的所有元素：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fmap</span></span>[<span class="type">A</span>, <span class="type">B</span>](xs: <span class="type">Vector</span>[<span class="type">A</span>], f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">Vector</span>[<span class="type">B</span>] = xs map f</span><br></pre></td></tr></table></figure>
<p>fmap提供了给定的函数<code>f</code>操作vector的所有元素。相似地，要操作Option，你可以创建另外一个函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fmap</span></span>[<span class="type">A</span>, <span class="type">B</span>](xs: <span class="type">Option</span>[<span class="type">A</span>], f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">Option</span>[<span class="type">B</span>] = xs map f</span><br></pre></td></tr></table></figure>
<p>但这两个看起来都一样，仅仅是类型不同。问题是：如何定义一个通用的fmap方法，并以各种类型作方法签名？使用高级类类型，你可以抽象第一个参数的类型，如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Mapper</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fmap</span></span>[<span class="type">A</span>, <span class="type">B</span>](xs: <span class="type">F</span>[<span class="type">A</span>], f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">F</span>[<span class="type">B</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特质Mapper通过<code>F[_]</code>类型被参数化。F是一个高级类类型，因为它用 <code>_</code> 标记接收其它类型参数。如果你实现了Vector的fmap，你可以：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">VectorMapper</span> </span>= <span class="keyword">new</span> <span class="type">Mapper</span>[<span class="type">Vector</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">fmap</span></span>[<span class="type">A</span>, <span class="type">B</span>](xs: <span class="type">Vector</span>[<span class="type">A</span>], f: (<span class="type">A</span>) =&gt; <span class="type">B</span>): <span class="type">Vector</span>[<span class="type">B</span>] = xs map f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似地，Option的定义是：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OptionMapper</span> </span>= <span class="keyword">new</span> <span class="type">Mapper</span>[<span class="type">Option</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">fmap</span></span>[<span class="type">A</span>, <span class="type">B</span>](xs: <span class="type">Option</span>[<span class="type">A</span>], f: (<span class="type">A</span>) =&gt; <span class="type">B</span>): <span class="type">Option</span>[<span class="type">B</span>] = xs map f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用高级类类型，你可以提示抽象的层次，以及定义工作在多种类型上的接口。要实例化，你可以使用Mapper实现Function0的fmap：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Function0Mapper</span> </span>= <span class="keyword">new</span> <span class="type">Mapper</span>[<span class="type">Function0</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">fmap</span></span>[<span class="type">A</span>, <span class="type">B</span>](r: <span class="type">Function0</span>[<span class="type">A</span>], f: (<span class="type">A</span>) =&gt; <span class="type">B</span>) = <span class="keyword">new</span> <span class="type">Function0</span>[<span class="type">B</span>] &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span> </span>= f(r.apply())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Function0表示一个函数，它不接收任何参数。例如，你可以使用上述Function0Mapper来组合两个函数，创建成为一个新的函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> newFunction = <span class="type">Function0Mapper</span>.fmap(() =&gt; <span class="string">&quot;one&quot;</span>, (s: <span class="type">String</span>) =&gt; s.toUpperCase)</span><br></pre></td></tr></table></figure>
<p>newFunction.apply将会返回结果&quot;ONE&quot;，第一个参数定义了一个不接收参数的函数，并返回&quot;one&quot;，第二个参数定义了另外一个函数，接收一个String参数，并使它大写。这里在Function类型中，执行apply方法来调用它的函数。</p>
<blockquote><h4 id="Type-projection"><a class="header-anchor" href="#Type-projection">¶</a>Type projection</h4>
<p>离开这个例子之前，在方便的时候，我想要解析一个窍门叫 type projection。类型投影(type project) <code>T#x</code> 引用的是类型<code>T</code>的类型成员<code>x</code>。类型投影允许方法给定类型的类型成员。你可以这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">E</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">EE</span> </span>= <span class="type">X</span>#<span class="type">E</span></span><br></pre></td></tr></table></figure>
<p>这为定义在<code>X</code>内的类型成员<code>E</code>，创建了一个新的别名。这在真是环境中有什么用？以Either作为例子。Either是一个类型构造器，它接收两个参数，一个用于Left，另一个用于Right。你可以如下方式创建一个Left或Right实例：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Either</span>.cond(test = <span class="literal">true</span>, <span class="string">&quot;one&quot;</span>, <span class="keyword">new</span> <span class="type">RuntimeException</span>)</span><br><span class="line"></span><br><span class="line">res4: <span class="type">Either</span>[java.lang.<span class="type">RuntimeException</span>,java.lang.<span class="type">String</span>] = <span class="type">Right</span>(one)</span><br></pre></td></tr></table></figure>
<p>取决于第一个参数是否是true或false，据此来创建Either的Left或Right实例。你可以在Either类型上使用fmap吗？很难实现，因为fmap只接收带一个类型参数的类型，而Either则接收两个。但你可以使用类型投影(type projection)来隐藏一个类型参数，并实例化这个参数。</p>
<p>首先，你仅提供是Right的函数，由于Right表示成功，Left表示失败。fmap的实现看起来如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fmap</span></span>[<span class="type">A</span>, <span class="type">B</span>](r: <span class="type">Either</span>[<span class="type">X</span>, <span class="type">A</span>], f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">Either</span>[<span class="type">X</span>, <span class="type">B</span>] = r <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Left</span>(c) =&gt; <span class="type">Left</span>(c)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Right</span>(x) =&gt; <span class="type">Right</span>(f(x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该实现有趣的部分是类型参数<code>X</code>。这里<code>X</code>由创建Mapper的函数指定，使用类型投影，你可以在Mapper特质中隐藏<code>X</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">EitherMapper</span></span>[<span class="type">X</span>] = <span class="keyword">new</span> <span class="type">Mapper</span>[(&#123;<span class="class"><span class="keyword">type</span> <span class="title">E</span>[<span class="type">A</span>] </span>= <span class="type">Either</span>[<span class="type">X</span>, <span class="type">A</span>]&#125;)#<span class="type">E</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">fmap</span></span>[<span class="type">A</span>, <span class="type">B</span>](r: <span class="type">Either</span>[<span class="type">X</span>, <span class="type">A</span>], f: (<span class="type">A</span>) =&gt; <span class="type">B</span>): <span class="type">Either</span>[<span class="type">X</span>, <span class="type">B</span>] = r <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Left</span>(c) =&gt; <span class="type">Left</span>(c)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Right</span>(x) =&gt; <span class="type">Right</span>(f(x))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型投影<code>({type E[A] = Either[X, A]})#E</code>引用了类型别名<code>E[A] = Either[X, A]</code>。这这个例子中，<code>X</code>表示类型<code>Left</code>，以及你不需要担心该类型——这是为什么你隐藏它，并保留由<code>A</code>表示的类型<code>Right</code>。类型投影看起来有点不同寻常，但在你实际需要的时候会很有帮助。</p>
</blockquote>
<p>第一次尝试时，会稍微难写出像fmap这样的通用函数。我推荐先从具体的实现开始，在创建抽象之前，先理解这种模式。一旦你理解了这种模式，高级类类型创建抽象。我鼓励你查阅Scala集合<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>以学习更多关于高级类类型的用法。</p>
<h3 id="823〖Phantom-types〗P243"><a class="header-anchor" href="#823〖Phantom-types〗P243">¶</a>8<sub>2</sub>3〖Phantom types〗P243</h3>
<p>幻类型(Phantom types)指的是类型不提供任何构造器来创建值。这些类型只在编译期用于增强约束。如果没有例子，很难理解它是怎么用的。我们以订购系统为例。一张订单表示了订货条目和货运地址：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span>(<span class="params">itemId: <span class="type">Option</span>[<span class="type">Item</span>], address: <span class="type">Option</span>[<span class="type">String</span>]</span>)</span></span><br></pre></td></tr></table></figure>
<p>要下订单，你需要指定订单条目和发货地址。订单系统的客户端提供一个订单，指定发货地址，然后下单：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addItem</span></span>(item: <span class="type">String</span>, o: <span class="type">Order</span>) =</span><br><span class="line"><span class="type">Order</span> (<span class="type">Some</span>(item), o.shippingAddress)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addShipping</span></span>(address: <span class="type">String</span>, o: <span class="type">Order</span>) =</span><br><span class="line"><span class="type">Order</span> (o.itemId, <span class="type">Some</span>(address))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">placeOrder</span> </span>(o: <span class="type">Order</span>) = &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>这方式的问题是，这些方法会被订单以外调用。例如，一些客户会错误地先placeOrder，而没有addShipping。这样依赖，你需要在placeOrder方法内部实现一些必要的校验，但使用类型系统来增强这方面会显得更好。这里你就可以使用phantom类型来增强一些必要性校验。首先，我们看看下列表示订单状态的phantom type：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">OrderCompleted</span></span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">InCompleteOrder</span></span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">ItemProvided</span></span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">NoItem</span></span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">AddressProvided</span></span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">NoAddress</span></span></span><br></pre></td></tr></table></figure>
<p>每个类型都表示订单的一个确切状态，在处理这些订单流程中，将会使用到这些类型。当订单被初始化时，订单没有条目、没有地址，以及状态是incomplete的。这可以容易地使用幻类型(phantom type)来表示：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>](<span class="params">itemId: <span class="type">Option</span>[<span class="type">String</span>], shippingAddress: <span class="type">Option</span>[<span class="type">String</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">emptyOrder</span> </span>= <span class="type">Order</span>[<span class="type">IncompleteOrder</span>, <span class="type">NoItem</span>, <span class="type">NoAddress</span>](<span class="type">None</span>, <span class="type">None</span>)</span><br></pre></td></tr></table></figure>
<p>类型Order接收3个类型参数，空的订单用IncompleteOrder, NoItem 以及 NoAddress表示。为了在订单的每个操作上增强某些约束，你需要组合这些类型。例如，你只能向一个没有条目的订单新增条目，一旦添加完成后，类型参数由NoItem变为ItemProvided。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addItem</span></span>[<span class="type">A</span>, <span class="type">B</span>](item: <span class="type">String</span>, o: <span class="type">Order</span>[<span class="type">A</span>, <span class="type">NoItem</span>, <span class="type">B</span>]) =</span><br><span class="line">o.copy[<span class="type">A</span>, <span class="type">ItemProvided</span>, <span class="type">B</span>](itemId = <span class="type">Some</span>(item))</span><br></pre></td></tr></table></figure>
<p>addItem方法添加订单条目，并改变第二个参数NoItem为ItemProvided，创建了一个新的订单。类似地，addShipping也创建了一个新的订单，并更新了地址：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addShipping</span></span>[<span class="type">A</span>, <span class="type">B</span>](address: <span class="type">String</span>, o: <span class="type">Order</span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">NoAddress</span>]) =</span><br><span class="line">o.copy[<span class="type">A</span>, <span class="type">B</span>, <span class="type">AddressProvided</span>](shippingAddress = <span class="type">Some</span>(address))</span><br></pre></td></tr></table></figure>
<p>为了下订单，前提条件是订单包含条目和地址，因此你可以在编译时期使用类型来验证：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">placeOrder</span></span>(o: <span class="type">Order</span>[<span class="type">InCompleteOrder</span>, <span class="type">ItemProvided</span>, <span class="type">AddressProvided</span>]) = &#123;</span><br><span class="line">o.copy[<span class="type">OrderCompleted</span>, <span class="type">ItemProvided</span>, <span class="type">AddressProvided</span>]()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>placeOrder方法仅接收条目和地址为完成了的订单。如果你尝试调用不包含条目和地址的订单，会发生编译错误。调用placeOrder方法而不指定地址，会有如下错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[error] found :</span><br><span class="line">phantomtypes.Order[phantomtypes.InCompleteOrder,phantomtypes.ItemProvide</span><br><span class="line">d,phantomtypes.NoAddress]</span><br><span class="line">[error] required:</span><br><span class="line">phantomtypes.Order[phantomtypes.InCompleteOrder,phantomtypes.ItemProvide</span><br><span class="line">d,phantomtypes.AddressProvided]</span><br></pre></td></tr></table></figure>
<p>下面列出幻类型(Phantom types)的完整示例代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">OrderCompleted</span></span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">InCompleteOrder</span></span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">ItemProvided</span></span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">NoItem</span></span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">AddressProvided</span></span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">NoAddress</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>](<span class="params">itemId: <span class="type">Option</span>[<span class="type">String</span>], shippingAddress: <span class="type">Option</span>[<span class="type">String</span>]</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">emptyOrder</span> </span>= <span class="type">Order</span>[<span class="type">InCompleteOrder</span>, <span class="type">NoItem</span>, <span class="type">NoAddress</span>](<span class="type">None</span>, <span class="type">None</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">OrderingSystem</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 订单的操作处理，改变了原来的订单状态</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addItem</span></span>[<span class="type">A</span>, <span class="type">B</span>](item: <span class="type">String</span>, o: <span class="type">Order</span>[<span class="type">A</span>, <span class="type">NoItem</span>, <span class="type">B</span>]) =</span><br><span class="line">    o.copy[<span class="type">A</span>, <span class="type">ItemProvided</span>, <span class="type">B</span>](itemId = <span class="type">Some</span>(item))</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addShipping</span></span>[<span class="type">A</span>, <span class="type">B</span>](address: <span class="type">String</span>, o: <span class="type">Order</span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">NoAddress</span>]) =</span><br><span class="line">    o.copy[<span class="type">A</span>, <span class="type">B</span>, <span class="type">AddressProvided</span>](shippingAddress = <span class="type">Some</span>(address))</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">placeOrder</span></span>(o: <span class="type">Order</span>[<span class="type">InCompleteOrder</span>, <span class="type">ItemProvided</span>, <span class="type">AddressProvided</span>]) = &#123;</span><br><span class="line">    o.copy[<span class="type">OrderCompleted</span>, <span class="type">ItemProvided</span>, <span class="type">AddressProvided</span>]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要使用该订单系统，你需要逐步为订单添加详细的信息：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> o = <span class="type">Order</span>.emptyOrder</span><br><span class="line"><span class="keyword">val</span> o1 = addItem(<span class="string">&quot;some book&quot;</span>, o)</span><br><span class="line"><span class="keyword">val</span> o2 = addShipping(<span class="string">&quot;some address&quot;</span>, o1)</span><br></pre></td></tr></table></figure>
<p>这时，如果客户端不适当地提交订单，便会得到编译错误。你也可以使用该技术来实现类型安全的构建者模式(Builder pattern)，使用幻类型(phantom types)，可以确保所有被需求的值都是填充的。</p>
<p>Scala并不仅局限这些类型。它所包含的种类比这里所讲的还要多。例如有类型叫做方法依赖类型<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> (method dependent type)，它允许你指定返回基于类型参数的类型，有路径依赖类型(path-dependent types)则允许你通过object来约束类型，还有更多的。我的建议是多和这门语言接触，我可以确保你会熟悉Scala的类型。</p>
<h3 id="8-3〖Ad-hoc-polymorphism-with-type-classes〗P246"><a class="header-anchor" href="#8-3〖Ad-hoc-polymorphism-with-type-classes〗P246">¶</a>8~3〖Ad hoc polymorphism with type classes〗P246</h3>
<p>一个类型类的类型系统概念是支持即时-多态(ad hoc polymorphism)。即时-多态是一类多态函数可以提供不同的类型参数。即时多态可以为类型添加任何需要的特性。不要把类型类(type classes)看作是OOP概念的类；把它们看作是一个范畴(category)。类型类是定义类型集合的一种方式。在本小节将学习类型类如何帮助构建抽象。</p>
<h3 id="831〖Modeling-orthogonal-正交-concerns-using-type-classes〗P246"><a class="header-anchor" href="#831〖Modeling-orthogonal-正交-concerns-using-type-classes〗P246">¶</a>8<sub>3</sub>1〖Modeling orthogonal(正交) concerns using type classes〗P246</h3>
<p>一个例子将证明如何在Scala中实现类型类(type classes)。下面的例子使用类型类实现了一个适配器模式。在一个对象适配器模式中，适配器(转换对象)包含了一个要转换了实例类。适配器模式是类型函数式组合实现的一个好方法。下面是你尝试要解决的问题：有一个Movie类型，由case class表示，你需要将它转换为XML：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span>(<span class="params">name: <span class="type">String</span>, year: <span class="type">Int</span>, rating: <span class="type">Double</span></span>)</span></span><br></pre></td></tr></table></figure>
<p>一个快速的、但又恶劣的解决方案是在case class里面添加toXml方法。但大多数情况下并不适用，因为转换为XML对于Movie类是一个完全的正交责任链(orthogonal responsibility)，并且不应该作为Movie类型的一部分。</p>
<p>第二种解决方案是使用对象适配器模式。定义一个通用接口XmlConverter，并使用类型参数化：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">XmlConverter</span> [<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">toXml</span></span>(a: <span class="type">A</span>): <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及为Movie实例提供一个对象适配器：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MovieXmlConverter</span> <span class="keyword">extends</span> <span class="title">XmlConverter</span>[<span class="type">Movie</span>] </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">toXml</span></span>(a: <span class="type">Movie</span>) =</span><br><span class="line">  &lt;movie&gt;</span><br><span class="line">  &lt;name&gt;&#123;a.name&#125;&lt;/name&gt;</span><br><span class="line">  &lt;year&gt;&#123;a.year&#125;&lt;/year&gt;</span><br><span class="line">  &lt;rating&gt;&#123;a.rating&#125;&lt;/rating&gt;</span><br><span class="line">  &lt;/movie&gt;.toString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MovieXmlConverter为Movie类型实现了toXml方法。为了转换Movie的一个实例为XML，你客户端要做的是：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> p = <span class="type">Movie</span>(<span class="string">&quot;Inception&quot;</span>, <span class="number">2010</span>, <span class="number">10</span>)</span><br><span class="line">logger info <span class="string">s&quot;<span class="subst">$&#123;MovieXmlConverter.toXml(p) &#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>上述实现的问题是MovieXmlConverter产生了偶然性复杂度。转换器隐藏了你正在处理的对象movie，进入toXml方法的处理仍然认为是一个优雅的处理方案。第二个问题是这个实现的刚性设计。使得它很难为Movie提供一个分割XML转换器。让我们看看如何用类型类来增进这个方案。</p>
<p>第一个类型类的作用是定义一个概念。这个概念是XML转换可以容易地被XmlConverter特质代替：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">XmlConverter</span> [<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">toXml</span></span>(a: <span class="type">A</span>): <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该特质被任何类型A所泛化。你暂时没有任何约束机制。第二个作用是根据通用算法(generic algorithm)自动传递约束逻辑。例如，你可以创建一个新的方法叫toXml，该方法接收一个类型实例，并将它转换为XML：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">toXml</span></span>[<span class="type">A</span>](a: <span class="type">A</span>)(converter: <span class="type">XmlConverter</span> [<span class="type">A</span>] ) = converter.toXml(a)</span><br></pre></td></tr></table></figure>
<p>但这并没有太大改进，因为你仍然要创建一个转换器实例，并把它传递给方法。Scala中是类型类实用的是implicit关键字。它可以使converter 参数隐式地允许Scala编译器在提供了参数，却没有找到时跳到相应的类型上：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">toXml</span></span>[<span class="type">A</span>](a: <span class="type">A</span>)(<span class="keyword">implicit</span> converter: <span class="type">XmlConverter</span>[<span class="type">A</span>]) = converter.toXml(a)</span><br></pre></td></tr></table></figure>
<p>现在你可以通过传递一个Movie实例调用toXml方法，Scala会自动提供类型相当的converter。事实上，你可以传递类型的任何实例，只要你隐式定义了相应的XmlConverter知道如何转换该类型。下面是该示例的完整代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span>(<span class="params">name: <span class="type">String</span>, year: <span class="type">Int</span>, rating: <span class="type">Double</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">XmlConverter</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">toXml</span></span>(a: <span class="type">A</span>): <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">toXml</span></span>[<span class="type">A</span>](a: <span class="type">A</span>)(<span class="keyword">implicit</span> converter: <span class="type">XmlConverter</span>[<span class="type">A</span>]) = converter.toXml(a)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Converters</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">MovieConverter</span> <span class="keyword">extends</span> <span class="title">XmlConverter</span> [<span class="type">Movie</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toXml</span></span>(a: <span class="type">Movie</span>): <span class="type">String</span> =</span><br><span class="line">      &lt;movie&gt;</span><br><span class="line">        &lt;name&gt;&#123;a.name&#125;&lt;/name&gt;</span><br><span class="line">        &lt;year&gt;&#123;a.year&#125;&lt;/year&gt;</span><br><span class="line">        &lt;rating&gt;&#123;a.rating&#125;&lt;/rating&gt;</span><br><span class="line">      &lt;/movie&gt;.toString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="type">Converters</span>._</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> p = <span class="type">Movie</span>(<span class="string">&quot;Inception&quot;</span>, <span class="number">2010</span>, <span class="number">10</span>)</span><br><span class="line">logger info <span class="string">s&quot;<span class="subst">$&#123;toXml(p)&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>你创建了一个类型类XmlConverter，以及为它提供了一个隐式定义。当使用toXml方法时，你需要确保该隐式定义在编译范围内是可用的，之后Scala编译器会做完剩余的工作。这种实现的灵活性在于，如果你想为Movie提供一个不同的XML转换，你只需要显式地将它作为参数传递给toXml方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MovieConverterWithoutRating</span> <span class="keyword">extends</span> <span class="title">XmlConverter</span> [<span class="type">Movie</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toXml</span></span>(a: <span class="type">Movie</span>): <span class="type">String</span> =</span><br><span class="line">    &lt;movie&gt;</span><br><span class="line">      &lt;name&gt;&#123;a.name&#125;&lt;/name&gt;</span><br><span class="line">      &lt;year&gt;&#123;a.year&#125;&lt;/year&gt;</span><br><span class="line">    &lt;/movie&gt;.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger info <span class="string">s&quot;<span class="subst">$&#123;toXml(p)(MovieConverterWithoutRating)&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>事实上，你也可以将MovieConverterWithoutRating隐式定义。但要确保这两个定义不能同时存在编译环境范围内，否则，将会得到一个 “ambiguous implicit values” 编译错误。为一个给定的类型使用多种隐式定义的一种方式是，在一个窄范围内导入(import)，比如方法内部。下面两个方法为Movie类型使用了不同的XML转换器：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">toXmlDefault</span></span>(a: <span class="type">Movie</span>) = &#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">Converters</span>._</span><br><span class="line">  toXml(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">toXmlSpecial</span></span>(a: <span class="type">Movie</span>) = &#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">SpecialConverters</span>._</span><br><span class="line">  toXml(a)(<span class="type">SpecialConverter</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MovieConverterWithoutRating被隐式定义在SpecialConverters对象内部。</p>
<p>类型类显得非常有用，并常见于大多数标准库中。例如，看List中的sum方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span> </span>[<span class="type">B</span> &gt;: <span class="type">A</span>] (<span class="keyword">implicit</span> num: <span class="type">Numeric</span>[<span class="type">B</span>]): <span class="type">B</span></span><br></pre></td></tr></table></figure>
<p><code>Numeric[B]</code>不是别的，就是类型类，我们运行看看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val l = List(1, 2, 3)</span></span><br><span class="line">l: List[Int] = List(1, 2, 3)</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">l.sum</span></span><br><span class="line">res0: Int = 6</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val ll = List(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span></span><br><span class="line">ll: List[java.lang.String] = List(a, b, c)</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">ll.sum</span></span><br><span class="line">&lt;console&gt;:9: error: could not find implicit value for parameter num:</span><br><span class="line">        Numeric[java.lang.String]</span><br><span class="line">        ll.sum</span><br><span class="line">        ^</span><br></pre></td></tr></table></figure>
<p>Scala库提供了<code>Numberic[Int]</code>的隐式定义，但却没有<code>Numberic[String]</code>，这就是你为什么或得到隐式编译错误的原因。类型地，Scala集合库里面定义的min方法，使用了<code>Ordering[B]</code>作为类型类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](<span class="keyword">implicit</span> cmp: <span class="type">Ordering</span>[<span class="type">B</span>]): <span class="type">A</span></span><br></pre></td></tr></table></figure>
<blockquote><h4 id="New-syntax-for-declaring-implicit-parameters"><a class="header-anchor" href="#New-syntax-for-declaring-implicit-parameters">¶</a>New syntax for declaring implicit parameters</h4>
<p>从Scala 2.8开始，使隐式参数匿名，方法或函数声明隐式参数有了更简洁的方式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">toXml</span></span>[<span class="type">A</span>: <span class="type">XmlConverter</span>](a: <span class="type">A</span>) = implicitly[<span class="type">XmlConverter</span>[<span class="type">A</span>]].toXml(a)</span><br></pre></td></tr></table></figure>
<p>使用<code>A: XmlConverter</code>，你声明toXml方法接收一个类型为<code>XmlConverter[A]</code>的隐式参数。因为隐式参数的名字不可用，你可以使用定义在scala.Predef里面的方法implicitly来获得引用隐式参数。下面是定义在scala.Predef的方法定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">implicitly</span></span>[<span class="type">T</span>](<span class="keyword">implicit</span> e: <span class="type">T</span>) = e</span><br></pre></td></tr></table></figure>
<p>为了更容易描述代码，我仍然显式地声明隐式参数。但当添加额外的参数并显得易读性差时，你可以尝试使用这个新语法。</p>
</blockquote>
<p>对于类型类的普遍困惑是，人们倾向于认为它是一个接口。接口和类型类不同的关键点是，接口专注于子类多态性(subtype polymorphism)，类型类则专注于参数多态性(parametric polymorphism)。在Java世界里面你会认为参数多态性是泛型(generics)，但更合适的名称是 <em>parametric polymorphism</em> 。另外一种区别是，子类型存在于面向对象(OOP)世界。参数多态性(parametric polymorphism)存在于函数式编程世界。事实上，类型类的概念最先发现于纯函数式编程语言Haskell。</p>
<p>类型类是模拟一个正交(orthogonal)抽象问题的灵活方式，并且不用对抽象硬连线。类型类在逆向模型(retroactive modeling)上也有帮助，因为你可以在任何时刻为一个类型添加一个类型类。唯一局限性就是类型类的实现是静态的——没有任何动态分配。这种局限的好处在于，所有隐式处理发生在编译时期，因此不会在运行期有关联消耗。类型类有了解决表述问题(expression problem)的所有东西，让我们看看它是如何处理的。</p>
<h3 id="832〖Solving-the-expression-problem-using-type-classes〗P250"><a class="header-anchor" href="#832〖Solving-the-expression-problem-using-type-classes〗P250">¶</a>8<sub>3</sub>2〖Solving the expression problem using type classes〗P250</h3>
<p>前面说到过，工资的处理由两个抽象层驱动。一是你所在的国家，二是收款方。USPayroll类看起来是：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">USPayroll</span>[<span class="type">A</span>](<span class="params">pagees: <span class="type">Seq</span>[<span class="type">A</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span> </span>= ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A类型表示收款方；它可以表示一个雇佣或者承包商。类似地，加拿大地区的薪资类看起来会像：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CanadaPayroll</span>[<span class="type">A</span>](<span class="params">payees: <span class="type">Seq</span>[<span class="type">A</span>]</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span> </span>= ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了表示薪资处理的一类，你需要定义下列特质，以及参数化区域和收款方：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.language.higherKinds</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PayrollProcessor</span>[<span class="type">C</span>[_], <span class="title">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(payees: <span class="type">Seq</span>[<span class="type">A</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C是一个高级类类型(high-kinded type)表示一个薪资类型。判断是高级类类型的依据是，他同时接收USPayroll和CanadaPayroll作为一个类型参数。A表示收款方。注意你现在还没在任何地方使用到C，除了作为一个参数类型外，像一个幻类型(phantom type)。只有当我创建了第二个类型类的构建块时才有意义，它隐式定义在PayrollProcessor特质中：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span>(<span class="params">name: <span class="type">String</span>, id: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PayrollProcessors</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">PayrollSystemWithTypeclass</span>._</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">USPayrollProcessor</span> <span class="keyword">extends</span> <span class="title">PayrollProcessor</span>[<span class="type">USPayroll</span>,<span class="type">Employee</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(payees: <span class="type">Seq</span>[<span class="type">PayrollSystemWithTypeclass</span>.<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;us employees are processed&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">CanadaPayrollProcessor</span> <span class="keyword">extends</span> <span class="title">PayrollProcessor</span>[<span class="type">CanadaPayroll</span>, <span class="type">Employee</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(payees: <span class="type">Seq</span>[<span class="type">PayrollSystemWithTypeclass</span>.<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;canada employees are processed&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意你使用了第一类型 PayrollProcessor 参数类型来标识定义所在的区域。为了使用这些隐式定义，你需要使用隐式类型参数USPayroll 和 CanadaPayroll：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">USPayroll</span>[<span class="type">A</span>](<span class="params">payees: <span class="type">Seq</span>[<span class="type">A</span>]</span>)(<span class="params">implicit processor: <span class="type">PayrollProcessor</span>[<span class="type">USPayroll</span>, <span class="type">A</span>]</span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span> </span>= processor.processPayroll(payees)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CanadaPayroll</span>[<span class="type">A</span>] (<span class="params">payees: <span class="type">Seq</span>[<span class="type">A</span>]</span>)(<span class="params">implicit processor: <span class="type">PayrollProcessor</span>[<span class="type">CanadaPayroll</span>, <span class="type">A</span>]</span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span> </span>= processor.processPayroll(payees)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段处理代码片段也证明了另外一个要点：你也可以在类定义中使用隐式参数。现在当你创建一个USPayroll 或 CanadaPayroll实例，Scala编译器将尝试为隐式参数提供值。下面是完整的代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PayrollSystemWithTypeClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span>(<span class="params">name: <span class="type">String</span>, id: <span class="type">Long</span></span>)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @tparam C 高级类类型(high-kinded types)，表示Country[US,Canada,...]</span></span><br><span class="line"><span class="comment">    * @tparam A 类型类(type classes)，表示薪资收款方</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">PayrollProcessor</span>[<span class="type">C</span>[_], <span class="title">A</span>] </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(payees: <span class="type">Seq</span>[<span class="type">A</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">USPayroll</span>[<span class="type">A</span>](<span class="params">payees: <span class="type">Seq</span>[<span class="type">A</span>]</span>)(<span class="params">implicit processor: <span class="type">PayrollProcessor</span>[<span class="type">USPayroll</span>, <span class="type">A</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span> </span>= processor.processPayroll(payees)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CanadaPayroll</span>[<span class="type">A</span>] (<span class="params">payees: <span class="type">Seq</span>[<span class="type">A</span>]</span>)(<span class="params">implicit processor: <span class="type">PayrollProcessor</span>[<span class="type">CanadaPayroll</span>, <span class="type">A</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span> </span>= processor.processPayroll(payees)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PayrollProcessors</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">PayrollSystemWithTypeClass</span>._</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">USPayrollProcessor</span> <span class="keyword">extends</span> <span class="title">PayrollProcessor</span>[<span class="type">USPayroll</span>,<span class="type">Employee</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(payees: <span class="type">Seq</span>[<span class="type">PayrollSystemWithTypeClass</span>.<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;us employees are processed&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">CanadaPayrollProcessor</span> <span class="keyword">extends</span> <span class="title">PayrollProcessor</span>[<span class="type">CanadaPayroll</span>, <span class="type">Employee</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(payees: <span class="type">Seq</span>[<span class="type">PayrollSystemWithTypeClass</span>.<span class="type">Employee</span>]): <span class="type">Either</span>[<span class="type">String</span>, <span class="type">Throwable</span>] = <span class="type">Left</span>(<span class="string">&quot;canada employees are processed&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="type">PayrollSystemWithTypeClass</span>._</span><br><span class="line"><span class="keyword">import</span> <span class="type">PayrollProcessors</span>._</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> r = <span class="type">USPayroll</span>(<span class="type">Vector</span>(<span class="type">Employee</span>(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>))).processPayroll</span><br><span class="line">logger info <span class="string">s&quot;<span class="subst">$r</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>这里再次将隐式定义分组在一起，以便于导入使用。注意当你使用实例化的USPayroll，你提供了一个Employee集合，并有Scala编译器隐式处理。在这里，隐式处理由USPayrollProcessor提供。现在，断言它是类型安全的。创建一个新的类型Contractor：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Contractor</span>(<span class="params">name: <span class="type">String</span></span>)</span></span><br></pre></td></tr></table></figure>
<p>因为在类型payee上没有严格限制(由A表示，没有任何边界约束)，你可以容易地创建一个供应商集合，并传递给USPayroll：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">USPayroll</span>(<span class="type">Vector</span>(<span class="type">Contractor</span>(<span class="string">&quot;a&quot;</span>))).processPayroll</span><br></pre></td></tr></table></figure>
<p>但在编译时，会报编译错误，因为还没有对USPayroll的Contractor类型的隐式定义。但你仍然受类型系统的保护——这非常好。</p>
<p><strong>注意</strong> 你可以在你的类型类上加<code>@implicitnotfound</code>注解，当编译器找不到该类型隐式值时将得到错误信息帮助。</p>
<p>让我们继续使用类型类(type classes)处理更多的表述问题(expression problem)。在当前设置中添加一个新类型显得有点琐屑；添加一个新类，并隐式定义薪资处理器：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PayrollSystemWithTypeClassExtension</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Contractor</span>(<span class="params">name: <span class="type">String</span></span>)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">JapanPayroll</span>[<span class="type">A</span>](<span class="params">payees: <span class="type">Vector</span>[<span class="type">A</span>]</span>) (<span class="params">implicit processor: <span class="type">PayrollProcessor</span>[<span class="type">JapanPayroll</span>, <span class="type">A</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span> </span>= processor.processPayroll(payees)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PayrollProcessorsExtension</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">PayrollSystemWithTypeClassExtension</span>._</span><br><span class="line">  <span class="keyword">import</span> <span class="type">PayrollSystemWithTypeClass</span>._</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">JapanPayrollProcessor</span> <span class="keyword">extends</span> <span class="title">PayrollProcessor</span>[<span class="type">JapanPayroll</span>, <span class="type">Employee</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(payees: <span class="type">Seq</span>[<span class="type">Employee</span>]) = <span class="type">Left</span>(<span class="string">&quot;japan employees are processed&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为供应商(contractors)提供相应的隐式定义，如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">USContractorPayrollProcessor</span> <span class="keyword">extends</span> <span class="title">PayrollProcessor</span>[<span class="type">USPayroll</span>, <span class="type">Contractor</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(payees: <span class="type">Seq</span>[<span class="type">Contractor</span>]) = <span class="type">Left</span>(<span class="string">&quot;us contractors are processed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">CanadaContractorPayrollProcessor</span> <span class="keyword">extends</span> <span class="title">PayrollProcessor</span>[<span class="type">CanadaPayroll</span>, <span class="type">Contractor</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(payees: <span class="type">Seq</span>[<span class="type">Contractor</span>]) = <span class="type">Left</span>(<span class="string">&quot;canada contractors are processed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">JapanContractorPayrollProcessor</span> <span class="keyword">extends</span> <span class="title">PayrollProcessor</span>[<span class="type">JapanPayroll</span>, <span class="type">Contractor</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processPayroll</span></span>(payees: <span class="type">Seq</span>[<span class="type">Contractor</span>]) = <span class="type">Left</span>(<span class="string">&quot;japan contractors are processed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现所有这些隐式定义，我们就可以在代码中直接执行调用：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">PayrollSystemWithTypeClassExtension</span>._</span><br><span class="line"><span class="keyword">import</span> <span class="type">PayrollProcessorsExtension</span>._</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> c = <span class="type">USPayroll</span>(<span class="type">Vector</span>(<span class="type">Contractor</span>(<span class="string">&quot;a&quot;</span>))).processPayroll</span><br><span class="line">logger info <span class="string">s&quot;<span class="subst">$c</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>你导入了所有必要的类和隐式定义，并为Japan定义了处理薪资。你再一次成功地解决了表述问题(expression problem)，这次使用的是函数式编程技术。</p>
<p>如果你是一个Java编程人员，类型类或少或多会使用到，当你熟练了它们，它们可以提供强大的逆向建模(retroactive modeling)，这意味着，你可以快速改变它们。</p>
<h3 id="8-4〖Summary〗P254"><a class="header-anchor" href="#8-4〖Summary〗P254">¶</a>8~4〖Summary〗P254</h3>
<p>这一章，在理解Scala类型系统各种应用上，是一个重要的里程碑。当你理解并探索之后，Scala类型系统帮助在构建可复用和可扩展组件上。一个好的类型系统不仅仅提供了类型安全，它也提供了足够的抽象来快速地构建组件和库。你学习了抽象类型成员(abstract type members)和自类型(self-type)注解，以及如何使用他们来构建组件。你也探索了Scala的类型类，以及如何使用它们来构建应用创建抽象。</p>
<p>编程语言中，判断该语言强弱的一个最通常方式是表述问题(expression problem)。你实现了解决表述问题(expression problem)的两种方式，清晰地证明了Scala类型系统的强大。Scala是多模式的(multiparadigm)，你同时使用了面向对象和函数式编程两种方式解决了这个问题。面向对象的方式是实现了抽象类型成员和特质。为了解决这个问题，你学习了类型类。类型类是一个强大解决在运行时的多态问题的方式。这还没有真正深入到Scala类型系统中。这章仅可能覆盖更多的内容，但我相信你的好奇心促使你探索更多的内容。</p>
<p>下一章将覆盖Scala最流行的特性：actor。Scala的actor使得构建高并发应用更容易，并一步到位(hassle-free)。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1">Benjamin C. Pierce, Types and Programming Languages, 2002, The MIT Press, <a target="_blank" rel="noopener" href="http://www.cis.upenn.edu/~bcpierce/tapl/">www.cis.upenn.edu/~bcpierce/tapl/</a>.<a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2">Martin Odersky and Lex Spoon, “The Architecture of Scala Collections,” adapted from Programming in Scala,second edition, Odersky, Spoon and Venners, Artima Inc., 2011, <a target="_blank" rel="noopener" href="http://mng.bz/Bso8">http://mng.bz/Bso8</a>.<a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3">“What are some compelling use cases for dependent method types?” Answered by Miles Sabin on stackoverflow, Oct 22, 2011, <a target="_blank" rel="noopener" href="http://mng.bz/uCj3">http://mng.bz/uCj3</a>.<a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div></div></article><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2016/10/27/scala/08-scala-components/';
var disqus_title = '第八章：构建可伸缩的、可扩展的组件';
var disqus_url = 'https://galudisu.info/2016/10/27/scala/08-scala-components/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>