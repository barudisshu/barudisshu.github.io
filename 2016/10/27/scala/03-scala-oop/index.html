<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>第三章：Scala OOP</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">第三章：Scala OOP</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2016-10-27</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/scala/">scala</a></p><p class="meta-item meta-category"><span class="meta-item-title"></span><i class="icon-bookmark"> </i><a class="category-link" href="/categories/learning/">learning</a></p></div><div class="article-content"><h4 id="主要内容："><a class="header-anchor" href="#主要内容：">¶</a>主要内容：</h4>
<ol>
<li>构建MongoDB驱动</li>
<li>case模式匹配</li>
<li>命名和默认参数</li>
</ol>
<p>上一章讲了Scala的基础部分，这章介绍Scala面向对象的特性。面向对象编程不是新鲜事物，但是Scala在面向对象基础上添加了一些新的特性。<br>
本章将使用Scala构建MongoDB的驱动。MongoDB也是可伸缩的(scalable)，基于文档的数据库。你将使用Scala面向对象构造器快速构建MongoDB驱动程序，并在此讲述每一步的概念。Scala使得面向对象得到革新，其中包括特征(trait)。特征相似与Java的半实现的抽象类(abstract classes)。本章将介绍特征在Scala程序中是如何工作的。同时，本章也将介绍容器类(case classes)，容器类对于构建不可变类是非常有用的，另外也会介绍并发和数据-对象转换。容器类是函数式编程和面向对象编程的桥梁。</p>
<span id="more"></span>
<h2 id="Building-a-Scala-MongoDB-driver-user-stories"><a class="header-anchor" href="#Building-a-Scala-MongoDB-driver-user-stories">¶</a>Building a Scala MongoDB driver: user stories</h2>
<blockquote><p>首先解析一下这个概念，顾名思义就是用户故事。这是敏捷开发中的一种模式，也叫用户案例(user case)，就是站在用户价值立场实时分析情景，只对需求作描述，不对需求作规范。</p>
</blockquote>
<p>我们思考一下，为什么要构建MongoDB的驱动?MongoDB不是已有现成的MongoDB驱动了吗?但考虑下面的user stories: As a developer, I want an easier way to connect to my MongoDB server and access document databases. As a developer, I want to query and manage documents.</p>
<p>MongoDB是一个用C++开发的数据库，具有可伸缩性、高并发、开源、模式自由的、面向文档的特性。MongoDB是一种用JSON(JavaScript Object Notation)数据格式存储的基于文档的数据库。这种模式自由的特性使得MongoDB可以存储任何类型的数据结构，因此你不需要定义你的数据库表和属性。你可以按需求任意删除属性。这种自由度是通过基于文档模式实现的。和关系型数据库不同，一个基于文档模式的记录(records)被作为一个文档存储，因此该记录可以存储任何长度、任何数量的字段。例如，一个集合(collection)中可以存储如下形式(集合在MongoDB中相当于传统RDBMS(Relational Database Management System)数据库中的表)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; name : <span class="string">&quot;Joe&quot;</span>, x : <span class="number">3.3</span>, y : [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] &#125;</span><br><span class="line">&#123; name : <span class="string">&quot;Kate&quot;</span>, x : <span class="string">&quot;abc&quot;</span> &#125;</span><br><span class="line">&#123; q : <span class="number">456</span> &#125;</span><br></pre></td></tr></table></figure>
<p>在模式自由的环境中，这里的模式(schema)更多是指应用程序，而不是数据库。和其他工具一样，模式自由的数据库有利也有弊，关键取决于你选择的解决方案。</p>
<p>在MongoDB中文档的存储格式是BSON(Binary JSON)，其他基于文档的数据库，如IBM的Lotus Notes和Amazon的SimpleDB则是使用XML结构存储。在基于Web应用程序中，JSON有一个突出的优势就是JSON文档可以非常容易地进行转换并使用。更多内容，参考<a target="_blank" rel="noopener" href="http://try.mongodb.org">http://try.mongodb.org</a>.并下载安装到本地。开启MongoDB服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/mongod</span></span><br></pre></td></tr></table></figure>
<p>开启服务之后，我们打开Shell进行数据库连接:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/mongo</span></span><br><span class="line">MongoDB shell version: 1.2.4</span><br><span class="line">url: test</span><br><span class="line">connecting to: test</span><br><span class="line">type &quot;help&quot; for help</span><br></pre></td></tr></table></figure>
<p>搭建好数据库后，我们将进入MongoDB驱动开发阶段。</p>
<h2 id="Classes-and-constructors"><a class="header-anchor" href="#Classes-and-constructors">¶</a>Classes and constructors</h2>
<p>创建一个Mongo客户端连接到服务上:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scala&gt; class MongoClient(val host:String, val port:Int)</span><br></pre></td></tr></table></figure>
<p>这看起来和Java、C#不同，不但声明了类，还声明了主构造器(primary constructor)。</p>
<p>当创建一个MongoClient类的实例时，主构造函数以重载的形式直接或间接地被调用。在Scala中，主构造器(primary constructor)是在类声明时行内出现。如本例中，构造器带有两个参数，host和port，即指定MongoDB的主机IP和端口。</p>
<p>因为所有构造器参数都是以val为前导，Scala会为每个参数创建不可变的实例。如:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val client = new MongoClient(<span class="string">&quot;127.0.0.1&quot;</span>, 123)</span></span><br><span class="line">client: MongoClient = MongoClient@561279c8</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">client.port</span></span><br><span class="line">res0: Int = 123</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">client.host</span></span><br><span class="line">res1: String = 127.0.0.1</span><br></pre></td></tr></table></figure>
<p>和Java、C#一样，Scala通过new关键字创建类的实例。不同的是，在Scala中，类的语句体是可选的，因此可以在声明类的不带语句体。如，要创建一个包含setter和getter的JavaBean，在Scala中就变得很简单了:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">class AddressBean(</span></span><br><span class="line">var address1:String,</span><br><span class="line">var address2:String,</span><br><span class="line">var city:String,</span><br><span class="line">var zipCode:Int)</span><br><span class="line">defined class AddressBean</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">var localAddress = new AddressBean(<span class="string">&quot;230 43rd street&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Columbus&quot;</span>,</span></span><br><span class="line">43233)</span><br><span class="line">localAddress: (java.lang.String, java.lang.String, java.lang.String, Int) =</span><br><span class="line">(230 43rd street,,Columbus,43233)</span><br></pre></td></tr></table></figure>
<p>如果参数是以var为前导，Scala将创建可变的变量。val和var前导都是可选的。如果两个都不填，则参数将作为私有的实例值，不能在类外部进行访问:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">class MongoClient(host:String, port:Int)</span></span><br><span class="line">defined class MongoClient</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val client = new MongoClient(<span class="string">&quot;localhost&quot;</span>, 123)</span></span><br><span class="line">client: MongoClient = MongoClient@4089f3e5</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">client.host</span></span><br><span class="line">&lt;console&gt;:7: error: value host is not a member of MongoClient client.host</span><br></pre></td></tr></table></figure>
<p>注意，当Scala创建值或者变量时，同时也将为他们创建相应的访问者，在某种程度上直接访问值。下面定义的MongoClient和之前的是等价的:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoClient</span>(<span class="params">private val _host:<span class="type">String</span>, private val _port:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">host</span> </span>= _host</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">port</span> </span>= _port</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用private的原因是Scala编译器默认不会创建访问者。val和var做的是定义一个字段和getter，var则带setter。</p>
<blockquote><p><strong>如何为类添加setter方法</strong><br>
当被定义为private类型时，如果需要添加setter方法，需要在其后添加_=.方法，如下面例子包含了getter和setter:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">var firstName:<span class="type">String</span>, var lastName:<span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">private var _age:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">age</span> </span>= _age</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">age_=</span></span>(newAge: <span class="type">Int</span>) = _age = newAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在可以创建实例并进行操作:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> p = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">&quot;Nima&quot;</span>, <span class="string">&quot;Raychaudhuri&quot;</span>, <span class="number">2</span>)</span><br><span class="line">p.age = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>赋值p.age = 3实际上相当于p.age_= (3)。当计数器遇到诸如x = e的赋值语句，它会检测是否有对应的x_=方法并进行调用。这种赋值推断(assignment interpretation)在Scala中显得很有趣，在不同的上下文中表示不同的操作。如对一个函数进行赋值f(args) = e则表示是f.update(args)。关于函数赋值，将在之后介绍。</p>
</blockquote>
<p>大多数情况下，MongoDB的默认端口是27017，那在Scala中如何定义默认IP和端口呢？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoClient</span>(<span class="params">val host:<span class="type">String</span>, val port:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">27017</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了重载构造函数，通过<code>this</code>关键字来表示当前定义方法。你不能为其构造函数指定返回类型，因为重载函数中的第一个表达式必须调用其他重载构造函数或主构造函数，因此如下声明是错误的:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoClient</span>(<span class="params">val host:<span class="type">String</span>, val port:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = &#123;</span><br><span class="line"><span class="keyword">val</span> defaultHost = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line"><span class="keyword">val</span> defaultPort = <span class="number">27017</span></span><br><span class="line"><span class="keyword">this</span>(defaultHost, defaultPort)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译时将报如下错误:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MongoClient.scala:3: error: &#x27;this&#x27; expected but &#x27;val&#x27; found.</span><br><span class="line">val defaultHost = &quot;127.0.0.1&quot;</span><br><span class="line">^</span><br><span class="line">MongoClient.scala:4: error: &#x27;(&#x27; expected but &#x27;;&#x27; found.</span><br><span class="line">val defaultPort = 27017</span><br><span class="line">^</span><br><span class="line">two errors found</span><br></pre></td></tr></table></figure>
<p>如果要在调用其他构造函数前做出一些操作将会是一个挑战，后面会通过companion object来突破这种限制。</p>
<p>连接MongoDB，你需要使用MongoDB为Java提供的驱动类<code>com.mongodb.Mongo</code>，</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoClient</span>(<span class="params">val host:<span class="type">String</span>, val port:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> underlying = <span class="keyword">new</span> <span class="type">Mongo</span>(host, port)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">27017</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> 本书使用的MongoDB驱动版本是1.10.1，更多版本信息请参考<a target="_blank" rel="noopener" href="http://www.mongodb.org/display/DOCS/Java+Language+Center">http://www.mongodb.org/display/DOCS/Java+Language+Center</a></p>
<p>因为Scala具有脚本的特性，因此你可以在类内编写像脚本一样的代码，并且会在实例创建时执行。如下面是一个打印类:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyScript</span>(<span class="params">host:<span class="type">String</span></span>) </span>&#123;</span><br><span class="line">require(host != <span class="literal">null</span>, <span class="string">&quot;Have to provide host name&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(host == <span class="string">&quot;127.0.0.1&quot;</span>) println(<span class="string">&quot;host = localhost&quot;</span>)</span><br><span class="line"><span class="keyword">else</span> println(<span class="string">&quot;host = &quot;</span> + host)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们像检验构造器的参数，我们可以在类内部这样做(通常在最前面):</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoClient</span>(<span class="params">val host:<span class="type">String</span>, val port:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">require(host != <span class="literal">null</span>, <span class="string">&quot;You have to provide a host name&quot;</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> underlying = <span class="keyword">new</span> <span class="type">Mongo</span>(host, port)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">27017</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和Java一样，Scala使用extends实现继承，如:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoClientV2</span>(<span class="params">val host:<span class="type">String</span>, val port:<span class="type">Int</span></span>)</span></span><br><span class="line"><span class="keyword">extends</span> <span class="type">Mongo</span>(host, port)&#123;</span><br><span class="line">require(host != <span class="literal">null</span>, <span class="string">&quot;You have to provide a host name&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">27017</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你同样可以在超类(super class)中定义主构造器。一个不好的地方就是，你不能向父类传递参数验证。</p>
<p><strong>注意</strong> 你不用显式继承任何类，但类默认继承了scala.AnyRef，并且scala.AnyRef是所有类型推断的基础类。</p>
<h2 id="Packaging"><a class="header-anchor" href="#Packaging">¶</a>Packaging</h2>
<p>包(package)在Scala中兼具有Java和C#两者的用法，因此，你可以这样定义:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com &#123;</span><br><span class="line">    <span class="keyword">package</span> scalainaction &#123;</span><br><span class="line">        <span class="keyword">package</span> mongo &#123;</span><br><span class="line">            <span class="keyword">import</span> com.mongodb.<span class="type">Mongo</span></span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">MongoClient</span>(<span class="params">val host:<span class="type">String</span>, val port:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">            require(host != <span class="literal">null</span>, <span class="string">&quot;You have to provide a host name&quot;</span>)</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> underlying = <span class="keyword">new</span> <span class="type">Mongo</span>(host, port)</span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">27017</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法和一下写法是等价的:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scalainaction.mongo</span><br><span class="line"><span class="keyword">import</span> com.mongodb.<span class="type">Mongo</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoClient</span>(<span class="params">val host:<span class="type">String</span>, val port:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">require(host != <span class="literal">null</span>, <span class="string">&quot;You have to provide a host name&quot;</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> underlying = <span class="keyword">new</span> <span class="type">Mongo</span>(host, port)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">27017</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，也可以使用大括号:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scalainaction.mongo &#123;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.<span class="type">Mongo</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoClient</span>(<span class="params">val host:<span class="type">String</span>, val port:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">require(host != <span class="literal">null</span>, <span class="string">&quot;You have to provide a host name&quot;</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> underlying = <span class="keyword">new</span> <span class="type">Mongo</span>(host, port)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">27017</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这的而且确会造成语法上的混乱，因此，一般都推荐使用顶部包名的方法。另外Scala的包不需要匹配目录结构，你可以任意声明多个包在同一个文件:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.persistence &#123;</span><br><span class="line"><span class="keyword">package</span> mongo &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoClient</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> riak &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RiakClient</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> hadoop &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HadoopClient</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当Scala对此进行编译时，会自动将其匹配到相应的目录中，前提是你的类是使用JVM进行编译的。</p>
<h3 id="Scala-imports"><a class="header-anchor" href="#Scala-imports">¶</a>Scala imports</h3>
<p>Scala的import和Java的相似，但是用法更加简洁，如导入com.mongodb包中的所有类，</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.mongodb._</span><br></pre></td></tr></table></figure>
<p>在Scala中，你不仅可以在开头使用import，你可以在任何地方使用import导入，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val randomValue = &#123; import scala.util.Random</span></span><br><span class="line">new Random().nextInt</span><br><span class="line">&#125;</span><br><span class="line">randomValue: Int = 1453407425</span><br></pre></td></tr></table></figure>
<p>因为import是在<code>&#123;&#125;</code>语句块内，所以<code>Random()</code>类只能在该语句块内使用。另外，由于Scala默认会自动导入scala包，所以，上述代码可以改为:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val randomValue = &#123; import util.Random</span></span><br><span class="line">new Random().nextInt</span><br><span class="line">&#125;</span><br><span class="line">randomValue: Int = 619602925</span><br></pre></td></tr></table></figure>
<p>若要引入类的成员，也可以通过<code>._</code>引入:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">import java.lang.System._</span></span><br><span class="line">import java.lang.System._</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">nanoTime</span></span><br><span class="line">res0: Long = 1268518636387441000</span><br></pre></td></tr></table></figure>
<p>其中nanoTime是System的一个方法，因此可以直接使用，这和Java的static import相似(scala没有static关键字)。因为引入是相关联的，因此也可以这样:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">import java.lang._</span></span><br><span class="line">import java.lang._</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">import System._</span></span><br><span class="line">import System._</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">nanoTime</span></span><br><span class="line">res0: Long = 1268519178151003000</span><br></pre></td></tr></table></figure>
<blockquote><p><strong>The <code>_root_</code> package in Scala</strong><br>
考虑如下两个包:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> monads &#123; <span class="class"><span class="keyword">class</span> <span class="title">IOMonad</span> &#125;</span></span><br><span class="line">    <span class="keyword">package</span> io &#123;</span><br><span class="line">    <span class="keyword">package</span> monads &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Console</span> </span>&#123; <span class="keyword">val</span> m = <span class="keyword">new</span> monads.<span class="type">IOMonad</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况，会发现编译报错，因为Console是在monads下，会报错没找到IOMonad类。为了声明一个顶层包，你可以使用<code>_root_</code>表示:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> m = <span class="keyword">new</span> _root_.monads.<span class="type">IOMonad</span></span><br></pre></td></tr></table></figure>
<p>另外需要说明的是，当你创建一个不带任何包的类或对象，他们属于一个空包。你不能导入空包，但是空包的成员是相互可见的。</p>
</blockquote>
<p>import另外一个非常有用的特性是：你可以为你引入的类创建新的名称空间，即别名。这在某些情况下可以提高可读性。如在Java中，<code>java.util.Date</code>和<code>java.sql.Date</code>具有同样的名字，这容易造成混淆，但在Scala，可以通过映射解决这个问题:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="type">Date</span></span><br><span class="line"><span class="keyword">import</span> java.sql.&#123;<span class="type">Date</span> =&gt; <span class="type">SqlDate</span>&#125;</span><br><span class="line"><span class="keyword">import</span> <span class="type">RichConsole</span>._</span><br><span class="line"><span class="keyword">val</span> now = <span class="keyword">new</span> <span class="type">Date</span></span><br><span class="line">p(now)</span><br><span class="line"><span class="keyword">val</span> sqlDate = <span class="keyword">new</span> <span class="type">SqlDate</span>(now.getTime)</span><br><span class="line">p(sqlDate)</span><br></pre></td></tr></table></figure>
<p>你甚至可以将导入的类通过占位符将其隐藏:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.&#123;<span class="type">Date</span> =&gt; _ &#125;</span><br></pre></td></tr></table></figure>
<p>这样Date类将不可见。</p>
<p>回到用户故事(user story)中，我们需要构建完整的类并添加方法:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scalainaction.mongo</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoClient</span>(<span class="params">val host:<span class="type">String</span>, val port:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">require(host != <span class="literal">null</span>, <span class="string">&quot;You have to provide a host name&quot;</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> underlying = <span class="keyword">new</span> <span class="type">Mongo</span>(host, port)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">27017</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">version</span> </span>= underlying.getVersion</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropDB</span></span>(name:<span class="type">String</span>) = underlying.dropDatabase(name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDB</span></span>(name:<span class="type">String</span>) = <span class="type">DB</span>(underlying.getDB(name))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">db</span></span>(name:<span class="type">String</span>) = <span class="type">DB</span>(underlying.getDB(name))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Objects-and-companion-objects"><a class="header-anchor" href="#Objects-and-companion-objects">¶</a>Objects and companion objects</h2>
<p>在给出DB类之前，让我们探索一下Scala的对象(objects)。Scala没有提供任何静态修改器，这样做是为了成为一门纯面向对象的编程语言的设计目标，即所有值都是对象，所有操作都是方法调用，所有变量都是对象的一个成员。如果包含static就无法成为一门纯粹的面向对象的语言，在代码中使用static会带来非常多的缺点。相反，Scala支持单例对象(singleton object)。一个单例对象限制你一个类只能有一个对象。简单实现一个单例模式可以通过如下表示:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">RichConsole</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p</span></span>(x: <span class="type">Any</span>) = println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里RichConsole是一个单例对象。对象的声明和Java的class一样，只不过是使用关键字object。若要调用方法p，你需要加类名前缀，这个你在Java或C#中调用静态方法一样:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :l <span class="type">RichConsole</span>.scala</span><br><span class="line"><span class="type">Loading</span> <span class="type">RichConsole</span>.scala...</span><br><span class="line">defined module <span class="type">RichConsole</span></span><br><span class="line">scala&gt; <span class="type">RichConsole</span>.p(<span class="string">&quot;rich console&quot;</span>)</span><br><span class="line">rich console</span><br></pre></td></tr></table></figure>
<p>你可以导入并使用Object中的所有方法:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">import</span> <span class="type">RichConsole</span>._</span><br><span class="line"><span class="keyword">import</span> <span class="type">RichConsole</span>._</span><br><span class="line">scala&gt; p(<span class="string">&quot;this is cool&quot;</span>)</span><br><span class="line"><span class="keyword">this</span> is cool</span><br></pre></td></tr></table></figure>
<p>在这里说到的DB实际上是一个对象(object)，它是一个工厂用于创建MongoDB数据库实例:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DB</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(underlying: <span class="type">MongDB</span>) = <span class="keyword">new</span> <span class="type">DB</span>(underlying)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有趣的是，当使用DB作为一个工厂对象使用时，你实际上是调用了他的一个方法，<code>DB(underlying.getDB(name))</code>，他实际上就是调用了<code>DB.apply(underlying.getDB(name))</code>。Scala提供了语法糖(syntactic sugar)，它允许你将一个对象看作是一个方法进行调用。Scala中是通过转换调用apply方法实现的，apply将匹配类或者对象中的参数。如果没有任何参数匹配apply方法，则会发生编译报错。我们注意到，一个对象总是被延迟执行的，这意味着对象是在它的第一个成员被访问时才创建。在这个例子中，这个成员就是apply。所以，即使apply方法是正确的，也要看它所使用的场景。</p>
<blockquote><p><strong>Scala的工厂模式</strong><br>
当我们讨论构造函数的时候，会发现会有诸如进程或参数校验的限制，因为Scala的构造器的第一行必须是调用其他构造函数或者是主构造器。使用Scala的object则可以很简单地解决了这个问题，因为方法apply没有这样的限制。我们以在Scala中实现工厂模式为例:<br>
你要创建多个Role类，基于这个类名你会常见合适的role实例</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(continued)</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">canAccess</span></span>(page: <span class="type">String</span>): <span class="type">Boolean</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Root</span> <span class="keyword">extends</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">canAccess</span></span>(page:<span class="type">String</span>) = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperAnalyst</span> <span class="keyword">extends</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">canAccess</span></span>(page:<span class="type">String</span>) = page != <span class="string">&quot;Admin&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Analyst</span> <span class="keyword">extends</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">canAccess</span></span>(page:<span class="type">String</span>) = <span class="literal">false</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(roleName:<span class="type">String</span>) = roleName <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;root&quot;</span> =&gt; <span class="keyword">new</span> <span class="type">Root</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;superAnalyst&quot;</span> =&gt; <span class="keyword">new</span> <span class="type">SuperAnalyst</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;analyst&quot;</span> =&gt; <span class="keyword">new</span> <span class="type">Analyst</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，object Role就相当于一个工厂一样，并创建每个实例的变量角色:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> root = <span class="type">Role</span>(<span class="string">&quot;root&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> analyst = <span class="type">Role</span>(<span class="string">&quot;analyst&quot;</span>)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在apply方法内创建了DB类的一个实例。在Scala中，class和object是可以同名的(share name)，这种共享名字的类(class)称为伴生类(companion class)，共享名字的对象(object)称为伴生对象(companion object)。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scalainaction.mongo</span><br><span class="line"><span class="keyword">import</span> com.mongodb.&#123;<span class="type">DB</span> =&gt; <span class="type">MongoDB</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DB</span> <span class="title">private</span>(<span class="params">val underlying: <span class="type">MongoDB</span></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DB</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(underlying: <span class="type">MongoDB</span>) = <span class="keyword">new</span> <span class="type">DB</span>(underlying)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，类DB的构造器被private修饰，表示不被其他伴生对象所访问。在Scala中，伴生对象(conpanion object)可以访问伴生类(companion class)的私有成员，该私有成员不能在类外部被访问。在这个例子中，通过伴生对象创建一个实例显得有点多余，但有时却非常有用，如上面提到的工厂模式。其次就是在导入MongoDB驱动类的时候，由于命名冲突的作用将MongoDB映射为DB类。提示: 伴生对象(companoin object)和伴生类(companion class)在使用时区别就是伴生对象是直接调用的，而伴生类是通过new关键字创建的。</p>
<blockquote><p><strong>Package object</strong></p>
<p>在包中，只有类、特性和对象。但通过使用包对象，你可以在包中放置任何你定义的内容。例如，你在包对象中添加一个方法，该方法将能被包中的所有成员访问。一般地，包对象的创建为同级目录的对应包文件，即package.scala。你也可以使用在包嵌套语法中，但一般不推荐:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">bar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> minimumAge = <span class="number">18</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyAge</span> </span>= &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码中，变量minimumAge和方法verifyAge将允许包bar下的所有成员访问。如下面为包内的类使用包对象的方法:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bar</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BarTender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serveDrinks</span> </span>= &#123; verifyAge; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像这种包对象的适用情景是，你需要定义包内的成员变量，而包外则通过包的接口定义。</p>
</blockquote>
<p>在MongoDB中，一个数据库是被分为多个集合(collection)和文档(document)。现在我们向DB类添加一个检索所有collection的方法:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scalainaction.mongo</span><br><span class="line"><span class="keyword">import</span> com.mongodb.&#123;<span class="type">DB</span> =&gt; <span class="type">MongoDB</span>&#125;</span><br><span class="line"><span class="keyword">import</span> scala.collection.convert.<span class="type">Wrappers</span>._</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DB</span> <span class="title">private</span>(<span class="params">val underlying: <span class="type">MongoDB</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collectionNames</span> </span>= <span class="keyword">for</span>(name &lt;- <span class="keyword">new</span></span><br><span class="line"><span class="type">JSetWrapper</span>(underlying.getCollectionNames)) <span class="keyword">yield</span> name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到JSetWrapper对象，它是一个工具类，用于将<code>java.util.Set</code>转换为Scala的set，因此这里使用了for-comprehension。Wrappers提供了Java集合到Scala集合之间的转换。下面尝试调用一下该方法:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.scalainaction.mongo._</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span> </span>= <span class="keyword">new</span> <span class="type">MongoClient</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">db</span> </span>= client.createDB(<span class="string">&quot;mydb&quot;</span>)</span><br><span class="line"><span class="keyword">for</span>(name &lt;- db.collectionNames) println(name)</span><br></pre></td></tr></table></figure>
<p>默认地，MongoDB会提供test和system.indexes这两个集合，因此上面mydb打印出这两个集合。</p>
<p>下面开始探讨一下MongoDB的CRUD(Create,Read,Update,Delete)操作。下面为完整的MongoClient.scala</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scalainaction.mongo</span><br><span class="line"><span class="keyword">import</span> com.mongodb._</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoClient</span>(<span class="params">val host:<span class="type">String</span>, val port:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">require(host != <span class="literal">null</span>, <span class="string">&quot;You have to provide a host name&quot;</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> underlying = <span class="keyword">new</span> <span class="type">Mongo</span>(host, port)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">27017</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">version</span> </span>= underlying.getVersion</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropDB</span></span>(name:<span class="type">String</span>) = underlying.dropDatabase(name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDB</span></span>(name:<span class="type">String</span>) = <span class="type">DB</span>(underlying.getDB(name))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">db</span></span>(name:<span class="type">String</span>) = <span class="type">DB</span>(underlying.getDB(name))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，你可以通过MongoClient类连接数据库了，我们还要为DB类添加相应的dropDB、createDB等方法。下面定义DB类的伴生对象:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scalainaction.mongo</span><br><span class="line"><span class="keyword">import</span> com.mongodb.&#123;<span class="type">DB</span> =&gt; <span class="type">MongoDB</span>&#125;</span><br><span class="line"><span class="keyword">import</span> scala.collection.convert.<span class="type">Wrappers</span>._</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DB</span> <span class="title">private</span>(<span class="params">val underlying: <span class="type">MongoDB</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collectionNames</span> </span>= <span class="keyword">for</span>(name &lt;- <span class="keyword">new</span></span><br><span class="line"><span class="type">JSetWrapper</span>(underlying.getCollectionNames)) <span class="keyword">yield</span> name</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DB</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(underlying: <span class="type">MongoDB</span>) = <span class="keyword">new</span> <span class="type">DB</span>(underlying)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后，我们将为其添加更多的函数和方法。</p>
<h2 id="Mixin-with-Scala-traits"><a class="header-anchor" href="#Mixin-with-Scala-traits">¶</a>Mixin with Scala traits</h2>
<p>在面向对象编程里面，一个mixin组合表示一个类可以被其他类使用并提供确定的函数。因此，在Scala中特性(traits)相当于一个添加到其他类中的抽象类，或者看作是实现了方法的接口。</p>
<p><strong>注意</strong> 在Scala中，特性(traits)和抽象类不同的是，抽象类(abstract class)可以带构造参数，但是特性(traits)不可以带任何参数。但两者都可以带类型参数。</p>
<p>第二个用户故事的需求是，你需要为你的MongoDB添加创建、删除和查询的功能。MongoDB将文档存储在集合(collection)里面，一个数据库又可以包含多个集合。因此，你需要创建一个组件用来表示集合。这个组件应该包括:从集合中检索文档，具有创建和删除文档的功能。Java的MongoDB驱动提供了DBCollection类用于操作集合，但你需要将其分为多个视图。在Scala，你可以使用特性(traits)实现。你将使用不同的特性(traits)处理不同的任务。</p>
<p>在这里，将扩展DBCollection实现三个特性: ReadOnly、Administrable和Updatable。如:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.mongodb.&#123;<span class="type">DBCollection</span> =&gt; <span class="type">MongoDBCollection</span> &#125;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.<span class="type">DBObject</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ReadOnly</span> </span>&#123;</span><br><span class="line"><span class="keyword">val</span> underlying: <span class="type">MongoDBCollection</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span> </span>= underlying getName</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fullName</span> </span>= underlying getFullName</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span></span>(doc: <span class="type">DBObject</span>) = underlying find doc</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findOne</span></span>(doc: <span class="type">DBObject</span>) = underlying findOne doc</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findOne</span> </span>= underlying findOne</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCount</span></span>(doc: <span class="type">DBObject</span>) = underlying getCount doc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的三个特性</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scalainaction.mongo</span><br><span class="line"><span class="keyword">import</span> com.mongodb.&#123;<span class="type">DBCollection</span> =&gt; <span class="type">MongoDBCollection</span> &#125;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.<span class="type">DBObject</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBCollection</span>(<span class="params">override val underlying: <span class="type">MongoDBCollection</span></span>)</span></span><br><span class="line"><span class="keyword">extends</span> <span class="type">ReadOnly</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ReadOnly</span> </span>&#123;</span><br><span class="line"><span class="keyword">val</span> underlying: <span class="type">MongoDBCollection</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span> </span>= underlying getName</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fullName</span> </span>= underlying getFullName</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span></span>(doc: <span class="type">DBObject</span>) = underlying find doc</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findOne</span></span>(doc: <span class="type">DBObject</span>) = underlying findOne doc</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findOne</span> </span>= underlying findOne</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCount</span></span>(doc: <span class="type">DBObject</span>) = underlying getCount doc</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Administrable</span> <span class="keyword">extends</span> <span class="title">ReadOnly</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drop</span></span>: <span class="type">Unit</span> = underlying drop</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropIndexes</span></span>: <span class="type">Unit</span> = underlying dropIndexes</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Updatable</span> <span class="keyword">extends</span> <span class="title">ReadOnly</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">-=</span></span>(doc: <span class="type">DBObject</span>): <span class="type">Unit</span> = underlying remove doc</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">+=</span></span>(doc: <span class="type">DBObject</span>): <span class="type">Unit</span> = underlying save doc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你使用过Ruby，你会发现它和Ruby的模组十分相似。和模组相比，特性的优点是模块化的mixin组合方式只在编译时进行校验，堆栈中发生错误将在编译是抛出。</p>
<p>下面尝试测试一下这个驱动:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.scalainaction.mongo._</span><br><span class="line"><span class="keyword">import</span> com.mongodb.<span class="type">BasicDBObject</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span> </span>= <span class="keyword">new</span> <span class="type">MongoClient</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">db</span> </span>= client.db(<span class="string">&quot;mydb&quot;</span>)</span><br><span class="line"><span class="keyword">for</span>(name &lt;- db.collectionNames) println(name)</span><br><span class="line"><span class="keyword">val</span> col = db.readOnlyCollection(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">println(col.name)</span><br><span class="line"><span class="keyword">val</span> adminCol = db.administrableCollection(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">adminCol.drop</span><br><span class="line"><span class="keyword">val</span> updatableCol = db.updatableCollection(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> doc = <span class="keyword">new</span> <span class="type">BasicDBObject</span>()</span><br><span class="line">doc.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;MongoDB&quot;</span>)</span><br><span class="line">doc.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;database&quot;</span>)</span><br><span class="line">doc.put(<span class="string">&quot;count&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> info = <span class="keyword">new</span> <span class="type">BasicDBObject</span>()</span><br><span class="line">info.put(<span class="string">&quot;x&quot;</span>, <span class="number">203</span>)</span><br><span class="line">info.put(<span class="string">&quot;y&quot;</span>, <span class="number">102</span>)</span><br><span class="line">doc.put(<span class="string">&quot;info&quot;</span>, info)</span><br><span class="line">updatableCol += doc</span><br><span class="line">println(updatableCol.findOne)</span><br><span class="line">updatableCol -= doc</span><br><span class="line">println(updatableCol.findOne)</span><br><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">100</span>) updatableCol += <span class="keyword">new</span> <span class="type">BasicDBObject</span>(<span class="string">&quot;i&quot;</span>, i)</span><br><span class="line"><span class="keyword">val</span> query = <span class="keyword">new</span> <span class="type">BasicDBObject</span></span><br><span class="line">query.put(<span class="string">&quot;i&quot;</span>, <span class="number">71</span>);</span><br><span class="line"><span class="keyword">val</span> cursor = col.find(query)</span><br><span class="line"><span class="keyword">while</span>(cursor.hasNext()) &#123;</span><br><span class="line">println(cursor.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BasicDBObject对象是一个MongoDB的map转换器，由于MongoDB是模式自由的，因此，你可以通过BasicDBObject类插入任何键值对。基本的增删改查操作是满足不了业务的需求，例如我们要提高每次访问的性能，这里使用一种称为记忆(Memoization)的技术。这里，他会记住之前的find方法，并避免重复去数据库执行。实现的方式是通过mixin组合traits。因为在Scala中traits是堆栈的，这意味着可以被其继承的traits修改或装饰。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Memoizer</span> <span class="keyword">extends</span> <span class="title">ReadOnly</span> </span>&#123;</span><br><span class="line"><span class="keyword">val</span> history = scala.collection.mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">DBObject</span>]()</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">findOne</span> </span>= &#123;</span><br><span class="line">history.getOrElseUpdate(<span class="number">-1</span>, &#123; <span class="keyword">super</span>.findOne &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">findOne</span></span>(doc: <span class="type">DBObject</span>) = &#123;</span><br><span class="line">history.getOrElseUpdate(doc.hashCode, &#123; <span class="keyword">super</span>.findOne(doc) &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法getOrElseUpdate将返回对应键的值，如果对应键不存在，它将调用第二个参数提供的方法。在这个例子中，由于不带参数，使用-1作为key。</p>
<h2 id="Class-Linearization"><a class="header-anchor" href="#Class-Linearization">¶</a>Class Linearization</h2>
<p>如果你学习过C++或Common Lisp，你就会发现特性混入类(mixin of traits)看起来和多继承一样。但问题是Scala应该如何处理多重继承的钻石问题(或称菱形缺陷，diamond problem)。</p>
<ul>
<li>
<p>什么是混入(mixin)<br>
混入是一种组合的抽象类，主要用于多继承上下文中为一个类添加多个服务，多重继承将多个 mixin 组合成你的类。例如，如果你有一个类表示“马”，你可以实例化这个类来创建一个“马”的实例，然后通过继承像“车库”和“花园”来扩展它，使用 Scala 的写法就是：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myHouse = <span class="keyword">new</span> <span class="type">House</span> <span class="keyword">with</span> <span class="type">Garage</span> <span class="keyword">with</span> <span class="type">Garden</span></span><br></pre></td></tr></table></figure>
<p>从 mixin 继承并不是一个特定的规范，这只是用来将各种功能添加到已有类的方法。在 OOP 中，有了mixin，你就有通过它来提升类的可读性。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): unit = &#123;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">Iter</span> <span class="keyword">extends</span> <span class="title">StringIterator</span>(<span class="params">args(0</span>))</span></span><br><span class="line">		<span class="keyword">with</span> <span class="type">RichIterator</span>[char]</span><br><span class="line">		<span class="keyword">val</span> iter = <span class="keyword">new</span> <span class="type">Iter</span></span><br><span class="line">		iter foreach <span class="type">System</span>.out.println</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如Iter类通过RichIterator和StringIterator这两个父类混入构成，第一个父类仍然称为超类(superclass)，第二个父类则称为混入类(mixin)。</p>
</li>
<li>
<p>多重继承的钻石问题<br>
又叫菱形问题(有时叫做“致命的死钻石”deadly diamond of death)，描述的是B和C继承自A，D继承自B和C，如果A有一个方法被B和C重载，而D不对其重载，那么D应该实现谁的方法，B还是C？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   A</span><br><span class="line"> ↗ ↖</span><br><span class="line">B     C</span><br><span class="line"> ↖ ↗</span><br><span class="line">   D</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Scala是通过类的全序化(Class Linearization)，或称作类的线性化。线性化指出一个类的祖先类是一条线性路径的，包括超类(superclass)和特性(traits)。它通过两步来处理方法调用的问题:<br>
- 使用右孩子优先的深度优先遍历搜索(right-first,depth-first search)算法进行搜索。<br>
- 遍历得到的结构层次中，保留最后一个元素，其余删除。</p>
<ul>
<li>
<p>JVM上的trait类<br>
Scala编译器上生成的class文件取决于你如何定义。当你定义一个只包含方法声明而不包含方法体的trait类，他会编译成一个Java接口。你可以使用<code>javap –c &lt;class file name&gt;</code>查看。例如，trait Empty{def e:Int}会产生如下的类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Empty</span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">e</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果trait声明了具体的方法或代码，Scala会生成两个类:一个接口类和一个包含代码的新类。当一个类继承这个trait时，trait中声明的变量将被复制到这个类文件中，而定义在trait中的方法作为这个继承类的外观模式的方法。这个类调用这个方法时，将调用新类中的对应方法。</p>
</li>
</ul>
<h2 id="Stackable-traits"><a class="header-anchor" href="#Stackable-traits">¶</a>Stackable traits</h2>
<p>现在回顾一下，通过ReadOnly特性作为接口实现，通过Updatable和Administrable实现扩展，通过Memoizer实现方法重载，trait这种可堆叠的特征使得在组件重构和行为修改上显得非常方便。现在来看看另外一个特征。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">LocaleAware</span> <span class="keyword">extends</span> <span class="title">ReadOnly</span> </span>&#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">findOne</span></span>(doc: <span class="type">DBObject</span>) = &#123;</span><br><span class="line">doc.put(<span class="string">&quot;locale&quot;</span>, java.util.<span class="type">Locale</span>.getDefault.getLanguage)</span><br><span class="line"><span class="keyword">super</span>.findOne(doc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">find</span></span>(doc: <span class="type">DBObject</span>) = &#123;</span><br><span class="line">doc.put(<span class="string">&quot;locale&quot;</span>, java.util.<span class="type">Locale</span>.getDefault.getLanguage)</span><br><span class="line"><span class="keyword">super</span>.find(doc)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LocaleAware重载中实现了super的findOne方法，这意味着下面两个表达式是等价的:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">DBCollection</span>(collection(name)) <span class="keyword">with</span> <span class="type">Memoizer</span> <span class="keyword">with</span> <span class="type">LocaleAware</span></span><br><span class="line"><span class="keyword">new</span> <span class="type">DBCollection</span>(collection(name)) <span class="keyword">with</span> <span class="type">LocaleAware</span> <span class="keyword">with</span> <span class="type">Memoizer</span></span><br></pre></td></tr></table></figure>
<p>因为Memoizer和LocaleAware的findOne都实现了super方法，由于super是动态调用的，这意味着，Memoizer和LocaleAware中的super.findOne方法并没有马上执行，而是先根据有孩子优先的深度遍历顺序先执行findOne里面的方法，最后才执行ReadOnly里面的方法。</p>
<ul>
<li>ScalaObject trait<br>
在讨论类的全序列化时，并没有给出完整的图例。实际上，Scala会在最后一个混入类中插入scala.ScalaObject。UpdatableCollection的完整序列化顺序是:<br>
<code>UpdatableCollection -&gt; Memoizer -&gt; Updatable -&gt; DBCollection -&gt; ReadOnly -&gt; ScalaObject -&gt; AnyRef -&gt; Any</code><br>
在Scala2.8之前，ScalaObject用于向$tag的正则匹配提供方法，但从Scala2.8开始ScalaObject将作为一个空的标记trait。</li>
</ul>
<h2 id="Case-class"><a class="header-anchor" href="#Case-class">¶</a>Case class</h2>
<p>case class 是一种使用case关键创建的特殊类。当Scala编译器看到一个case class时，它会自动生成样板代码而不用自己手动编写。如我们要创建一个Person类:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash"><span class="keyword">case</span> class Person(firstName:String, lastName:String)</span></span><br><span class="line">defined class Person</span><br></pre></td></tr></table></figure>
<p>在这个例子中，你创建了一个Person 样本类并包含参数。如果一个类的前缀是case关键字，则它会自动完成下面的工作:</p>
<ul>
<li>所有参数前缀用val修饰，使它们作为public成员。但仍然不能对其进行直接方法，若要访问，需要通过访问器(accessors)。</li>
<li>根据参数自动实现equals和hashCode方法。</li>
<li>编译器会自动实现toString方法，并返回类名和参数。</li>
<li>所有case class都有一个copy方法用于该类实例的复制。</li>
<li>伴生对象(companion object)被创建并提供apply方法，并且该方法参数和该case class参数一致。</li>
<li>编译器会添加一个unapply方法，该方法将用于正则匹配中的类名提取器中。</li>
<li>默认的实现将提供了序列化。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val me = Person(<span class="string">&quot;Nilanjan&quot;</span>, <span class="string">&quot;Raychaudhuri&quot;</span>)</span></span><br><span class="line">me: Person = Person(Nilanjan,Raychaudhuri)</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val myself = Person(<span class="string">&quot;Nilanjan&quot;</span>, <span class="string">&quot;Raychaudhuri&quot;</span>)</span></span><br><span class="line">myself: Person = Person(Nilanjan,Raychaudhuri)</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">me.equals(myself)</span></span><br><span class="line">res1: Boolean = true</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">me.hashCode</span></span><br><span class="line">res2: Int = 1688656232</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">myself.hashCode</span></span><br><span class="line">res4: Int = 1688656232</span><br></pre></td></tr></table></figure>
<p>在Java中，想想我们创建了多少个DTO(Data transfer object)，而这些对象仅仅是数据转换的访问器！Scala中的样本类使得对象的访问变得容易了，并且自动为我们提供了equals和hasCode方法，这样再也不用写包含setter和getter的JavaBean了。<br>
<strong>注意</strong> 如果你想要同时实现访问器和修改器，你可以在样本类参数前面使用var关键字修饰。Scala中默认是通过val修饰参数的，并且推荐这样做。</p>
<p>和其他类一样，样本类(case class)可以继承其他类，包括trait和case class自身。当你声明一个abstract case class时，Scala不会在伴生对象(companion object)中生成apply方法。这意味着你不能创建一个抽象类的实例，但你可以创建单例的、序列化的case object，如:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Boolean</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Yes</span> <span class="keyword">extends</span> <span class="title">Boolean</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">No</span> <span class="keyword">extends</span> <span class="title">Boolean</span></span></span><br></pre></td></tr></table></figure>
<p>在网络传输中，Scala的case class和case object是非常容易进行消息传送的。这将在Scala actors中介绍讲到。<br>
<strong>注意</strong> 从Scala2.8开始，不带参数列表的case class是不赞成的(deprecated)。如果需要，你可以声明你的case class不带任何参数，但要使用()代替。</p>
<p>下面讲述case class在MongoDB中如何使用。前面主要实现了find方法，MongoDB支持多条件查询选项如Sort、Skip和Limt下面通过case class和模式匹配实现。首先定义选项查询支持:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">QueryOption</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">NoOption</span> <span class="keyword">extends</span> <span class="title">QueryOption</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Sort</span>(<span class="params">sorting: <span class="type">DBObject</span>, anotherOption: <span class="type">QueryOption</span></span>)</span></span><br><span class="line"><span class="keyword">extends</span> <span class="type">QueryOption</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Skip</span>(<span class="params">number: <span class="type">Int</span>, anotherOption: <span class="type">QueryOption</span></span>)</span></span><br><span class="line"><span class="keyword">extends</span> <span class="type">QueryOption</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Limit</span>(<span class="params">limit: <span class="type">Int</span>, anotherOption: <span class="type">QueryOption</span></span>)</span></span><br><span class="line"><span class="keyword">extends</span> <span class="type">QueryOption</span></span><br></pre></td></tr></table></figure>
<p>这里你创建了四个选项: Sort、Skip、Limit和NoOption，每个查询选项可以包含其他查询选项。注意到，所有查询选项都继承了QueryOption并使用sealed修饰。关于修改器的内容将在后面阐述。sealed修改器会阻止除在同一文件内的其他所有对象的继承。<br>
下面实现Query查询类:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Query</span>(<span class="params">q: <span class="type">DBObject</span>, option: <span class="type">QueryOption</span> = <span class="type">NoOption</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort</span></span>(sorting: <span class="type">DBObject</span>) = <span class="type">Query</span>(q, <span class="type">Sort</span>(sorting, option))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">skip</span></span>(skip: <span class="type">Int</span>) = <span class="type">Query</span>(q, <span class="type">Skip</span>(skip, option))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">limit</span></span>(limit: <span class="type">Int</span>) = <span class="type">Query</span>(q, <span class="type">Limit</span>(limit, option))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，QueryOption默认是NoOption，则可以通过以下形式调用</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rangeQuery = <span class="keyword">new</span> <span class="type">BasicDBObject</span>(<span class="string">&quot;i&quot;</span>, <span class="keyword">new</span> <span class="type">BasicDBObject</span>(<span class="string">&quot;$gt&quot;</span>, <span class="number">20</span>))</span><br><span class="line"><span class="keyword">var</span> richQuery = <span class="type">Query</span>(rangeQuery).skip(<span class="number">20</span>).limit(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>这里当第二个参数未指定时，它将使用一个默认的参数值。当我们创建一个case class对象实例时，我们不需要通过new关键字创建，因为他会自动创建伴生对象。现在可以通过下面的形式调用Query对象。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span> </span>(query: <span class="type">Query</span>) = &#123; <span class="string">&quot;...&quot;</span> &#125;</span><br></pre></td></tr></table></figure>
<p>下面讲解case class如何实现模式匹配功能:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash"><span class="keyword">case</span> class Person(firstName:String, lastName: String)</span></span><br><span class="line">defined class Person</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val p = Person(<span class="string">&quot;Matt&quot;</span>, <span class="string">&quot;vanvleet&quot;</span>)</span></span><br><span class="line">p: Person = Person(Matt,vanvleet)</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">p match &#123;</span></span><br><span class="line">case Person(first, last) =&gt; println(&quot;&gt;&gt;&gt;&gt; &quot; + first + &quot;, &quot; + last)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt; Matt, vanvleet</span></span><br></pre></td></tr></table></figure>
<p>看看模式匹配是如何提取Person中的first和last的。这里通过变量值的匹配来获取first和last的值。在后台，Scala处理这种匹配模式是通过调用一个unapply方法。如果你手动输入伴生对象的代码，它实际上是如下形式:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(firstName:<span class="type">String</span>, lastName:<span class="type">String</span>) = &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="type">Person</span>(firstName, lastName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(p:<span class="type">Person</span>): <span class="type">Option</span>[(<span class="type">String</span>, <span class="type">String</span>)] =</span><br><span class="line"><span class="type">Some</span>((p.firstName, p.lastName))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中,apply方法用于case class创建一个实例时进行调用。方法unapply只有在使用模式匹配中被调用。典型地，方法unapply用于解封case实例并返回case class的元素。Option类型将在下一章详细阐述。<br>
<strong>注意</strong> 取代unapply方法的另一个方法unapplySeq用于生成case class中参数重复的情况，这将在下一章讨论。</p>
<p>在第二章中没有提及到for-comprehensions如何使用模式匹配，下面讨论一下如何在for表达式中使用模式匹配:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val people = List(</span></span><br><span class="line">| Person(&quot;Simon&quot;, &quot;kish&quot;),</span><br><span class="line">| Person(&quot;Phil&quot;, &quot;Marzullo&quot;),</span><br><span class="line">| Person(&quot;Eric&quot;, &quot;Weimer&quot;)</span><br><span class="line">| )</span><br><span class="line">people: List[Person] = List(Person(Simon,kish), Person(Phil,Marzullo),</span><br><span class="line">Person(Eric,Weimer))</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash"><span class="keyword">for</span>(Person(first, last) &lt;- people) yield first + <span class="string">&quot;,&quot;</span> + last</span></span><br><span class="line">res12: List[java.lang.String] =</span><br><span class="line">List(Simon,kish, Phil,Marzullo, Eric,Weimer)</span><br></pre></td></tr></table></figure>
<p>你将在本书多处看到模式匹配和提取器的例子。</p>
<ul>
<li>公共参数和模式匹配<br>
模式匹配存在于函数式编程语言中，但不在OOP编程中。从面向对象的角度看模式匹配相当于观察者模式，模式匹配不能扩展，并打破了封装。<br>
首先，相比观察者模式，模式匹配减少了大量的样板代码，其次模式匹配不仅可以匹配基本数据类型，还可以匹配到更多复杂的类型。另外，case class的匹配仅仅是通过构造器的参数提供匹配，这样，你就不需要暴露隐藏的字段，并确保封装。</li>
</ul>
<h2 id="Named-and-default-arguments-and-copy-constructors"><a class="header-anchor" href="#Named-and-default-arguments-and-copy-constructors">¶</a>Named and default arguments and copy constructors</h2>
<p>主要是三部分：命名参数，默认参数和构造器复制</p>
<ul>
<li>命名参数<br>
首先观看一下代码:</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash"><span class="keyword">case</span> class Person(firstName:String, lastName:String)</span></span><br><span class="line">defined class Person</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val p = Person(<span class="string">&quot;lastname&quot;</span>, <span class="string">&quot;firstname&quot;</span>)</span></span><br><span class="line">p: Person = Person(lastname,firstname)</span><br></pre></td></tr></table></figure>
<p>不幸的是，两个参数都有相同的参数类型，即都是String类型，并且Scala编译器在编译期间不会检测错误。不过，你可以通过指定命名类型来避免这个问题:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val p = Person(lastName = <span class="string">&quot;lastname&quot;</span>, firstName = <span class="string">&quot;firstname&quot;</span>)</span></span><br><span class="line">p: Person = Person(firstname,lastname)</span><br></pre></td></tr></table></figure>
<p>这样，使用名称参数后就不用顾虑参数的顺序问题，这有利不避免不定参数和trait重构的情况，因此，如下写法等价:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val p = Person(firstName = <span class="string">&quot;firstname&quot;</span>, <span class="string">&quot;lastname&quot;</span>)</span></span><br><span class="line">p: Person = Person(firstname,lastname)</span><br></pre></td></tr></table></figure>
<p>下面看看如下代码:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">trait Person &#123; def grade(years: Int): String &#125;</span></span><br><span class="line">defined trait Person</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">class SalesPerson extends Person &#123; def grade(yrs: Int) = <span class="string">&quot;Senior&quot;</span> &#125;</span></span><br><span class="line">defined class SalesPerson</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val s = new SalesPerson</span></span><br><span class="line">s: SalesPerson = SalesPerson@42a6cdf5</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">s.grade(yrs=1)</span></span><br><span class="line">res17: java.lang.String = Senior</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">s.grade(years=1)</span></span><br><span class="line">&lt;console&gt;:12: error: not found: value years</span><br><span class="line">s.grade(years=1)</span><br><span class="line">^</span><br></pre></td></tr></table></figure>
<p>编译不通过，因为years不是SalesPerson的实例，如果你强制转换为Person，你可以使用命名参数。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val s: Person = new SalesPerson</span></span><br><span class="line">s: Person = SalesPerson@5418f143</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">s.grade(years=1)</span></span><br><span class="line">res19: String = Senior</span><br></pre></td></tr></table></figure>
<p>这里的命名参数实际上相当于一个表达式或者是一个方法或代码块，每次该方法被调用时，这个表达式就被执行:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">s.grade(years=&#123;val x = 10; x + 1&#125;)</span></span><br><span class="line">res20: String = Senior</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>默认参数<br>
默认参数使用<code>arg:Type=expression</code>形式表示，当使用默认参数时，expression将被调用执行。</p>
</li>
<li>
<p>copy方法<br>
从Scala2.8开始，所有case class将附加提供一个copy方法用于修改类的实例。在对象成员同名或者父级对象同名的情况下不会生成copy方法，它用于覆盖指定构造器参数的情况。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val skipOption = Skip(10, NoOption)</span></span><br><span class="line">skipOption: Skip = Skip(10,NoOption())</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val skipWithLimit = skipOption.copy(anotherOption = Limit(10,</span></span><br><span class="line">NoOption))</span><br><span class="line">skipWithLimit: Skip = Skip(10,Limit(10,NoOption))</span><br><span class="line">实际上，方法copy自动生成代码为如下形式:</span><br><span class="line">case class Skip(number: Int, anotherOption: QueryOption)</span><br><span class="line">extends QueryOption &#123;</span><br><span class="line">def copy(number: Int = number,</span><br><span class="line">anotherOption: QueryOption = anotherOption) = &#123;</span><br><span class="line">Skip(number, anotherOption)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当copy方法不指定参数时，它将等同于自身:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">Skip(10, NoOption) == Skip(10, NoOption).copy()</span></span><br><span class="line">res22: Boolean = true</span><br></pre></td></tr></table></figure>
<p>在Scala中，==和equals方法是等价的。</p>
<h2 id="Modifiers"><a class="header-anchor" href="#Modifiers">¶</a>Modifiers</h2>
<p>修饰器，常见的就是private和protected，和Java一样，用于修饰访问范围，Scala不限于这些修饰器，并带来新的特性。<br>
private修改器可以用于任何定义中，使用private意味着访问只能在闭包、伴生类或伴生对象中。在Scala中，你可以通过包名或者一个类进行限定。如:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> outerpkg.innerpkg</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span>[<span class="type">Outer</span>] <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>() = <span class="string">&quot;This is f&quot;</span></span><br><span class="line"><span class="keyword">private</span>[innerpkg] <span class="function"><span class="keyword">def</span> <span class="title">g</span></span>() = <span class="string">&quot;This is g&quot;</span></span><br><span class="line"><span class="keyword">private</span>[outerpkg] <span class="function"><span class="keyword">def</span> <span class="title">h</span></span>() = <span class="string">&quot;This is h&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里方法f可以出现在Outer类的任何地方；方法g可以在outerpkg.innerpkg任何地方访问；方法h可以出现在outerpkg以及它的子包的任何地方。<br>
在Scala中可以通过this:private[this]进行限制，在这里表示object private。对象私有表示它只能在对象内部进行访问。当成员用private修饰时，这称为类私有化(class-private)。</p>
<p>类似地，protected表示伴生类和子类访问权限，也可以修饰package、class和this。默认地，如果你不是使用任何修改器，则表示它是public的。但Scala没有public这个修改器。<br>
和Java一样，Scala中提供了override重构修改器，不同的是Scala中的override是强制性的，这意味着，被重构的父类对象的方法应该是具体的方法，如下面写法会发生编译错误:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">DogMood</span></span>&#123;<span class="function"><span class="keyword">def</span> <span class="title">greet</span></span>()&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">AngryMood</span> <span class="keyword">extends</span> <span class="title">DogMood</span></span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">greet</span></span>() = &#123;</span><br><span class="line">    println(<span class="string">&quot;bark&quot;</span>)</span><br><span class="line">    <span class="keyword">super</span>.greet()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为DogMood中的greet是抽象的，在AngryMood中通过<code>super.greet()</code>调用了抽象的父类方法，但是override中的greet()方法是具体的，因此会发生编译错误。因此，这里的override需要和abstract组合使用:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">AngryMood</span> <span class="keyword">extends</span> <span class="title">DogMood</span></span>&#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">greet</span></span>() = &#123;</span><br><span class="line">    println(<span class="string">&quot;bark&quot;</span>)</span><br><span class="line">    <span class="keyword">super</span>.greet()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Scala中还提供了一个新的仅用于类定义的修改器sealed(密封的)，它和final有点不同；final中定义的类不能被子类重载，但是sealed定义的类，只要是在同一个文件就可以实现重构，因此可以这样定义:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">QueryOption</span></span></span><br></pre></td></tr></table></figure>
<p>可以可以达到QueryOption只能被其子类继承而不能被其他对象继承。</p>
<h2 id="Value-classes-objects-on-a-diet"><a class="header-anchor" href="#Value-classes-objects-on-a-diet">¶</a>Value classes: objects on a diet</h2>
<p>从Scala2.10版本开始，Scala允许一种继承于AnyVal的值类(value class)，当然也可以是case class类，它是一个新的机制用于避免运行时分配对象。创建一个值类，你需要遵循某些规则:</p>
<ul>
<li>这个类至少要有一个val参数（vars不允许）。</li>
<li>参数类型不应该是值类。</li>
<li>不能有任何附加的构造器。</li>
<li>只能用def定义对象的成员，不能有val或var。</li>
<li>该类不能继承任何trait，只能是全局的trait（如AnyVal）。<br>
Scala对于该类有如此多的限制，为什么还需要值类(value class)？它允许你在运行时添加方法但又不创建实例，如:</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span>(<span class="params">val name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">AnyVal</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">up</span> </span>= name.toUpperCase</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类Wrapper有一个自定义参数name，并暴露了up()方法，下面创建一个Wrapper实例并调用这个方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> w = <span class="keyword">new</span> <span class="type">Wrapper</span>(<span class="string">&quot;hey&quot;</span>)</span><br><span class="line">w.up</span><br></pre></td></tr></table></figure>
<p>上述调用只有在编译时才生效。而在运行时这个表达式实际上等效于调用了一个对象的静态方法:Wrapper.up<img src="https://math.now.sh?inline=extendsion%28%22hey%22%29%E3%80%82%E9%82%A3%E4%B9%88%E5%9C%A8%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F%0A%E5%9C%A8Scala%E5%90%8E%E5%8F%B0%E7%BC%96%E8%AF%91%E6%97%B6%E4%BC%9A%E4%B8%BA%E5%80%BC%E7%B1%BB%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B9%B6%E5%9C%A8%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1%E5%86%85%E6%94%B9%E7%BA%BF(rerouted)%E5%80%BC%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95w.up()%E4%B8%BAup" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>extension方法。方法&quot;<img src="https://math.now.sh?inline=extension%22%E4%B8%BA%E5%AF%B9%E5%BA%94%E4%BC%B4%E7%94%9F%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E5%90%8D%E7%9A%84%E5%90%8E%E7%BC%80%E3%80%82%E4%BD%86%E6%98%AF%E6%96%B9%E6%B3%95%E4%BD%93up" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>extension中的内容和up()方法体完全一模一样，因此，Wrapper值类的等效伴生对象为:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">up$extension</span></span>(_name: <span class="type">String</span>) = _name.toUpperCase</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>规定！一个值类只能继承一个通用特质(universal trait)，并且该特质是继承自Any的（特质默认是继承自AnyDef的）。通用特质只能有方法定义不能包含初始代码。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Printable</span> <span class="keyword">extends</span> <span class="title">Any</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p</span></span>() = println(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span>(<span class="params">val name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">AnyVal</span> <span class="keyword">with</span> <span class="title">Printable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">up</span></span>() = name.toUpperCase</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">val</span> w = <span class="type">Wrapper</span>(<span class="string">&quot;Hey&quot;</span>)</span><br><span class="line">w.p()</span><br></pre></td></tr></table></figure>
<p>无论如何，通过值类为存在的类型添加附加的方法是一个非常好的方法。我们会在本书后面看到关于这方面更多的例子。</p>
<h2 id="Implicit-conversion-with-implicit-classes"><a class="header-anchor" href="#Implicit-conversion-with-implicit-classes">¶</a>Implicit conversion with implicit classes</h2>
<p>隐式转换是一种传入一个类型的参数返回另外一种类型参数的方法。例如下面例子将Double类转换为Int:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val someInt: Int = 2.3</span></span><br><span class="line">&lt;console&gt;:7: error: type mismatch;</span><br><span class="line">found : Double(2.3)</span><br><span class="line">required: Int</span><br><span class="line">val someInt: Int = 2.3</span><br><span class="line">^</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">def double2Int(d: Double): Int = d.toInt</span></span><br><span class="line">double2Int: (d: Double)Int</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val someInt: Int = double2Int(2.3)</span></span><br><span class="line">someInt: Int = 2</span><br></pre></td></tr></table></figure>
<p>通常你不能显式地将Double类转换为Int类型，但这里我们可以使用double2Int方法明确地将Double转换为Int类型。我们可以使用implicit关键字进行隐式转换:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> double2Int(d: <span class="type">Double</span>): <span class="type">Int</span> = d.toInt</span><br></pre></td></tr></table></figure>
<p>隐式转换的特点是编译器会找到合适的转换器并进行调用:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val someInt: Int = 2.3</span></span><br><span class="line">&lt;console&gt;:7: error: type mismatch;</span><br><span class="line">found : Double(2.3)</span><br><span class="line">required: Int</span><br><span class="line">val someInt: Int = 2.3</span><br><span class="line">^</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">implicit def double2Int(d: Double): Int = d.toInt</span></span><br><span class="line">warning: there were 1 feature warnings; re-run with -feature for details</span><br><span class="line">double2Int: (d: Double)Int</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val someInt: Int = 2.3</span></span><br><span class="line">someInt: Int = 2</span><br></pre></td></tr></table></figure>
<p>在Scala中，当编译器解析到一个类型错误的时候，它并没有马上退出；实际上，它会查找任何满足这个错误的隐式转换。因此，在这个例子中，double2Int是用于将Double转换为Int的，表达式会被编译器重写:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> someInt: <span class="type">Int</span> = double2Int(<span class="number">2.3</span>)</span><br></pre></td></tr></table></figure>
<p>这个转换发生在编译期间，如果没有找到合适的转换方法，编译器则会抛出一个编译异常。另外，如果转换方法冲突也会抛出一个异常。例如，有多于一个隐式转换器被匹配到，相比其他动态语言Scala的隐式转换只在编译期抛出错误信息，因此它是安全的。下面讨论一下隐式转换器的用法:<br>
隐式转换器一个普遍的用法就是对存在的数据类型添加扩展方法，如，我们知道可以用如下方法创建一个范围:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> oneTo10 = <span class="number">1</span> to <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>但是，如果我们要创建一个<code>--&gt;</code>方法来表示1到10的范围怎么实现？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> oneTo10 = <span class="number">1</span> --&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过两步进行</p>
<p>①创建一个类型实现了Int类型的<code>--&gt;</code>方法<br>
②提供一个隐式转换器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">class RangeMaker(left: Int) &#123;</span></span><br><span class="line">| def --&gt;(right: Int) = left to right</span><br><span class="line">| &#125;</span><br><span class="line">defined class RangeMaker</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val range: Range = new RangeMaker(1).--&gt;(10)</span></span><br><span class="line">range: Range = Range(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</span><br></pre></td></tr></table></figure>
<p>现在只需要再定义一个隐式转换器即可</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">implicit def int2RangeMaker(left: Int) = new RangeMaker(left)</span></span><br></pre></td></tr></table></figure>
<p>当我们使用<code>val oneTo10 = 1 --&gt; 10</code>时，它实际上隐式调用了<code>new RangeMaker(1).--&gt;(10)</code>方法进行操作<br>
另外一种比较便捷的方法是使用implicit class修改器（或称作修饰符）实现</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implicit class RangeMaker(left: Int) &#123;</span><br><span class="line">def --&gt;(right: Int): Range = left to right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，它和上面的实现形式是一样的，Scala编译器会将implicit class进行“拖糖”，即将其分解为一般类和隐式转换方法。注意隐式类必须要有一个带一个参数的主构造器（那是当然的，不然如何实现转换）。<br>
我们注意到，上面的例子中，隐式转换是在编译期发生的，这意味着在运行期每实现一个隐式转换就会创建一个隐式转换类的一个实例，这是我们不希望看到的，幸运的是，前面介绍到，我们可以创建值类:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">RangeMaker</span>(<span class="params">val left: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">AnyVal</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">--&gt;</span></span>(right: <span class="type">Int</span>): <span class="type">Range</span> = left to right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，隐式转换就变得非常强大，但过度使用会减少代码的可读性和基础代码的维护性。</p>
<h2 id="Scala-class-hierarchy"><a class="header-anchor" href="#Scala-class-hierarchy">¶</a>Scala class hierarchy</h2>
<p>在3.3小节介绍过Scala的类层次结构。层次结构中的根类为scala.Any，其他所有类直接或间接继承该类。该类定义了两个子类，分别是AnyVal和AnyDef，在主系统(JVM或CLR)中，一个对象的所有值都是AnyDef的子类。其中，所有用户定义的Scala类继承自特质scala.ScalaObject，AnyDef是java.lang.Object（Java）和system.Object（C#）的映射。<br>
子类AnyVal在主系统中不作为一个对象表示。但是在Scala中，Everything is Object，这不是矛盾？的确在Scala中所有事物都是对象，但不在主系统范围(JVM或CLR)。当Scala编译成Java字节码时，它会使用Java的基础类行，而不是封装类型，因为这样更加高效，而当需要被Scala使用时则转换为对象。<br>
实际上Scala有个views隐式类型，它是一个转换器用于将Char，Int，Long进行相互转换。在之后将会介绍到隐式函数。<br>
Scala.Null是所有参考类型的子类，也是null唯一的实例参考。所以创建一个null实例的唯一方法就是指定它的类型:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val x: Null = null</span></span><br><span class="line">x: Null = null</span><br></pre></td></tr></table></figure>
<p>因为Null对象是AnyRef的子类，所以不能将其标识为值类型，否则将抛出异常</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val x: Int = null</span></span><br><span class="line">&lt;console&gt;:8: error: type mismatch;</span><br><span class="line">found : Null(null)</span><br><span class="line">required: Int</span><br><span class="line">val x: Int = null</span><br></pre></td></tr></table></figure>
<p>另外，scala.Nothing是Scala层次结构的最后一个子类，它是所有类的子类，但是你不能创建scala.Nothing的实例，在Scala中没有该类型的实例。在第四章将介绍到更多关于Nothing的解决复杂的问题。<br>
<img src="/img/scala-in-action/chapter3/scala-class-hierarchy.png" alt="Class hierarchy of Scala with subtypes and views"></p>
<h2 id="Summary"><a class="header-anchor" href="#Summary">¶</a>Summary</h2>
<p>本章介绍了比较多的内容，包括Scala增强的OOP技术，并介绍了命名和默认参数；介绍了混入和类组合结构；介绍了case class和value class，以及如何通过case class实现可变参数，你将在后面章节的Actors和concurrency使用到更多case class，同时，你也学习了单例对象和伴生对象如何在Scala中使用。<br>
在本章最后，我们探索了Scala的类层次结构和一些重要的类，这部分内容将有助你更容易入手Scala文档并库。<br>
本章只介绍了一些基础，你会在第7章重新开始面向对象的概念，并接触到更多抽象的技术。<br>
记住，一个是你熟悉的好方法就是进入到REPL环境并尝试所有的特性和功能。行动才是学习Scala最快捷的方法。下一章将开始介绍Scala多样的函数式接口。</p>
</div></article><nav class="article-nav"><div class="article-nav-prev">🔙<a href="/2016/10/27/scala/04-fp-structure/">第四章：函数数据结构</a></div><div class="article-nav-next">🔜<a href="/2016/10/27/scala/02-getting-started/">第二章：开始学习Scala</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2016/10/27/scala/03-scala-oop/';
var disqus_title = '第三章：Scala OOP';
var disqus_url = 'https://galudisu.info/2016/10/27/scala/03-scala-oop/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>