<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>rust基础入门[19] - Object-Oriented Programming</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/maths/">Maths</a></li><li class="menu-item"><a class="menu-link" href="/projects/">Projects</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/maths/">Maths</a></li><li class="menu-item"><a class="menu-link" href="/projects/">Projects</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">rust基础入门[19] - Object-Oriented Programming</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2023-01-19</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/rust/">rust</a></p><p class="meta-item meta-category"><span class="meta-item-title"></span><i class="icon-bookmark"> </i><a class="category-link" href="/categories/learning/">learning</a></p></div><div class="article-content"><p>本章覆盖有：</p>
<ul>
<li>不使用trait，继承方式实现关联类型的函数</li>
<li>Rust面向对象和C++面向对象的区别</li>
<li>那些trait可以实现哪些type，哪些不能</li>
<li>如何指定一个方法更改对象</li>
<li>构造对象的一些约定方法</li>
<li>为什么Rust不适用数据继承</li>
<li>什么是静态派遣，什么是动态派遣，如何实现，如何使用</li>
</ul>
<span id="more"></span>
<h2 id="Inherent-Implementations"><a class="header-anchor" href="#Inherent-Implementations">¶</a>Inherent Implementations</h2>
<p>前面章节，我们看到如何解决下面的问题。你有一个结构体<code>Stru</code>，用于两个方面：用作名称空间，里面有一个函数<code>f1</code>，用作表达式<code>Stru::f1(500_000)</code>的调用；用作创建实例，实例名为<code>s</code>，这个实例可以调用<code>f2</code>方法，例如<code>s.f2(456).x</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Tr</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f1</span>(a: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f2</span>(&amp;<span class="keyword">self</span>, b: <span class="type">u16</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stru</span> &#123;</span><br><span class="line">    x: <span class="type">u16</span>,</span><br><span class="line">    y: <span class="type">u16</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Tr</span> <span class="keyword">for</span> <span class="title class_">Stru</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f1</span>(a: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        a == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f2</span>(&amp;<span class="keyword">self</span>, b: <span class="type">u16</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> b == <span class="keyword">self</span>.x || b == <span class="keyword">self</span>.y &#123;</span><br><span class="line">            Stru &#123;</span><br><span class="line">                x: <span class="keyword">self</span>.x + <span class="number">1</span>,</span><br><span class="line">                y: <span class="keyword">self</span>.y + <span class="number">1</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Stru &#123;</span><br><span class="line">                x: <span class="keyword">self</span>.x - <span class="number">1</span>,</span><br><span class="line">                y: <span class="keyword">self</span>.y - <span class="number">1</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = Stru &#123; x: <span class="number">23</span>, y: <span class="number">456</span> &#125;;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, Stru::<span class="title function_ invoke__">f1</span>(<span class="number">500_000</span>), s.<span class="title function_ invoke__">f2</span>(<span class="number">456</span>).x);</span><br></pre></td></tr></table></figure>
<p>结果将打印：<code>false 24</code>。</p>
<p>首先，<code>Tr</code>被声明，带有两个方法签名，<code>f1</code>和<code>f2</code>，<code>Stru</code>结构体被声明。然后，trait<code>Tr</code>有该结构体的实现。最后实例化结构体变量，并调用这两个方法。</p>
<p>这种模式很常见，下面有一种简化的写法，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stru</span> &#123;</span><br><span class="line">    x: <span class="type">u16</span>,</span><br><span class="line">    y: <span class="type">u16</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Stru</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f1</span>(a: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        a == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f2</span>(&amp;<span class="keyword">self</span>, b: <span class="type">u16</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> b == <span class="keyword">self</span>.x || b == <span class="keyword">self</span>.y &#123;</span><br><span class="line">            Stru &#123;</span><br><span class="line">                x: <span class="keyword">self</span>.x + <span class="number">1</span>,</span><br><span class="line">                y: <span class="keyword">self</span>.y + <span class="number">1</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Stru &#123;</span><br><span class="line">                x: <span class="keyword">self</span>.x - <span class="number">1</span>,</span><br><span class="line">                y: <span class="keyword">self</span>.y - <span class="number">1</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = Stru &#123; x: <span class="number">23</span>, y: <span class="number">456</span> &#125;;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, Stru::<span class="title function_ invoke__">f1</span>(<span class="number">500_000</span>), s.<span class="title function_ invoke__">f2</span>(<span class="number">456</span>).x);</span><br></pre></td></tr></table></figure>
<p>这段代码将trait部分移除了，但需要推断trait的名字；因此，对于<code>impl</code>语句,它直接作用于类型，所以不需要trait。这种类型有继承实现。</p>
<p>从面向对象的角度，它表示：我们有一个自定义类型，<code>Stru</code>，带有某些数据成员，x和y；以及某些方法，<code>f1</code>和<code>f2</code>。</p>
<p><code>C++</code>的类似实现如下，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Stru</span> &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span> x;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span> y;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">f1</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> a)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">Stru <span class="title">f2</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> b == x || b == y ?</span><br><span class="line">                Stru &#123;</span><br><span class="line">                    (<span class="type">unsigned</span> <span class="type">short</span>)(x + <span class="number">1</span>),</span><br><span class="line">                    (<span class="type">unsigned</span> <span class="type">short</span>)(y + <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            :</span><br><span class="line">                Stru &#123;</span><br><span class="line">                    (<span class="type">unsigned</span> <span class="type">short</span>)(x - <span class="number">1</span>),</span><br><span class="line">                    (<span class="type">unsigned</span> <span class="type">short</span>)(y - <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Stru s = &#123; <span class="number">23</span>, <span class="number">456</span> &#125;;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha &lt;&lt; Stru::<span class="built_in">f1</span>(<span class="number">500000</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.<span class="built_in">f2</span>(<span class="number">456</span>).x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rust方法中，参数以<code>self</code>开头的称为“对象方法object methods”；不以<code>self</code>开头的称为“类方法class methods”。</p>
<p>在一个对象方法内，<code>self</code>关键表示当前对象，类似其它面向对象语言的<code>self</code>或<code>this</code>。</p>
<p>要调用带有<code>self</code>参数的方法，使用点操作，如<code>s.f2(456)</code>；调用不带<code>self</code>参数的方法，使用函数调用方式，语法像<code>Stru::f1(500_000)</code>，类型名后带两个冒号，其后跟着方法名。</p>
<p><code>Rust</code>和<code>C++</code>字段访问方式的不同在于，Rust中必须写<code>self.x</code>，但<code>C++</code>或其它语言对应可能是<code>this -&gt; x</code>，甚至可以不写，例如Java中的字段<code>this.x</code>和<code>x</code>都一样。</p>
<p>Rust和其它面向对象语言的不同在于，大部分面向对象语言对当前对象的参考(<code>this</code>、<code>self</code>或<code>Me</code>)总是一个指针(pointer)或一个引用(reference)。在Rust中，方法前面中的<code>&amp;self</code>是个引用<code>reference</code>，<code>self</code>则是当前对象的一个拷贝。</p>
<h2 id="Peculiarities-of-Rust-Object-Orientation"><a class="header-anchor" href="#Peculiarities-of-Rust-Object-Orientation">¶</a>Peculiarities of Rust Object-Orientation</h2>
<p>Rust和其它面向对象语言还有几点不同的地方：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">S::<span class="title function_ invoke__">f2</span>();</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">S</span> &#123; <span class="keyword">fn</span> <span class="title function_">f1</span>() &#123; <span class="built_in">print!</span>(<span class="string">&quot;1&quot;</span>); &#125; &#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">S</span> &#123; &#125;</span><br><span class="line">S::<span class="title function_ invoke__">f1</span>();</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">S</span> &#123; <span class="keyword">fn</span> <span class="title function_">f2</span>() &#123; <span class="built_in">print!</span>(<span class="string">&quot;2&quot;</span>); &#125; <span class="keyword">fn</span> <span class="title function_">_f3</span>() &#123;&#125; &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><code>impl</code>的实现只要在同一个范围，可以不用关心它的位置和顺序。结构体和函数也可以在调用之后再定义。不过为了便于阅读，通常会先声明，后面再使用。</p>
<p>在同一个范围内，只允许有一个<code>struct S</code>语句；而对于<code>impl S</code>语句可以有多个。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S1</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S2</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">S1</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">//ILLEGAL: fn f(a: i32) &#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">S2</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">S1::<span class="title function_ invoke__">f</span>();</span><br><span class="line">S2::<span class="title function_ invoke__">f</span>();</span><br></pre></td></tr></table></figure>
<p>在Rust中，同一个范围不允许有同名函数。一个类型表示一个范围。因此，对于<code>S1</code>类型，不能有两个<code>f</code>的方法，即使它有不同的参数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Continent</span> &#123;</span><br><span class="line">    Africa,</span><br><span class="line">    America,</span><br><span class="line">    Asia,</span><br><span class="line">    Europe,</span><br><span class="line">    Oceania,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Contient</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            Continent::Afria =&gt; <span class="string">&quot;Africa&quot;</span>,</span><br><span class="line">            Continent::America =&gt; <span class="string">&quot;America&quot;</span>,</span><br><span class="line">            Continent::Asia =&gt; <span class="string">&quot;Asia&quot;</span>,</span><br><span class="line">            Continent::Europe =&gt; <span class="string">&quot;Europe&quot;</span>,</span><br><span class="line">            Continent::Oceania =&gt; <span class="string">&quot;Oceania&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, Continent::Asia.<span class="title function_ invoke__">name</span>());</span><br></pre></td></tr></table></figure>
<p>在Rust中，不仅可以在结构体添加方法，其它任何定义的类型都可以，诸如枚举和元组-结构体。</p>
<p>但原生数据类型不能直接添加方法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">i32</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码尝试给<code>i32</code>原生类型添加方法，即使方法体是空的，编译器会报错：“only a single inherent implementation marked with <code>#[lang = &quot;i32&quot;]</code> is allowed for the <code>i32</code> primitive”。意思是说，<code>i32</code>原生类型仅能有一处实现，也就是仅能在语言自身和标准库中提供。</p>
<p>另外也不能直接对标准库或其它库中的非原生类型添加方法，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Vec</span>&lt;<span class="type">i32</span>&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>对于这段代码，编译器会报错：“cannot define inherent <code>impl</code> for a type outside of the crate where the type is defined.”。这里的“crate”指一个程序或一个库。因为<code>Vec</code>泛型类型被定义在标准库，这段错误信息告诉你，<code>Vec</code>不能在标准库的外部继承实现。</p>
<p>对于trait，也不能在标准库或其它库的外部实现，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">std</span>::iter::<span class="built_in">Iterator</span> <span class="keyword">for</span> <span class="title class_">i32</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码，编译器会报错：“only traits defined in the current crate can be implemented for arbitrary types”。意思是说，“Iterator”并没有被声明在你的代码范围内，“i32”没有声明在代码中，trait不能对该类型实现。</p>
<p>所以，反过来说，定义在可见范围的任何类型、任何trait都可以实现，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Tr</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f1</span>();</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f2</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Tr</span> <span class="keyword">for</span> <span class="title class_">bool</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f1</span>() &#123; <span class="built_in">print!</span>(<span class="string">&quot;Tr::f1 &quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f2</span>(&amp;<span class="keyword">self</span>) &#123; <span class="built_in">print!</span>(<span class="string">&quot;Tr::f2 &quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span>::<span class="title function_ invoke__">f1</span>();</span><br><span class="line"><span class="literal">true</span>.<span class="title function_ invoke__">f2</span>();</span><br></pre></td></tr></table></figure>
<p>结果打印：“Tr::f1 Tr::f2”。</p>
<p>任何类型都可以通过trait实现代码，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>(<span class="type">u32</span>, <span class="type">u32</span>);</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">std</span>::iter::<span class="built_in">Iterator</span> <span class="keyword">for</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="title function_ invoke__">Pair</span>(<span class="number">23u32</span>, <span class="number">34u32</span>);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, a.<span class="title function_ invoke__">next</span>());</span><br></pre></td></tr></table></figure>
<p>将会打印：“None”。</p>
<p>首先是“Pair”已经定义，以及“Iterator”定义在标准库中，被用来实现“Pair”类型。两者都在作用域可见并且不冲突。</p>
<p>总结！</p>
<ul>
<li>如果<code>Ty</code>是一个类型，允许有<code>impl Ty</code>，要求<code>Ty</code>被声明在当前crate。</li>
<li>如果<code>Tr</code>是一个trait，允许有<code>impl Tr for Ty</code>，要求<code>Tr</code>或<code>Ty</code>被声明在当前crate，不能两者都是标准库或其它库的一部分。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th><code>Tr</code>在当前rate</th>
<th><code>Tr</code>在其它crate</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Ty</code>在当前crate</td>
<td><code>impl Tr for Ty</code> 允许</td>
<td><code>impl Tr for Ty</code> 允许</td>
</tr>
<tr>
<td><code>Ty</code>在其它crate</td>
<td><code>impl Tr for Ty</code> 允许</td>
<td><code>impl Tr for Ty</code> 不合法</td>
</tr>
</tbody>
</table>
<h2 id="Mutating-Methods"><a class="header-anchor" href="#Mutating-Methods">¶</a>Mutating Methods</h2>
<p>Rust中，任何不带<code>mut</code>关键字的，都是immutable的。这对于虚拟参数(pseudo-argument)<code>self</code>也一样。如果想通过方法，更改其作用的对象，需要带上关键字<code>mut</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123; x: <span class="type">u32</span> &#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; <span class="keyword">self</span>.x &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_x</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, x: <span class="type">u32</span>) &#123; <span class="keyword">self</span>.x = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = S &#123; x: <span class="number">12</span> &#125;;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, s.<span class="title function_ invoke__">get_x</span>());</span><br><span class="line">s.<span class="title function_ invoke__">set_x</span>(<span class="number">17</span>);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, s.<span class="title function_ invoke__">get_x</span>());</span><br></pre></td></tr></table></figure>
<p><code>C++</code>的等价实现如下，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> x;</span><br><span class="line">		<span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">get_x</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_x</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span> </span>&#123; <span class="keyword">this</span> -&gt; x = x; &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	S s = &#123; <span class="number">12</span> &#125;;</span><br><span class="line">	std::cout &lt;&lt; s.<span class="built_in">get_x</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	s.<span class="built_in">set_x</span>(<span class="number">17</span>);</span><br><span class="line">	std::cout &lt;&lt; s.<span class="built_in">get_x</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Constructors"><a class="header-anchor" href="#Constructors">¶</a>Constructors</h2>
<p>每次用到构造对象时，我们都需要指定它的所有字段。</p>
<p>为了独立于方法实现的方式处理对象，某些语言会提供“构造器”这个特性。Rust中也提供了一个或多个方法，不需要接收<code>self</code>参数，但有<code>Self</code>返回的实现。这类方法就是构造器，Rust中没有构造器的明确语法写法，但有一些惯例(convention)。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">	x: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Number &#123; Number &#123; x: <span class="number">0</span>. &#125; &#125;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">from</span>(x: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> Number &#123; Number &#123; x: x &#125; &#125;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123; <span class="keyword">self</span>.x &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = Number::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = Number::<span class="title function_ invoke__">from</span>(<span class="number">2.3</span>);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">value</span>(), b.<span class="title function_ invoke__">value</span>());</span><br></pre></td></tr></table></figure>
<p><code>new</code>和<code>from</code>方法是构造器。按照惯例，不带参数的构造器命名为<code>new</code>，带有一个参数的构造器命名为<code>from</code>。然而，通常有很多构造器仅带一个参数的；这些构造器中仅有一个命名为<code>from</code>。</p>
<p>这种惯例在标准库中有实例，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;(&#123;&#125;) (&#123;&#125;);&quot;</span>, a, b);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = <span class="type">Vec</span>::&lt;<span class="type">i32</span>&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">d</span> = <span class="type">Vec</span>::&lt;<span class="type">u8</span>&gt;::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot; &#123;:?&#125; &#123;:?&#125;&quot;</span>, c, d);</span><br></pre></td></tr></table></figure>
<h2 id="Composition-Instead-of-Inheritance"><a class="header-anchor" href="#Composition-Instead-of-Inheritance">¶</a>Composition Instead of Inheritance</h2>
<p>面向对象中有三种继承：数据继承、方法实现继承、方法接口继承。Rust中不支持数据继承，因为它会带来很多问题，Rust中使用组合方式来替代数据继承的实现。</p>
<p>假设我们有一个类型，它表示将字符文本画在屏幕上，另外要创建一个类型表示这个文本的框。为了简单，用控制台打印，替代画文本，用中括号代替这个矩形。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Text</span> &#123; characters: <span class="type">String</span> &#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Text</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(text: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Text &#123;</span><br><span class="line">        Text &#123; characters: text.<span class="title function_ invoke__">to_string</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.characters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BoxedText</span> &#123;</span><br><span class="line">    text: Text,</span><br><span class="line">    first: <span class="type">char</span>,</span><br><span class="line">    last: <span class="type">char</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">BoxedText</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">with_text_and_borders</span>(</span><br><span class="line">        text: &amp;<span class="type">str</span>, first: <span class="type">char</span>, last: <span class="type">char</span>) <span class="punctuation">-&gt;</span> BoxedText &#123;</span><br><span class="line">            BoxedText &#123;</span><br><span class="line">                text: Text::<span class="title function_ invoke__">from</span>(text),</span><br><span class="line">                first: first,</span><br><span class="line">                last: last,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.first);</span><br><span class="line">        <span class="keyword">self</span>.text.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">greeting</span> = Text::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">greeting.<span class="title function_ invoke__">draw</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">boxed_greeting</span> = </span><br><span class="line">	BoxedText::<span class="title function_ invoke__">with_text_and_borders</span>(<span class="string">&quot;Hi&quot;</span>, <span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">	boxed_greeting.<span class="title function_ invoke__">draw</span>();</span><br></pre></td></tr></table></figure>
<p>第二条语句定义了两个方法：<code>from</code>，它是一个构造器；<code>draw</code>，打印输出字符内容。</p>
<p>现在想利用已有的结构和方法，来创建一个新的结构<code>BoxedText</code>。它是继承的一种常见方法。</p>
<p>在Rust中，如其使用继承，你可以创建一个<code>BoxedText</code>结构体来“包含”<code>Text</code>类型对象。然后创建对应的方法封装这个类型<code>with_text_and_borders</code>。这段代码中，代码复用出现在几个地方：</p>
<ul>
<li><code>struct BoxedText</code>的第一个字段是<code>Text</code>类型，它复用了数据结构，</li>
<li><code>BoxedText</code>构造器用到了<code>Text::from(text)</code>，它复用了<code>Text</code>的构造器，</li>
<li><code>BoxedText</code>的方法体<code>draw</code>内，用到了<code>self.text.draw();</code>。它复用了<code>Text</code>的方法<code>draw</code>，</li>
</ul>
<h2 id="Memory-Usage-of-Composition"><a class="header-anchor" href="#Memory-Usage-of-Composition">¶</a>Memory Usage of Composition</h2>
<p>组合和继承的内存使用没有区别。它们都需要内存，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line">	_x: <span class="type">f64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base2</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived1</span> &#123;</span><br><span class="line">	_b1: Base1,</span><br><span class="line">	_b2: Base2,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived2</span> &#123;</span><br><span class="line">	_d1: Derived1,</span><br><span class="line">	_other: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">use</span> std::mem:size_of;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>,</span><br><span class="line">	size_of::&lt;Base1&gt;(), size_of::&lt;Base2&gt;(),</span><br><span class="line">	size_of::&lt;Derived1&gt;(), size_of::&lt;Derived2&gt;());</span><br></pre></td></tr></table></figure>
<p>打印输出为：“8 0 8 16”。<code>Base1</code>是一个仅包含8字节数的结构体，所以它占8个字节；<code>Base2</code>结构体不包含任何东西，占0个字节；<code>Derived1</code>是一个包含两个结构体的结构体，一个占8，一个占0，总共占8个字节；<code>Derived2</code>是一个包含8字节结构体，以及一个8字节字段，总共占16字节。我们看到内存使用是非常高效的。</p>
<h2 id="Static-Dispatch"><a class="header-anchor" href="#Static-Dispatch">¶</a>Static Dispatch</h2>
<p>Rust不是动态语言，所以，下面写法是不允许的，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">draw_text</span>(txt) &#123;</span><br><span class="line">	txt.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里希望，如果<code>txt</code>的类型是<code>Text</code>，则调用<code>Text</code>对应的<code>draw</code>方法；如果<code>txt</code>的类型是<code>BoxedText</code>，则调用<code>BoxedText</code>的方法<code>draw</code>。因为Rust是强静态语言，要实现这个方案，有两种不等价的实现方式，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Text</span> &#123; characters: <span class="type">String</span> &#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Text</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">from</span>(text: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Text &#123;</span><br><span class="line">		Text &#123; characters: text.<span class="title function_ invoke__">to_string</span>() &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">Text</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">		<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.characters);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BoxedText</span> &#123;</span><br><span class="line">	text: Text,</span><br><span class="line">	first: <span class="type">char</span>,</span><br><span class="line">	last: <span class="type">char</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">BoxedText</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">with_text_and_borders</span>(text: &amp;<span class="type">str</span>, first: <span class="type">char</span>, last: <span class="type">char</span>) <span class="punctuation">-&gt;</span> BoxedText &#123;</span><br><span class="line">		BoxedText &#123;</span><br><span class="line">			text: Text::<span class="title function_ invoke__">from</span>(text),</span><br><span class="line">			first: first,</span><br><span class="line">			last: last,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">BoxedText</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">		<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.first);</span><br><span class="line">		<span class="keyword">self</span>.text.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">		<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.last);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">greeting</span> = Text::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">boxed_greeting</span> = </span><br><span class="line">	BoxedText::<span class="title function_ invoke__">with_text_and_borders</span>(<span class="string">&quot;Hi&quot;</span>, <span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// SOLUTION 1 //</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">draw_text</span>&lt;T&gt;(txt: T) <span class="keyword">where</span> T: Draw &#123;</span><br><span class="line">	txt.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">draw_text</span>(greeting);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">draw_text</span>(boxed_greeting);</span><br></pre></td></tr></table></figure>
<p>这里定义了泛型函数，并使用<code>where</code>从句确定类型边界。我们需要在这里引申解析静态派遣(static dispatch)这个概念。</p>
<p>首先声明了<code>Draw</code>，作为一个对象，拥有drawn的能力。</p>
<p>然后<code>Text</code>和<code>BoxedText</code>类型被声明，有对应的方法，有两个构造函数<code>Text::from</code>和<code>BoxedText::with_text_and_borders</code>；它们的<code>draw</code>函数的实现都继承来自<code>Draw</code>。</p>
<p>SOLUTION 1中的方法，<code>draw_text</code>泛型方法接收类型参数<code>T</code>，<code>T</code>是任何实现了<code>Draw</code>的类型。</p>
<p>因此，不乱编译器计数器在哪里调用<code>draw_text</code>函数，它会决定参数的类型，并检测该类型是否实现<code>Draw</code>。如果没有对应类型，编译器报错，若有具体的类型，会生成具体版本的<code>draw_text</code>函数，泛型函数体内的<code>draw</code>方法的调用，会被替换为对应<code>T</code>的实现的<code>draw</code>的方法。</p>
<p>这种技术称为“静态派遣static dispatch”。在计算机科学中，<code>dispatch</code>表示有几个同名函数时，选择调用哪个函数。在这段程序中，有两个函数命名为<code>draw</code>，因此派遣从两者中选择一个。在该程序中，选择由编译器处理，在编译期，这种派遣是“静态的static”。</p>
<h2 id="Dynamic-Dispatch"><a class="header-anchor" href="#Dynamic-Dispatch">¶</a>Dynamic Dispatch</h2>
<p>上面的程序可以稍作改变，改变最后几行代码，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SOLUTION 1/bis //</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">draw_text</span>&lt;T&gt;(txt: &amp;T) <span class="keyword">where</span> T: Draw &#123;</span><br><span class="line">	txt.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">draw_text</span>(&amp;greeting);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">draw_text</span>(&amp;boxed_greeeting);</span><br></pre></td></tr></table></figure>
<p>这里把接收参数，改为了一个reference，即在方法签名的参数带上<code>&amp;</code>，以及两处调用带上<code>&amp;</code>。</p>
<p>这种方案仍然是静态派遣。因此，可以看到静态派遣工作在值传递(pass-by-value)和引用传递(pass-by-reference)上。</p>
<p>上面的代码可以改变下，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SOLUTION 2 //</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">draw_text</span>(txt: &amp;Draw) &#123;</span><br><span class="line">	txt.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">draw_text</span>(&amp;greeting);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">draw_text</span>(&amp;boxed_greeting);</span><br></pre></td></tr></table></figure>
<p>该程序保留原来的行为，但使用了另一种技术。仅改变了<code>draw_text</code>的签名，删除了<code>T</code>类型参数，删除了<code>where</code>从句，参数用<code>&amp;Draw</code>替换了<code>&amp;T</code>。现在，由原来的泛型函数，替换为具体的函数，它的参数是对trait的一个引用。</p>
<p>不同的是，一个trait不是一个类型(type)。你不能声明一个变量或一个函数参数用trait来表示它的类型。但对trait的reference是一个有效的类型。然而，它不是普通的引用。</p>
<p>在第一个地方，如果它是一个普通引用，它不能将引用，传递<code>Text</code>或<code>BoxedText</code>中函数的参数；但实际上，它是允许的，考虑如下，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Tr</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Tr</span> <span class="keyword">for</span> <span class="title class_">bool</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_a</span>: &amp;Tr = &amp;<span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>这里<code>bool</code>类型实现了<code>Tr</code>trait，所以<code>&amp;true</code>的引用的值类型是<code>bool</code>，可以初始化给变量<code>_a</code>，<code>_a</code>是<code>Tr</code>的一个引用。</p>
<p>相反，下面写法是不合法的，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Tr</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_a</span>: &amp;Tr = &amp;<span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>这里，<code>bool</code> 没有<code>Tr</code>的实现，因此<code>&amp;true</code>这个对<code>bool</code>的值引用，不能被初始化为<code>Tr</code>的引用。</p>
<p>通常地，任何对类型<code>T</code>的引用，都可以初始化为一个实现<code>T</code>的trait的一个引用。将参数传递给函数，是一种初始化处理，因此任何对类型<code>T</code>的引用，可以作为函数参数进行传递，这个参数引用的<code>trait</code>是<code>T</code>的实现。</p>
<p>在第二处，如果<code>&amp;Draw</code>是一个普通指针，<code>txt</code>是指针的类型，表达式<code>txt.draw()</code>会调用相同的函数，取决于引用对象<code>txt</code>的名字。如其说需要一个dispatch，实际我们需要的是，当<code>draw_text</code>接收一个<code>Text</code>时，<code>Text</code>类型关联的<code>draw</code>方法被调用；当<code>draw_tet</code>接收一个<code>BoxedText</code>时，<code>BoxedText</code>类型关联的<code>draw</code>方法被调用。</p>
<p>所以，这里的<code>&amp;Draw</code>并不是一个普通的指针，而一个能够根据引用对象的类型，选择调用方法的指针。这是一种派遣(dispatch)，但发生在运行时，因此叫做“动态派遣(dynamic dispatch)”。</p>
<p>动态派遣在C++中的通过<code>virtual</code>关键字处理，尽管机制略有不同。</p>
<h2 id="Implementation-of-References-to-Traits"><a class="header-anchor" href="#Implementation-of-References-to-Traits">¶</a>Implementation of References to Traits</h2>
<p>回到原来代码关于派遣的问题，将最后几行替换如下代码，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> st::mem::size_of_val;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;, &#123;&#125; &#123;&#125; &#123;&#125;, &quot;</span>,</span><br><span class="line">	<span class="title function_ invoke__">size_of_val</span>(&amp;greeting),</span><br><span class="line">	<span class="title function_ invoke__">size_of_val</span>(&amp;&amp;greeting),</span><br><span class="line">	<span class="title function_ invoke__">size_of_val</span>(&amp;&amp;&amp;greeting),</span><br><span class="line">	<span class="title function_ invoke__">size_of_val</span>(&amp;boxed_greeting),</span><br><span class="line">	<span class="title function_ invoke__">size_of_val</span>(&amp;&amp;boxed_greeting),</span><br><span class="line">	<span class="title function_ invoke__">size_of_val</span>(&amp;&amp;&amp;boxed_greeting));</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">draw_text</span>(txt: &amp;Draw) &#123;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125; &quot;</span>,</span><br><span class="line">		<span class="title function_ invoke__">size_of_val</span>(txt),</span><br><span class="line">		<span class="title function_ invoke__">size_of_val</span>(&amp;txt),</span><br><span class="line">		<span class="title function_ invoke__">size_of_val</span>(&amp;&amp;txt));</span><br><span class="line">	txt.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">draw_text</span>(&amp;greeting);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">draw_text</span>(&amp;boxed_greeting);</span><br></pre></td></tr></table></figure>
<p>在64位目标机器上，会打印：“<code>24 8 8, 32 8 8, 24 16 8 Hello, 32 16 8 [Hi]</code>”。</p>
<p><code>size_of_val</code>定义在标准库的一个泛型函数，接收对象的引用，返回该引用对象的字节大小。</p>
<p>首先，<code>greeting</code>变量被处理。它的类型是<code>Text</code>结构体，仅包含一个<code>String</code>对象。我们已经探讨过<code>String</code>对象在栈上占24个字节，附带在堆一个缓冲区。这个缓冲区不会在<code>size_of_val</code>函数的计算范围内。</p>
<p>接着打印<code>Text</code>引用的大小，<code>Text</code>的引用是普通引用，占8个字节。</p>
<p>类似地，<code>boxed_greeting</code>变量是个结构体，有两个<code>char</code>对象。每个占4个字节，一共有24 + 4 + 4 = 32字节。</p>
<p>对于表达式<code>&amp;greeting</code>，有类型<code>&amp;Text</code>，它作为参数传递给<code>draw_text</code>函数，该函数实例化<code>txt</code>参数，参数类型是<code>&amp;Draw</code>。</p>
<p>由于<code>txt</code>是一种引用，所以可以由表达式<code>size_of_val(txt)</code>计算。它会返回引用对象的大小。但就是哪个才是<code>&amp;Draw</code>的引用对象？明显，一定不是<code>Draw</code>，因为<code>Draw</code>不是类型。实际上，在编译期不能确定。它需要运行期，有初始化<code>txt</code>参数的表达式决定。首先，第一次接收的<code>txt</code>参数的引用类型是<code>Text</code>，占24个字节。</p>
<p>当接收的<code>txt</code>参数的引用类型是<code>BoxedText</code>时，它占32个字节，将被打印。</p>
<p>回到<code>greeting</code>的调用处，我们发现表达式<code>size_of_val(&amp;txt)</code>的值是16。这很奇怪。这个表达式是求类型<code>&amp;Draw</code>对象的大小，由类型<code>&amp;Text</code>的对象初始化。所以，实际上用了一个常规8字节引用来初始化一个16字节的trait引用？为什么对trait的引用这么大？</p>
<p>实际上，任何对trait的引用有两个字段。第一个字段，是初始化引用的一个拷贝；第二个字段，是一个指针，用于选择合适“版本”的<code>draw</code>函数，或者说其它函数的动态派遣。它的名字是“虚拟表指针，virtual table pointer”。该名称来源于C++。</p>
<p>最后，trait的引用的引用被打印，它是个常规引用，所以占8个字节。</p>
<h2 id="Static-vs-Dynamic-Dispatch"><a class="header-anchor" href="#Static-vs-Dynamic-Dispatch">¶</a>Static vs. Dynamic Dispatch</h2>
<p>我们可以用静态派遣，也可以用动态派遣，哪个更适合？</p>
<p>“静态static”意味着“编译期”，“动态dynamic”意味着“运行期”，静态要求更多的编译时间，以及生成更多更快的代码，但如果编译期没有足够的可用信息，动态方案是唯一可能的选择。</p>
<p>假设将原来的示例程序更改一下需求，要求如果字符串是“b”，则输出带边框，否则，直接输出文本。</p>
<p>使用静态派遣，程序最后部分会变为，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SOLUTION 1/ter //</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">draw_text</span>&lt;T&gt;(txt: T) <span class="keyword">where</span> T: Draw &#123;</span><br><span class="line">	txt.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">std::io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> input).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="keyword">if</span> input.<span class="title function_ invoke__">trim</span>() == <span class="string">&quot;b&quot;</span> &#123;</span><br><span class="line">	<span class="title function_ invoke__">draw_text</span>(boxed_greeting);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="title function_ invoke__">draw_text</span>(greeting);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用动态派遣，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SOLUTION 2/bis //</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">draw_text</span>(txt: &amp;Draw) &#123;</span><br><span class="line">	txt.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">std::io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> input).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">dr</span>: &amp;Draw = <span class="keyword">if</span> input.<span class="title function_ invoke__">trim</span>() == <span class="string">&quot;b&quot;</span> &#123;</span><br><span class="line">	&amp;boxed_greeting</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	&amp;greeting</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_ invoke__">draw_text</span>(dr);</span><br></pre></td></tr></table></figure>
<p>静态派遣要求写几个函数调用，动态派遣允许你将选择的对象派遣给变量<code>dr</code>，然后仅需要些一个函数接收这个变量。</p>
<p>另外，静态派遣使用了泛型方法，这个技术可以会导致代码膨胀，可能最后会变得越来越慢。</p>
</div></article><nav class="article-nav"><div class="article-nav-prev"><a href="/2023/01/20/rust/beginning/chapter20_Standard%20Library%20Collections/">rust基础入门[20] - Standard Library Collections</a></div><div class="article-nav-next"><a href="/2023/01/18/rust/beginning/chapter18_Using%20Traits/">rust基础入门[18] - Using Traits</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2023/01/19/rust/beginning/chapter19_Object-Oriented Programming/';
var disqus_title = 'rust基础入门[19] - Object-Oriented Programming';
var disqus_url = 'https://galudisu.info/2023/01/19/rust/beginning/chapter19_Object-Oriented Programming/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>