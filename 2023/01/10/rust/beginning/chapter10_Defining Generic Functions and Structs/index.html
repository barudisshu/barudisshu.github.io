<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>rust基础入门[10] - Defining Generic Functions and Structs</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/maths/">Maths</a></li><li class="menu-item"><a class="menu-link" href="/projects/">Projects</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/maths/">Maths</a></li><li class="menu-item"><a class="menu-link" href="/projects/">Projects</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">rust基础入门[10] - Defining Generic Functions and Structs</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2023-01-10</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/rust/">rust</a></p><p class="meta-item meta-category"><span class="meta-item-title"></span><i class="icon-bookmark"> </i><a class="category-link" href="/categories/learning/">learning</a></p></div><div class="article-content"><p>本章覆盖有：</p>
<ul>
<li>如何定义单独的函数，使得调用者可以处理不同的数据类型</li>
<li>泛型函数如何使用类型推导来避免指定具体类型</li>
<li>如何在struct、tuple-struct、enum实现各种泛型类型</li>
<li>如何使用两个常见的枚举类型，Option和Result</li>
<li>标准函数对Option和Result的处理</li>
</ul>
<span id="more"></span>
<h2 id="Need-of-Generic-Functions"><a class="header-anchor" href="#Need-of-Generic-Functions">¶</a>Need of Generic Functions</h2>
<p>Rust提供一个静态类型检查，所以定义函数的参数必须是确切的类型，例如<code>fn square_root(x: f32) -&gt; f32</code>，调用时必须传递一个确切的参数，例如<code>square_root(45.2f32)</code>，或显示转换为它所需要的参数<code>square_root(45.2f64 as f32)</code>。你不能传递不同的类型。</p>
<p>这不论是写代码、还是调用代码都带来了不方便。甚至于Rust有很多不同的整型类型，当写一个函数，每次都要处理选择哪一种类型。例如，当你用<code>i16</code>类型作为参数，但每次都传递了<code>i32</code>类型，这要求我们重新定义我们的函数。</p>
<p>另外，函数会被作为模块在其它地方调用，这也不能满足每个使用者。</p>
<h2 id="Defining-and-Using-Generic-Functions"><a class="header-anchor" href="#Defining-and-Using-Generic-Functions">¶</a>Defining and Using Generic Functions</h2>
<p>最笨的办法是编写泛型函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Library code</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>&lt;T&gt;(ch: <span class="type">char</span>, num1: T, num2: T) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">if</span> ch == <span class="string">&#x27;a&#x27;</span> &#123; num1 &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; num2 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: <span class="type">i16</span> = f::&lt;<span class="type">i16</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="number">37</span>, <span class="number">41</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span>: <span class="type">f64</span> = f::&lt;<span class="type">f64</span>&gt;(<span class="string">&#x27;b&#x27;</span>, <span class="number">37.2</span>, <span class="number">41.1</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, a, b);</span><br></pre></td></tr></table></figure>
<p>泛型参数类型定义在函数名后面，由尖括号囊括，它就是函数的类型参数声明。它表述声明的不是一个具体函数，而是一个泛型函数，该函数的泛型参数类型，仅在编译期确定。</p>
<p>参数<code>T</code>的定义范围仅限于函数定义内。实际上仅会出现在3个地方，函数签名，以及函数语句体内部调用，不会在其它地方出现。</p>
<p>泛型函数的调用，需要带上类型参数，类型参数就是具体的类型替换这个<code>T</code>即可。如这里的<code>f::&lt;i16&gt;</code>、<code>f::&lt;f64&gt;</code>。</p>
<p>C语言没有泛型类型的概念，但C++有：它使用了函数模板。</p>
<h2 id="Inferring-the-Parametric-Types"><a class="header-anchor" href="#Inferring-the-Parametric-Types">¶</a>Inferring the Parametric Types</h2>
<p>上面的代码可以进一步简化，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Library code</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>&lt;T&gt;(ch: <span class="type">char</span>, num1: T, num2: T) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">if</span> ch == <span class="string">&#x27;a&#x27;</span> &#123; num1 &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; num2 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: <span class="type">i16</span> = <span class="title function_ invoke__">f</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">37</span>, <span class="number">41</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span>: <span class="type">f64</span> = <span class="title function_ invoke__">f</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">37.2</span>, <span class="number">41.1</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, a, b);</span><br></pre></td></tr></table></figure>
<p>这里把<code>::&lt;i16&gt;</code>和<code>::&lt;f64&gt;</code>移除了，以及得到等价的结果。实际上，编译器在解析一个泛型函数的调用时，使用了参数的类型来确定类型。</p>
<p>说白了，参数化类型(parametric type)是由泛型函数调用的表达式推断(inferred)出来的。</p>
<p>当然，被使用的类型必须是一致的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>&lt;T&gt;(a: T, _b: T) <span class="punctuation">-&gt;</span> T &#123; a &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_a</span> = <span class="title function_ invoke__">f</span>(<span class="number">12u8</span>, <span class="number">13u8</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_b</span> = <span class="title function_ invoke__">f</span>(<span class="number">12i64</span>, <span class="number">13i64</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_c</span> = <span class="title function_ invoke__">f</span>(<span class="number">12i16</span>, <span class="number">13u16</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_d</span>: <span class="type">i32</span> = <span class="title function_ invoke__">f</span>(<span class="number">12i16</span>, <span class="number">13i16</span>);</span><br></pre></td></tr></table></figure>
<p>最后一个出现编译错误，虽然参数传递了相同的类型，但函数返回的类型不匹配变量声明。</p>
<p>如果有几个不同的类型需要参数化，你可以指定泛型函数的多个类型参数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>&lt;Param1, Param2&gt;(_a: Param1, _b: Param2) &#123;&#125;</span><br><span class="line"><span class="title function_ invoke__">f</span>(<span class="string">&#x27;a&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="title function_ invoke__">f</span>(<span class="number">12.56</span>, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">f</span>((<span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>), [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]);</span><br></pre></td></tr></table></figure>
<h2 id="Defining-and-Using-Generic-Structs"><a class="header-anchor" href="#Defining-and-Using-Generic-Structs">¶</a>Defining and Using Generic Structs</h2>
<p>参数化类型也适用于声明泛型结构体和泛型元组-结构体(tuple-struct)：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">	c: <span class="type">char</span>,</span><br><span class="line">	n1: T1,</span><br><span class="line">	n2: T1,</span><br><span class="line">	n3: T2,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_s</span> = S &#123; c: <span class="string">&#x27;a&#x27;</span>, n1: <span class="number">34</span>, n2: <span class="number">782</span>, n3: <span class="number">0.02</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SE</span>&lt;T1, T2&gt; (<span class="type">char</span>, T1, T1, T2);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_se</span> = <span class="title function_ invoke__">SE</span> (<span class="string">&#x27;a&#x27;</span>, <span class="number">34</span>, <span class="number">782</span>, <span class="number">0.02</span>);</span><br></pre></td></tr></table></figure>
<p>结构体和元组-结构体的类型参数声明，和泛型函数的声明一样，都是在名称后面带上类型参数声明。</p>
<p>当然也可以显式指定类型参数的具体类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">	c: <span class="type">char</span>,</span><br><span class="line">	n1: T1,</span><br><span class="line">	n2: T1,</span><br><span class="line">	n3: T2,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_s</span> = S::&lt;<span class="type">u16</span>, <span class="type">f32</span>&gt; &#123; c: <span class="string">&#x27;a&#x27;</span>, n1: <span class="number">34</span>, n2: <span class="number">782</span>, n3: <span class="number">0.02</span> &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SE</span>&lt;T1, T2&gt; (<span class="type">char</span>, T1, T1, T2);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_se</span> = SE::&lt;<span class="type">u16</span>, <span class="type">f32</span>&gt; (<span class="string">&#x27;a&#x27;</span>, <span class="number">34</span>, <span class="number">782</span>, <span class="number">0.02</span>);</span><br></pre></td></tr></table></figure>
<p>C语言没有泛型结构体，但C++提供了：类模板和结构模板。</p>
<h2 id="Genericity-Mechanics"><a class="header-anchor" href="#Genericity-Mechanics">¶</a>Genericity Mechanics</h2>
<p>要理解泛化的内部机制，应该先看编译器这个角色。实际上，概念上来说，泛型代码的编译出现在几个阶段。</p>
<p>让我们跟随编译机制的基本概念，提供一下代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">swap</span>&lt;T1, T2&gt;(a: T1, b: T2) <span class="punctuation">-&gt;</span> (T2, T1) &#123; (b, a) &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">swap</span>(<span class="number">3i16</span>, <span class="number">4u16</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="title function_ invoke__">swap</span>(<span class="number">5f32</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125; &#123;:?&#125;&quot;</span>, x, y);</span><br></pre></td></tr></table></figure>
<p>第一阶段，源码被浏览，每次编译器查找一个泛型函数声明(这里的是<code>swap</code>函数)，编译器加载该函数的数据结构，检查泛型代码有没有语法错误。</p>
<p>第二阶段，源码再次被浏览，编译器统计泛型函数的调用次数，并加载该函数的结构关联关系——泛型声明的内部响应和使用进行关联，这阶段在类型检查和响应合法的前提下进行。</p>
<p>在这两个阶段下，编译器获得了一个泛型函数<code>swap</code>，一个<code>main</code>函数，以及<code>swap</code>函数的引用。</p>
<p>第三阶段，所有泛型函数的调用被读取(这里的例子，swap调用了两次)。每次调用，确定一个具体的响应类型的定义。这个具体类型可能在调用的地方显式获取，又或者有参数的表达式推断出来。例如这里例子，第一处调用swap，参数<code>T1</code>关联的类型是<code>i16</code>，<code>T2</code>关联的类型是<code>u16</code>；以此类推…</p>
<p>确定了具体泛型参数类型后，一个确定类型版本的函数被生成。每个泛型函数的调用，都会替换到具体生成的函数上。</p>
<p>例如，内部生成的Rust代码为：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">swap_i16_u16</span>(a: <span class="type">i16</span>, b: <span class="type">u16</span>) <span class="punctuation">-&gt;</span> (<span class="type">u16</span>, <span class="type">i16</span>) &#123; (b, a) &#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">swap_f32_bool</span>(a: <span class="type">f32</span>, b: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> (<span class="type">bool</span>, <span class="type">f32</span>) &#123; (b, a) &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">swap_i16_u16</span>(<span class="number">3i16</span>, <span class="number">4u16</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="title function_ invoke__">swap_f32_bool</span>(<span class="number">5f32</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125; &#123;:?&#125;&quot;</span>, x, y);</span><br></pre></td></tr></table></figure>
<p>可以看到，调用了两处，就生成了两个具体的函数。</p>
<p>第四阶段，是编译这些生成的代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">swap</span>&lt;T1, T2&gt;(a: T1, b: T2) <span class="punctuation">-&gt;</span> (T2, T1) &#123; (b, a) &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">swap</span>(<span class="string">&#x27;A&#x27;</span>, <span class="number">4.5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="title function_ invoke__">swap</span>(<span class="string">&#x27;g&#x27;</span>, -<span class="number">6</span>.);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125; &#123;:?&#125;&quot;</span>, x, y);</span><br></pre></td></tr></table></figure>
<p>如果调用的参数类型一致，仅会生成一个版本，因为所有调用的参数类型都相同。</p>
<p>上面会生成，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">swap_char_f64</span>(a: <span class="type">char</span>, b: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> (<span class="type">f64</span>, <span class="type">char</span>) &#123; (b, a) &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">swap_char_f64</span>(<span class="string">&#x27;A&#x27;</span>, <span class="number">4.5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="title function_ invoke__">swap_char_f64</span>(<span class="string">&#x27;g&#x27;</span>, -<span class="number">6</span>.);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125; &#123;:?&#125;&quot;</span>, x, y);</span><br></pre></td></tr></table></figure>
<p>上面得出，一段程序，会生成几个具体版本的机器代码：</p>
<ul>
<li>对于编译非泛型代码，这种多阶段编译会有几分慢。</li>
<li>生成的代码针对每个特定的调用进行了高度优化，因此不需要对类型转换或决策，运行时的性能都是优化的。</li>
<li>每次调用使用不同的数据类型时，会产生大量的机器码。这会导致一个现象，“代码膨胀(code bloat)”，面对这个事实，为了优化性能，最好不要在单一进程使用过多不同的类型，具体代码使用具体的类型，这回给CPU缓存带来负担。</li>
</ul>
<p>对于泛型结构体和泛型元组-结构体也一样原理。</p>
<h2 id="Generic-Arrays-and-Vectors"><a class="header-anchor" href="#Generic-Arrays-and-Vectors">¶</a>Generic Arrays and Vectors</h2>
<p>关于array和vector不是新的事物。最开始的章节已经介绍了泛型类型。</p>
<p>实际上，array是Rust语言的一部分，vector作为结构体定义在Rust标准库。</p>
<h2 id="Generic-Enums"><a class="header-anchor" href="#Generic-Enums">¶</a>Generic Enums</h2>
<p>在Rust中，enum也可以泛化。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result1</span>&lt;SuccessCode, FailureCode&gt; &#123;</span><br><span class="line">	<span class="title function_ invoke__">Success</span>(SuccessCode),</span><br><span class="line">	<span class="title function_ invoke__">Failure</span>(FailureCode, <span class="type">char</span>),</span><br><span class="line">	Uncertainty,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">_res</span> = Result1::Success::&lt;<span class="type">u32</span>,<span class="type">u16</span>&gt;(<span class="number">12u32</span>);</span><br><span class="line">_res = Result1::Uncertainty;</span><br><span class="line">_res = Result1::<span class="title function_ invoke__">Failure</span>(<span class="number">0u16</span>, <span class="string">&#x27;d&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码是合法的。下面代码在最后一行发生编译错误，因为第一个参数Failure的类型是<code>u32</code>，但根据初始化，它实际上应该是<code>u16</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result1</span>&lt;SuccessCode, FailureCode&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Success</span>(SuccessCode),</span><br><span class="line">    <span class="title function_ invoke__">Failure</span>(FailureCode, <span class="type">char</span>),</span><br><span class="line">    Uncertainty,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">_res</span> = Result1::Success::&lt;<span class="type">u32</span>,<span class="type">u16</span>&gt;(<span class="number">12u32</span>);</span><br><span class="line">_res = Result1::Uncertainty;</span><br><span class="line">_res = Result1::<span class="title function_ invoke__">Failure</span>(<span class="number">0u32</span>, <span class="string">&#x27;d&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>泛型枚举在Rust标准库中被大量用到。</p>
<p>Rust标准库中enum最常被用于解决下面常见问题。如果一个函数可以失败(<code>fail</code>)，失败时应该做什么？</p>
<p>例如，当vector包含条目，函数<code>pop</code>移除vector最后一个条目，并返回被删除的记录。若vector是空的，表达式<code>vec![0;0].pop()</code>应该怎样处理？</p>
<p>某些语言不定义这种行为，让其报错或导致一个不可预测的结果。Rust尽可能避免这种未定义的行为。</p>
<p>某些语言抛出一个异常，由闭合块或当前函数的调用方处理，或报错误。Rust中不适用异常这一概念。</p>
<p>某些语言会返回一个指定的<code>null</code>值。但vector可以包含几乎所有类型，这些类型没有<code>null</code>值。</p>
<p>下面是Rust的解决办法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">item</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = v.<span class="title function_ invoke__">pop</span>();</span><br><span class="line">	<span class="keyword">match</span> item &#123;</span><br><span class="line">		<span class="title function_ invoke__">Some</span>(number) =&gt; <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;, &quot;</span>, number),</span><br><span class="line">		<span class="literal">None</span> =&gt; <span class="built_in">print!</span>(<span class="string">&quot;#, &quot;</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果将输出：“33, 22, 11, #, #, ”。</p>
<p><code>pop</code>函数作用于<code>Vec&lt;T&gt;</code>类型对象，并返回一个<code>Option&lt;T&gt;</code>类型的值。</p>
<p>该泛型类型被定义在Rust的标准库中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">	<span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它是一个optional的T类型，表示有，或者无。</p>
<h2 id="Error-Handling"><a class="header-anchor" href="#Error-Handling">¶</a>Error Handling</h2>
<p>Rust标准库也定义了一个泛型枚举来处理函数不能返回正确类型的情况：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(numerator: <span class="type">f64</span>, denominator: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">f64</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">if</span> denominator == <span class="number">0</span>. &#123;</span><br><span class="line">		<span class="title function_ invoke__">Err</span>(<span class="built_in">format!</span>(<span class="string">&quot;Divide by zero&quot;</span>))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="title function_ invoke__">Ok</span>(nmerator / denominator)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;, &#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">divide</span>(<span class="number">8</span>., <span class="number">2</span>.), <span class="title function_ invoke__">divide</span>(<span class="number">8</span>., <span class="number">0</span>.));</span><br></pre></td></tr></table></figure>
<p>这回输出 <code>Ok(4), Err(&quot;Divide by zero&quot;)</code>。</p>
<p><code>Result</code>类型和<code>Option</code>类型类似，其中<code>Option</code>表示有或无，<code>Result</code>表述了一种异常情况。</p>
<p>它在标准库的定义为：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">	<span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">	<span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用了debug输出结果信息，在生产环境不建议这样做，可以改为下面这种形式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(numerator: <span class="type">f64</span>, denominator: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">f64</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> denominator == <span class="number">0</span>. &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="built_in">format!</span>(<span class="string">&quot;Divide by zero&quot;</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(numerator / denominator)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">show_divide</span>(num: <span class="type">f64</span>, den: <span class="type">f64</span>) &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">divide</span>(num, den) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(val) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; / &#123;&#125; = &#123;&#125;&quot;</span>, num, den, val),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(msg) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Cannot divide &#123;&#125; by &#123;&#125;: &#123;&#125;&quot;</span>, num, den, msg),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">show_divide</span>(<span class="number">8</span>., <span class="number">2</span>.);</span><br><span class="line"><span class="title function_ invoke__">show_divide</span>(<span class="number">8</span>., <span class="number">0</span>.);</span><br></pre></td></tr></table></figure>
<p>结果将输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 / 2 = 4</span><br><span class="line">Cannot divide 8 by 0: Divide by zero</span><br></pre></td></tr></table></figure>
<h2 id="Enum-Standard-Utility-Functions"><a class="header-anchor" href="#Enum-Standard-Utility-Functions">¶</a>Enum Standard Utility Functions</h2>
<p><code>Option</code>和<code>Result</code>标准泛型类型以一种灵活、高效的方式，允许我们捕获real-world code出现的所有情况；然而，使用<code>match</code>语句来获取结果有点不方便。</p>
<p>因此，标准库包含一些工具类函数，以方便<code>Option</code>和<code>Result</code>类型的使用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(numerator: <span class="type">f64</span>, denominator: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">f64</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">if</span> denominator == <span class="number">0</span>. &#123;</span><br><span class="line">		<span class="title function_ invoke__">Err</span>(<span class="built_in">format!</span>(<span class="string">&quot;Divide by zero&quot;</span>))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="title function_ invoke__">Ok</span>(numerator / denominator)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = <span class="title function_ invoke__">divide</span>(<span class="number">8</span>., <span class="number">2</span>.);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = <span class="title function_ invoke__">divide</span>(<span class="number">8</span>., <span class="number">0</span>.);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, r1.<span class="title function_ invoke__">is_ok</span>(), r2.<span class="title function_ invoke__">is_ok</span>());</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, r1.<span class="title function_ invoke__">is_err</span>(), r2.<span class="title function_ invoke__">is_err</span>());</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, r1.<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, r2.<span class="title function_ invoke__">unwrap</span>());</span><br></pre></td></tr></table></figure>
<p>程序首先输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">true false</span><br><span class="line">false true</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>然后给出一个panic信息：“thread ‘main’ panicked at ‘called <code>Result::unwrap()</code> on an <code>Err</code> value: “Divide by zero”’”。</p>
<p><code>is_ok</code>函数返回<code>true</code>如果变式为Ok，<code>is_err</code>返回<code>true</code>如果变式为Err。<code>is_err()</code>等价于<code>! is_ok()</code>。</p>
<p>当作用于一个Ok变式，<code>unwrap</code>函数返回<code>Ok</code>变式的值，否则出现panics。该函数的意思是“我知道在一个Ok变式中可以wrap这个值，因此我只想获取这个容器的值，摈除它的转换；若不是Ok变式，会出现一个不可覆盖的错误，因此我会立即终止该程序”。该代码编译没有出错，运行时会出现panic错误。</p>
<p>对于<code>Option</code>枚举也有<code>unwrap</code>函数，要输出一个Vec的所有制，你可以：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..v.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;, &quot;</span>, v.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwrap</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果会输出：“33, 22, 11,”。<code>unwrap</code>的调用会获取<code>Ok</code>内部的值。我们避免了在一个空vector调用<code>pop()</code>；否则，<code>pop()</code>返回一个<code>None</code>，<code>unwrap()</code>会出现panick。</p>
<p><code>unwrap</code>函数常被用于<code>quick-and-dirty</code>Rust程序中，即错误不要求处理的情况。</p>
</div></article><nav class="article-nav"><div class="article-nav-prev"><a href="/2023/01/11/rust/beginning/chapter11_Allocating%20Memory/">rust基础入门[11] - Allocating Memory</a></div><div class="article-nav-next"><a href="/2023/01/09/rust/beginning/chapter09_Defining%20Functions/">rust基础入门[09] - Defining Functions</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2023/01/10/rust/beginning/chapter10_Defining Generic Functions and Structs/';
var disqus_title = 'rust基础入门[10] - Defining Generic Functions and Structs';
var disqus_url = 'https://galudisu.info/2023/01/10/rust/beginning/chapter10_Defining Generic Functions and Structs/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>