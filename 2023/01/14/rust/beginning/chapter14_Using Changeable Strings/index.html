<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>rust基础入门[14] - Using Changeable Strings</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/maths/">Maths</a></li><li class="menu-item"><a class="menu-link" href="/projects/">Projects</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/maths/">Maths</a></li><li class="menu-item"><a class="menu-link" href="/projects/">Projects</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">rust基础入门[14] - Using Changeable Strings</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2023-01-14</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/rust/">rust</a></p><p class="meta-item meta-category"><span class="meta-item-title"></span><i class="icon-bookmark"> </i><a class="category-link" href="/categories/learning/">learning</a></p></div><div class="article-content"><p>本章覆盖有：</p>
<ul>
<li>静态字符串是如何实现的</li>
<li>动态字符串是如何实现的</li>
<li>如何从动态字符串添加或删除字符</li>
<li>如何在静态字符串和动态字符串之间相互转换</li>
<li>如何合并字符串</li>
</ul>
<span id="more"></span>
<h2 id="Static-Strings"><a class="header-anchor" href="#Static-Strings">¶</a>Static Strings</h2>
<p>我们用到的字符串是可变的(changeable)吗？</p>
<p>某种层面上，她们是可变的(mutable)，我们可以改变它们：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="string">&quot;Hel&quot;</span>;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br><span class="line">a = <span class="string">&quot;lo&quot;</span>;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br></pre></td></tr></table></figure>
<p>我们这里的改变，是更改了整个字符串的内容，不是某些字符。实际上，这里将字符串变量，指派给了一个新的字面量或字符串变量。</p>
<p>但如果我们想要创建一个字符串，是由算法、文件读取、或由用户输入(type)的，这怎么实现？可以确切说，这些都可以做到，并且会改变字符串的内容，它们有一个不可变的<code>content</code>，这些内容不能对其中一两个字符进行重写。基于这个原因，这些字符内容(content)称作<strong>静态字符串(static strings)</strong>。下面例子理清一下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem::*;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: &amp;<span class="type">str</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span>: &amp;<span class="type">str</span> = <span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">c</span>: &amp;<span class="type">str</span> = <span class="string">&quot;abcdè&quot;</span>;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>,</span><br><span class="line">	<span class="title function_ invoke__">size_of_val</span>(a),</span><br><span class="line">	<span class="title function_ invoke__">size_of_val</span>(b),</span><br><span class="line">	<span class="title function_ invoke__">size_of_val</span>(c));</span><br></pre></td></tr></table></figure>
<p>结果将打印“0 10 6”。</p>
<p>首先，我们指定了三个变量的类型。它们的类型是<code>&amp;str</code>，即“<code>str</code>的引用”。</p>
<p><code>str</code>这个词定义在标准库中，作为一个不可修改的字节数组，表示UTF-8字符串。编译器每次解析到字面量字符串时，它存储在一个字符串的字符静态程序区域，这个区域是<code>str</code>类型的。编译器使用一个引用(reference)，来表示字面量字符串表达式在该区域的值，因此任何字符串字面量的类型都是<code>&amp;str</code>。</p>
<p>在例子中，泛型函数<code>size_of_val</code>入参三个字符串变量调用。还记得该函数返回引用对象的大小。如果参数是<code>a</code>，参数类型是<code>&amp;str</code>，该函数会返回由<code>a</code>引用的字符串缓冲区的大小，即返回类型<code>str</code>的大小。</p>
<p>因此，这里打印出引用字符串缓冲区<code>a</code>、<code>b</code>和<code>c</code>的大小。分别大小由<code>0</code>、<code>10</code>和<code>6</code>字节。第一个字符串为空，第二个包含10个数，与此，第三个仅包含5个字符，却打印了6.这是因为UTF-8标注的原因。这种标注，取决于字符本身，每个字符由一个或多个字节表示。ASCII字符由1个字节表示，对于“grave e”字符，即“è”，由两个字节表示。因此，整个字符串大小是6个字节。</p>
<p>注意由<code>a</code>、<code>b</code>和<code>c</code>变量引用的缓冲区的类型相同，都是<code>str</code>，但它们有不同长度：0，10，6。这里我们第一次看到了一个不与长度关联的类型。</p>
<p>这种类型不常见，但它们有某些限制。一是你不能给这种类型声明一个变量或一个函数参数。另一个明显的限制是，你不能访问这种类型的大小。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: <span class="type">str</span>;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>(a: <span class="type">str</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, std::mem::size_of::&lt;<span class="type">str</span>&gt;());</span><br></pre></td></tr></table></figure>
<p>上面三个语句都是不合法的。</p>
<p>但，要怎样才能获得缓冲区的大小？在C语言，字符串终止符被作为字符串结束标志，但Rust中没有字符串终止符。</p>
<p>实际上<code>&amp;str</code>不是一个普通的Rust引用，它仅包含一个指针，但它是一对指针和长度(a pair of a pointer and a length)。指针的值是字符串缓冲区的开始地址，长度值是字符串缓冲区的字节数量。</p>
<p>让我们更深入探索一下这种奇怪的类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem::*;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: &amp;<span class="type">str</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span>: &amp;<span class="type">str</span> = <span class="string">&quot;0123456789&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">c</span>: &amp;<span class="type">str</span> = <span class="string">&quot;abcdè&quot;</span>;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;; &quot;</span>,</span><br><span class="line">	<span class="title function_ invoke__">size_of_val</span>(&amp;a),</span><br><span class="line">	<span class="title function_ invoke__">size_of_val</span>(&amp;b),</span><br><span class="line">	<span class="title function_ invoke__">size_of_val</span>(&amp;c));</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;; &quot;</span>,</span><br><span class="line">	<span class="title function_ invoke__">size_of_val</span>(&amp;&amp;a),</span><br><span class="line">	<span class="title function_ invoke__">size_of_val</span>(&amp;&amp;b),</span><br><span class="line">	<span class="title function_ invoke__">size_of_val</span>(&amp;&amp;c));</span><br></pre></td></tr></table></figure>
<p>该程序在一个64位系统将打印“16 16 16; 8 8 8”，在32位系统打印“8 8 8; 4 4 4”。</p>
<p>第一条<code>print</code>语句打印变量自身的大小，即类型<code>&amp;str</code>。该变量得到的结果，是常规引用大小的2倍，因为它们包含一个指针对象和一个<code>usize</code>对象。所以，当我们在一个静态字符串调用<code>len</code>函数，得到的是pair的第二个值。</p>
<p>第二条<code>print</code>语句打印变量自身引用的大小，即类型<code>&amp;&amp;str</code>。它们是常规引用。</p>
<h2 id="Dynamic-Strings"><a class="header-anchor" href="#Dynamic-Strings">¶</a>Dynamic Strings</h2>
<p>因此如果我们想要在运行期创建或更改字符串的内容(contents)，前面用到的<code>&amp;str</code>类型显然不适合。</p>
<p>Rust同时也提供了另外一种字符串类型，<code>动态字符串(dynamic strings)</code>，它的内容可以被改变：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span>: <span class="type">String</span> = <span class="string">&quot;He&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">a.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">a.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">a.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br></pre></td></tr></table></figure>
<p>结果将输出“Hello”。</p>
<p>变量<code>a</code>是一个<code>String</code>类型，它是Rust静态字符串的类型。</p>
<p>在Rust中没有动态字符串字面量；字符串字面量总是静态的。但一个动态字符串可能由一个静态字符串的几种方式构造得来。一种方式是在静态字符串调用<code>to_string</code>函数。这种函数名应该考虑是<code>to_dynamic_string</code>或<code>to_String</code>。但第一个名字太长，第二个违反了函数名字母大写的规则。</p>
<p>一个动态字符串应该能像任何静态字符串一样打印输出，如上面的例子。以及它有静态字符串做不到的能力：增长。</p>
<p>第二、三、四语句中向字符串尾部添加一个字符。</p>
<p>以及可以在一个动态字符串内部的其它位置添加、或者删除字符：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span>: <span class="type">String</span> = <span class="string">&quot;Xy&quot;</span>.<span class="title function_ invoke__">to_string</span>(); <span class="comment">// &quot;Xy&quot;</span></span><br><span class="line">a.<span class="title function_ invoke__">remove</span>(<span class="number">0</span>); <span class="comment">// &quot;y&quot;</span></span><br><span class="line">a.<span class="title function_ invoke__">insert</span>(<span class="number">0</span>, <span class="string">&#x27;H&#x27;</span>); <span class="comment">// &quot;Hy&quot;</span></span><br><span class="line">a.<span class="title function_ invoke__">pop</span>(); <span class="comment">// &quot;H&quot;</span></span><br><span class="line">a.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;i&#x27;</span>); <span class="comment">// &quot;Hi&quot;</span></span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br></pre></td></tr></table></figure>
<p>结果将打印“Hi”。</p>
<p>变量<code>a</code>由<code>Xy</code>初始化。然后在位置0的字符被移除，剩下<code>y</code>。然后<code>H</code>插入到位置0，变成了<code>Hy</code>。然后最后一个字符pop out，剩下<code>H</code>。接着添加<code>i</code>，得到<code>Hi</code>。</p>
<h2 id="Implementation-of-String"><a class="header-anchor" href="#Implementation-of-String">¶</a>Implementation of String</h2>
<p>Rust的静态字符串和C语言的字符串有几分类似，带有一个额外的计数器，以及一个Rust动态字符串和C++ <code>std::string</code>对象十分相像。Rust和C<ins>动态字符串类型的主要不同是，C</ins>字符串包含一个字符数组，而Rust动态字符串，和Rust静态字符串一样，包含的是一个由UTF-8字符串表述的字节数组；它不是包含字符数组的。</p>
<p>Rust语言中保留了其它一些相似的特性。静态字符串缓冲区类似于数组，即<code>str</code>类型类似于泛型类型<code>[u8; N]</code>；动态字符串类似于字节向量，即<code>String</code>类型类似于<code>Vec&lt;u8&gt;</code>类型。</p>
<p>进一步，上面我们看到的函数——<code>push</code>，<code>pop</code>，<code>insert</code>以及<code>remove</code>，还有<code>len</code>函数，在<code>Vector</code>泛型类型都有对应的同名函数。</p>
<p>另外，动态字符串和向量拥有相同的实现。两者都又下面三部分构成：</p>
<ul>
<li>堆空间分配缓冲区的首地址包含数据条目；</li>
<li>条目的数量可能包含在分配的缓冲区；</li>
<li>条目的数量可能会在分配的缓冲区提供使用。</li>
</ul>
<p>然而，值得注意的是，字符串的“条目”是字节，不是字符：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="string">&quot;&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">s1.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s2</span> = <span class="string">&quot;&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">s2.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;è&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s3</span> = <span class="string">&quot;&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">s3.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;€&#x27;</span>);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;; &quot;</span>, s1.<span class="title function_ invoke__">capacity</span>(), s1.<span class="title function_ invoke__">len</span>());</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;; &quot;</span>, s2.<span class="title function_ invoke__">capacity</span>(), s2.<span class="title function_ invoke__">len</span>());</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, s3.<span class="title function_ invoke__">capacity</span>(), s3.<span class="title function_ invoke__">len</span>());</span><br></pre></td></tr></table></figure>
<p>这里可能打印：“4 1; 2 2; 3 3”。意味着在一个4字节的缓冲区ASCII字符<code>e</code>占一个字节，在一个两字节缓冲区重音字符<code>è</code>占两个字节，在一个3字节缓冲区货币符号<code>€</code>占三个字节。字节数由UTF-8标准导致，而缓冲区大小则由Rust标准库的实现决定，它可能会在将来的版本改进。</p>
<p>让我们看看当向一个动态字符串添加若干字符时发生了啥：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="string">&quot;&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; &#123;&#125; &#123;&#125;&quot;</span>,</span><br><span class="line">		s.<span class="title function_ invoke__">as_ptr</span>(), s.<span class="title function_ invoke__">capacity</span>(), s.<span class="title function_ invoke__">len</span>());</span><br><span class="line">	s.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; &#123;&#125; &#123;&#125;: &#123;&#125;&quot;</span>,</span><br><span class="line">	s.<span class="title function_ invoke__">as_ptr</span>(), s.<span class="title function_ invoke__">capacity</span>(), s.<span class="title function_ invoke__">len</span>(), s);</span><br></pre></td></tr></table></figure>
<p>在64位系统中，可能输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0x1 0 0</span><br><span class="line">0x7fbf95e20020 4 1</span><br><span class="line">0x7fbf95e20020 4 2</span><br><span class="line">0x7fbf95e20020 4 3</span><br><span class="line">0x7fbf95e20020 4 4</span><br><span class="line">0x7fbf95e20020 8 5</span><br><span class="line">0x7fbf95e20020 8 6</span><br><span class="line">0x7fbf95e20020 8 7</span><br><span class="line">0x7fbf95e20020 8 8</span><br><span class="line">0x7fbf95e2a000 16 9</span><br><span class="line">0x7fbf95e2a000 16 10: aaaaaaaaaa</span><br></pre></td></tr></table></figure>
<p>函数<code>as_ptr</code>(可以读作“as pointer”)返回堆空间分配的字符串缓冲区地址。</p>
<p>注意到当字符串是空的，该地址简化为<code>1</code>，它不是一个有效的内存地址，因为没有给一个空字符串指派任何缓冲。</p>
<p>当一个ASCII字符被添加，一个4字节缓冲区被分配在一个由十六进制7fbf95e20020表述的地址上。</p>
<p>添加另外3个字符后，没有再分配的发生，因为缓冲区已经足够大了。</p>
<p>当第五个字符被添加，要求重新分配，但，由于内存紧接着的缓冲区仍然为空闲，缓冲区可以扩展8个字节简化实现。因此为了避免在新缓冲区分配上的开销，拷贝4个已用的字节，回收前面的缓冲区。</p>
<p>再说一遍，添加另外3个字符，不要求再分配，当第九个字符被添加，不仅缓冲区扩展到16个字节，而且它必须重新定位地址，因为，接下来8字节可能并不是空闲的。</p>
<p>最后，字符串用了10字节。</p>
<h2 id="Creating-Strings"><a class="header-anchor" href="#Creating-Strings">¶</a>Creating Strings</h2>
<p>创建空的动态字符串有几种方式。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = <span class="string">&quot;&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s4</span> = <span class="string">&quot;&quot;</span>.<span class="title function_ invoke__">to_owned</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s5</span> = <span class="built_in">format!</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;(&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;)&quot;</span>, s1, s2, s3, s4, s5);</span><br></pre></td></tr></table></figure>
<p>打印“()”。</p>
<p><code>new</code>函数是<code>String</code>类型的基础构造器，类似于C++的“default constructor”。</p>
<p><code>from</code>函数为<code>String</code>类型的转换构造器，类似于C++的“non-default constructor”。</p>
<p>函数<code>to_string</code>和<code>to_owned</code>现在是可以替换的用法。由于历史的原因有几分不同。</p>
<p><code>format</code>宏是<code>print</code>宏的identical，唯一不同的是<code>print</code>是将结果发送到控制台，而<code>format</code>是返回一个<code>String</code>对象结果。</p>
<p>上述几种方式，除了<code>new</code>函数，都可以由一个非空静态字符串转换为动态字符串。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;a,&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(s);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = s.<span class="title function_ invoke__">to_owned</span>();</span><br><span class="line"><span class="comment">//let s4 = format!(s);</span></span><br><span class="line"><span class="comment">//let s5 = format!(&quot;a,&#123;&#125;&quot;);</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s6</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;(&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;)&quot;</span>, s1, s2, s3, s6);</span><br></pre></td></tr></table></figure>
<p>输出“<code>(a,a,a,a,)</code>”。</p>
<p>相反，在第五行和第六行会生成编译错误。实际上，<code>format</code>宏，和<code>print</code>还有<code>println</code>宏一样，要求它们第一个参数是一个字面量，以及这个字面量包含与连续参数相同数目的占位符。</p>
<h2 id="Concatenating-Strings"><a class="header-anchor" href="#Concatenating-Strings">¶</a>Concatenating Strings</h2>
<p>一个动态字符串也可以由两个静态字符串、两个动态字符串、或一个动态字符串一个静态字符串，组合得到。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">ss1</span> = <span class="string">&quot;He&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ss2</span> = <span class="string">&quot;llo &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ds1</span> = ss1.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ds2</span> = ss2.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ds3</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&quot;</span>, ss1, ss2);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, ds3);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ds3</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&quot;</span>, ss1, ds2);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, ds3);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ds3</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&quot;</span>, ds1, ss2);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, ds3);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ds3</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&quot;</span>, ds1, ds2);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, ds3);</span><br></pre></td></tr></table></figure>
<p>输出“<code>Hello Hello Hello Hello</code>”。</p>
<p>通常，一个字符串的出现由另一个字符串取决，当然它必须是mutable的。这样可以使用<code>format</code>宏，但它是冗长和低效的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">dyn_str</span> = <span class="string">&quot;Hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">dyn_str = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&quot;</span>, dyn_str, <span class="string">&quot;, &quot;</span>);</span><br><span class="line">dyn_str = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&quot;</span>, dyn_str, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">dyn_str = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&quot;</span>, dyn_str, <span class="string">&quot;!&quot;</span>);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, dyn_str);</span><br></pre></td></tr></table></figure>
<p>下面是一个比较好的写法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">dyn_str</span> = <span class="string">&quot;Hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">dyn_str.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">dyn_str.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">dyn_str.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;!&quot;</span>);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, dyn_str);</span><br></pre></td></tr></table></figure>
<p>函数<code>push_str</code>接收一个静态字符串，并把所有接收到的字符串push到后面。打印“Hello, world!”。</p>
<p>另外有一种更紧凑(compact)的写法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">dyn_str</span> = <span class="string">&quot;Hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">dyn_str += <span class="string">&quot;, &quot;</span>;</span><br><span class="line">dyn_str += <span class="string">&quot;world&quot;</span>;</span><br><span class="line">dyn_str += <span class="string">&quot;!&quot;</span>;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, dyn_str);</span><br></pre></td></tr></table></figure>
<p><code>+=</code>操作符，当作用在一个<code>String</code>对象时，等价于<code>push_str</code>函数。</p>
<p>也可以追加字符串对象或单个字符。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">comma</span> = <span class="string">&quot;, &quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">world</span> = <span class="string">&quot;world&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">excl_point</span> = <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">dyn_str</span> = <span class="string">&quot;Hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">dyn_str += &amp;comma;</span><br><span class="line">dyn_str.<span class="title function_ invoke__">push_str</span>(&amp;world);</span><br><span class="line">dyn_str.<span class="title function_ invoke__">push</span>(excl_point);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, dyn_str);</span><br></pre></td></tr></table></figure>
<p>该程序和上一个是等价的。注意到将动态字符串作为参数传递给<code>push_str</code>或<code>+=</code>时，必须预先转换为静态字符串。这个效果使用<code>&amp;</code>操作符获得。实际上，可以用该操作符，获得一个<code>String</code>的引用，但任何一个<code>String</code>的引用，会隐式转换为一个<code>str</code>引用，如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">word</span> = <span class="string">&quot;bye&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">w1</span>: &amp;<span class="type">str</span> = &amp;word;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">w2</span>: &amp;<span class="type">String</span> = &amp;word;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, w1, w2);</span><br></pre></td></tr></table></figure>
<p>打印为：“bye bye”。</p>
</div></article><nav class="article-nav"><div class="article-nav-prev"><a href="/2023/01/15/rust/beginning/chapter15_Ranges%20and%20Slices/">rust基础入门[15] - Ranges and Slices</a></div><div class="article-nav-next"><a href="/2023/01/13/rust/beginning/chapter13_Defining%20Closures/">rust基础入门[13] - Defining Closures</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2023/01/14/rust/beginning/chapter14_Using Changeable Strings/';
var disqus_title = 'rust基础入门[14] - Using Changeable Strings';
var disqus_url = 'https://galudisu.info/2023/01/14/rust/beginning/chapter14_Using Changeable Strings/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>