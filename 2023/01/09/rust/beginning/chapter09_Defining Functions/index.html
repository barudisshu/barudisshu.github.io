<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>rust基础入门[09] - Defining Functions</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">rust基础入门[09] - Defining Functions</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2023-01-09</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/rust/">rust</a></p><p class="meta-item meta-category"><span class="meta-item-title"></span><i class="icon-bookmark"> </i><a class="category-link" href="/categories/learning/">learning</a></p></div><div class="article-content"><p>本章覆盖有：</p>
<ul>
<li>如何定义程序/函数,如何调用</li>
<li>同名函数</li>
<li>函数的参数如何传递，by-value还是by-reference</li>
<li>函数的返回值</li>
<li>如何提前退出一个函数</li>
<li>对象的引用如何控制</li>
</ul>
<span id="more"></span>
<h2 id="Defining-and-Invoking-a-Function"><a class="header-anchor" href="#Defining-and-Invoking-a-Function">¶</a>Defining and Invoking a Function</h2>
<p>函数的定义比较简单，以<code>fn</code>关键字开头，函数名+参数+块。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>() &#123;</span><br><span class="line">    <span class="comment">// your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个块是函数的“body”，对这个body的处理称为函数署名“signature”。</p>
<p>同大多数语言一样，main方法/函数式程序的入口，它由机器码调用。</p>
<p>和C有点不同的是，函数的定义，可以在其它函数的body内直接定义。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f1</span>() &#123; <span class="built_in">print!</span>(<span class="string">&quot;1&quot;</span>); &#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">f1</span>();</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f2</span>() &#123; <span class="built_in">print!</span>(<span class="string">&quot;2&quot;</span>); &#125;</span><br><span class="line">    <span class="title function_ invoke__">f2</span>(); <span class="title function_ invoke__">f1</span>(); <span class="title function_ invoke__">f2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，块定义的函数作用范围仅在其块内。</p>
<h2 id="Functions-Defined-After-Their-Use"><a class="header-anchor" href="#Functions-Defined-After-Their-Use">¶</a>Functions Defined After Their Use</h2>
<p>下面代码是不合法的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>因为变量在定义前被调用了；对于函数，只要在作用范围内，顺序不受影响，下面是有效的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">f</span>();</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>() &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Functions-Shadowing-Other-Functions"><a class="header-anchor" href="#Functions-Shadowing-Other-Functions">¶</a>Functions Shadowing Other Functions</h2>
<p>前面说过，变量声明如果同名，变量会被投影。但是函数却不能这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这样写会有编译错误：“the name <code>f</code> is defined multiple times”。</p>
<p>只有在不同的块里面，才可以定义多个同名的函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>() &#123; <span class="built_in">print!</span>(<span class="string">&quot;a&quot;</span>); &#125;</span><br><span class="line">    <span class="title function_ invoke__">f</span>(); <span class="title function_ invoke__">f</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>() &#123; <span class="built_in">print!</span>(<span class="string">&quot;b&quot;</span>); &#125;</span><br><span class="line">    <span class="title function_ invoke__">f</span>(); <span class="title function_ invoke__">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果将输出：“aab”。</p>
<p>并且不能再语句块外部调用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">f</span>();</span><br></pre></td></tr></table></figure>
<p>编译器会抱怨：“cannot find function <code>f</code> in this scope”。</p>
<p>最后，函数投影，仅能投影语句块外部定义的。下面是完整例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>() &#123; <span class="built_in">print!</span>(<span class="string">&quot;1&quot;</span>); &#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>(); <span class="comment">// Prints 2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_ invoke__">fn</span>(); <span class="comment">// Prints 3</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">f</span>() &#123; <span class="built_in">print!</span>(<span class="string">&quot;3&quot;</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">f</span>(); <span class="comment">// Prints 2</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>() &#123; <span class="built_in">print!</span>(<span class="string">&quot;2&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，按照编译器的思路，当调用<code>fn()</code>时，会先找临近的块作用范围，如果有，则调用最近路径上的函数。如果没有，则往下一个节点寻找(类似于树的深度搜索)。</p>
<h2 id="Passing-Arguments-to-a-Function"><a class="header-anchor" href="#Passing-Arguments-to-a-Function">¶</a>Passing Arguments to a Function</h2>
<p>可以将参数传递给函数，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_sum</span>(addend1: <span class="type">f64</span>, addend2: <span class="type">f64</span>) &#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, addend1, addend2, addend1 + andend2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">print_sum</span>(<span class="number">3</span>., <span class="number">5</span>.);</span><br><span class="line"><span class="title function_ invoke__">print_sum</span>(<span class="number">3.2</span>, <span class="number">5.1</span>);</span><br></pre></td></tr></table></figure>
<p>3 + 5 = 8<br>
3.2 + 5.1 = 8.3</p>
<p>现在先来理解下圆括号(parentheses)的用法！在一个函数定义，闭合着参数定义列表；该闭合参数在函数调用时传递。</p>
<p>函数参数的定义和变量的定义类似。</p>
<p>因此，下面代码会被解析：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">addend1</span>: <span class="type">f64</span> = <span class="number">3</span>.; <span class="keyword">let</span> <span class="variable">addend2</span>: <span class="type">f64</span> = <span class="number">5</span>.;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, addend1, addend2,</span><br><span class="line">		addend1 + addend2);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">addend1</span>: <span class="type">f64</span> = <span class="number">3.2</span>; <span class="keyword">let</span> <span class="variable">addend2</span>: <span class="type">f64</span> = <span class="number">5.1</span>;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, addend1, addend2,</span><br><span class="line">		addend1 + addend2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数参数定义和变量定义的主要不同是，函数参数的定义，类型是必须的，它不能依赖于类型推断。</p>
<p>类型推断总是被用于编译器检查，确保接收的参数是实际参数的声明类型。正是这样，下面代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>(a: <span class="type">i16</span>) &#123;&#125;</span><br><span class="line"><span class="title function_ invoke__">f</span>(<span class="number">3</span>.);</span><br><span class="line"><span class="title function_ invoke__">f</span>(<span class="number">3u16</span>);</span><br><span class="line"><span class="title function_ invoke__">f</span>(<span class="number">3i16</span>);</span><br><span class="line"><span class="title function_ invoke__">f</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>会发生错误，因为浮点类型不能传递给一个整型参数；第二个函数调用也一样，u16类型的值不能传递给一个i16的参数。</p>
<p>最后两个函数调用是运行的。实际上，第三处调用传递了正确的参数类型；第四处调用，它被类型推断，传递了unconstrained integer类型。</p>
<h2 id="Passing-Arguments-by-Value"><a class="header-anchor" href="#Passing-Arguments-by-Value">¶</a>Passing Arguments by Value</h2>
<p>注意参数不是简单传递对象的新名，它不是别名；实际上他们是对象的拷贝。该拷贝在函数调用时被创建，函数结束并return给调用者时拷贝被销毁。下面例子阐明这个概念：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_double</span>(<span class="keyword">mut</span> x: <span class="type">f64</span>) &#123;</span><br><span class="line">	x *= <span class="number">2</span>.;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">4</span>.;</span><br><span class="line"><span class="title function_ invoke__">print_double</span>(x);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot; &#123;&#125;&quot;</span>, x);</span><br></pre></td></tr></table></figure>
<p>结果输出：“8 4”。<br>
变量名“x”被声明并初始化，然后传递给函数“print_double”，该函数包含一个参数“x”，函数执行正确后返回给调用者。</p>
<p>实际上，不是 <strong>变量</strong> 传递给函数，二是变量的 <strong>值</strong> 。它称为 <strong>值传递</strong> ，和C语言类似。变量“x”的值被用于初始化一个新变量，这个新变量为函数的参数。新的变量被修改，并在函数体内打印，最后由函数结束销毁。该函数的调用者的变量并没有发生改变。</p>
<p>注意这里的函数签名“print_double”，在参数“x”前有关键字“<code>mut</code>”。它允许函数体内第一条语句；至此，该语句仅改变函数参数的值，函数外部的变量并没有发生改变，所以外部的“x”不需要用<code>mut</code>关键字修饰。</p>
<h2 id="Returning-a-Value-from-a-Function"><a class="header-anchor" href="#Returning-a-Value-from-a-Function">¶</a>Returning a Value from a Function</h2>
<p>函数若要给调用者返回一个结果：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">double</span>(x: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123; x * <span class="number">2</span>. &#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">double</span>(<span class="number">17.3</span>));</span><br></pre></td></tr></table></figure>
<p>返回值实际上是函数体自身。因为函数体是个块，所以它的值就是最后一个表达式的值，否则就是一个空tuple ()。</p>
<p>函数的返回类型，在C语言写在函数名前面，在Rust则写在后面，并由符号“<code>-&gt;</code>”隔离。</p>
<p>如果没有指定返回类型，默认是空tuple，即前面说的“()”：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f1</span>(x: <span class="type">i32</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f2</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> () &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>函数体的类型，必须与函数签名指定的类型相同，或者无符号类型可以约束的类型。因此下面代码是合法的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f1</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; <span class="number">4.5</span>; <span class="string">&quot;abc&quot;</span>; <span class="number">73i32</span> &#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f2</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; <span class="number">4.5</span>; <span class="string">&quot;abc&quot;</span>; <span class="number">73</span> &#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f3</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; <span class="number">4.5</span>; <span class="string">&quot;abc&quot;</span>; <span class="number">73</span> + <span class="number">100</span> &#125;</span><br></pre></td></tr></table></figure>
<p>下面代码不合法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f1</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; <span class="number">4.5</span>; <span class="string">&quot;abc&quot;</span>; <span class="literal">false</span> &#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f2</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; <span class="number">4.5</span>; <span class="string">&quot;abc&quot;</span>; () &#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f3</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; <span class="number">4.5</span>; <span class="string">&quot;abc&quot;</span>; &#123;&#125; &#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f4</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; <span class="number">4.5</span>; <span class="string">&quot;abc&quot;</span>; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Early-Exit"><a class="header-anchor" href="#Early-Exit">¶</a>Early Exit</h2>
<p>要让一个函数从某条中间语句结束，可以使用<code>return</code>关键字返回，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>(x: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x &lt;= <span class="number">0</span>. &#123; <span class="keyword">return</span> <span class="number">0</span>.; &#125;</span><br><span class="line">	x + <span class="number">3</span>.</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, <span class="title function_ invoke__">f</span>(<span class="number">1</span>.), <span class="title function_ invoke__">f</span>(-<span class="number">1</span>.));</span><br></pre></td></tr></table></figure>
<p><code>return</code>关键字和C语言类似，不同的是最后一个语句可以不写。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>(x: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x &lt;= <span class="number">0</span>. &#123; <span class="keyword">return</span> <span class="number">0</span>.; &#125;</span><br><span class="line">	<span class="keyword">return</span> x + <span class="number">3</span>.;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, <span class="title function_ invoke__">f</span>(<span class="number">1</span>.), <span class="title function_ invoke__">f</span>(-<span class="number">1</span>.));</span><br></pre></td></tr></table></figure>
<p>上面的写法不是严谨的，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>(x: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &lt;= <span class="number">0</span>. &#123; <span class="number">0</span>. &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; x + <span class="number">3</span>. &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, <span class="title function_ invoke__">f</span>(<span class="number">1</span>.), <span class="title function_ invoke__">f</span>(-<span class="number">1</span>.));</span><br></pre></td></tr></table></figure>
<p>如果函数签名指定的是空tuple，可以有多种写法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>(x: <span class="type">i32</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> x &lt;= <span class="number">0</span> &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="number">4</span> &#123; <span class="title function_ invoke__">return</span> (); &#125;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="number">7</span> &#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">f</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>任何函数调用可被看做一个有效语句：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; <span class="number">3</span> &#125;</span><br><span class="line"><span class="title function_ invoke__">f</span>();</span><br></pre></td></tr></table></figure>
<p>这里，返回值被忽略并立即销毁。</p>
<p>相反，如果返回值被使用，如下，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_a</span>: <span class="type">i32</span> = <span class="title function_ invoke__">f</span>();</span><br></pre></td></tr></table></figure>
<p>它必须是一个正确的类型。</p>
<h2 id="Returning-Several-Values"><a class="header-anchor" href="#Returning-Several-Values">¶</a>Returning Several Values</h2>
<p>可以使用tuple返回多个值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(dividend: <span class="type">i32</span>, divisor: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> (<span class="type">i32</span>, <span class="type">i32</span>) &#123;</span><br><span class="line">	(dividend / divisor, dividend % divisor)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">divide</span>(<span class="number">50</span>, <span class="number">11</span>));</span><br></pre></td></tr></table></figure>
<p>结果输出“(4, 6)”</p>
<p>或者你可以返回一个enum, struct, tuple struct, array, vector：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">E</span> &#123; E1, E2 &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123; a: <span class="type">i32</span>, b: <span class="type">bool</span> &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TS</span> (<span class="type">f64</span>, <span class="type">char</span>);</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f1</span>() <span class="punctuation">-&gt;</span> E &#123; E::E2 &#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f2</span>() <span class="punctuation">-&gt;</span> S &#123; S &#123; a: <span class="number">49</span>, b: <span class="literal">true</span> &#125; &#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f3</span>() <span class="punctuation">-&gt;</span> TS &#123; <span class="title function_ invoke__">TS</span> (<span class="number">4.7</span>, <span class="string">&#x27;w&#x27;</span>) &#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f4</span>() <span class="punctuation">-&gt;</span> [<span class="type">i16</span>; <span class="number">4</span>] &#123; [<span class="number">7</span>, -<span class="number">2</span>, <span class="number">0</span>, <span class="number">19</span>] &#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f5</span>() <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">i64</span>&gt; &#123; <span class="built_in">vec!</span>[<span class="number">12000</span>] &#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, <span class="keyword">match</span> <span class="title function_ invoke__">f1</span>() &#123; E::E1 =&gt; <span class="number">1</span>, _ =&gt; -<span class="number">1</span> &#125;);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, <span class="title function_ invoke__">f2</span>().a);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, <span class="title function_ invoke__">f3</span>().<span class="number">0</span>);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, <span class="title function_ invoke__">f4</span>()[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, <span class="title function_ invoke__">f5</span>()[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>结果输出“&quot;-1 49 4.7 7 12000”。</p>
<p>下面解析下。</p>
<p>函数<code>f1</code>调用返回一个枚举E2，并用于匹配E1，没有匹配，返回默认值-1。<br>
函数<code>f2</code>调用返回一个结构对象，并访问该结构的field。<br>
函数<code>f3</code>调用返回一个tuple-struct，通过数字identifiered访问field。<br>
函数<code>f4</code>调用返回一个数组，并获取数组下标的值。<br>
函数<code>f4</code>调用返回一个向量，并获取向量下标的值。</p>
<h2 id="How-to-Change-a-Variable-of-the-Caller"><a class="header-anchor" href="#How-to-Change-a-Variable-of-the-Caller">¶</a>How to Change a Variable of the Caller</h2>
<p>假设我们要对数组作平方处理：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">5</span>, -<span class="number">4</span>, <span class="number">9</span>, <span class="number">0</span>, -<span class="number">7</span>, -<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> arr[i] &lt; <span class="number">0</span> &#123; arr[i] *= <span class="number">2</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br></pre></td></tr></table></figure>
<p>现在要将其封装成一个函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">double_negatives</span>(<span class="keyword">mut</span> a: [<span class="type">i32</span>; <span class="number">10</span>]) &#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> a[i] &lt; <span class="number">0</span> &#123; a[i] *= <span class="number">2</span>; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">5</span>, -<span class="number">4</span>, <span class="number">9</span>, <span class="number">0</span>, -<span class="number">7</span>, -<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>];</span><br><span class="line"><span class="title function_ invoke__">double_negatives</span>(arr);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br></pre></td></tr></table></figure>
<p>结果仅输出“[5, -4, 9, 0, -7, -1, 3, 5, 3, 1].”。并没有达到预期。</p>
<p>前面说个，函数的参数是变量的一个拷贝，因此没有办法直接修改外部变量。你可以：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">double_negatives</span>(<span class="keyword">mut</span> a: [<span class="type">i32</span>; <span class="number">10</span>]) <span class="punctuation">-&gt;</span> [<span class="type">i32</span>; <span class="number">10</span>] &#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> a[i] &lt; <span class="number">0</span> &#123; a[i] *= <span class="number">2</span>; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">5</span>, -<span class="number">4</span>, <span class="number">9</span>, <span class="number">0</span>, -<span class="number">7</span>, -<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>];</span><br><span class="line">arr = <span class="title function_ invoke__">double_negatives</span>(arr);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br></pre></td></tr></table></figure>
<p>这种方法有点遗憾：数据被拷贝了两次，第一次发生在函数调用上，第二次发生在覆盖赋值上。这种拷贝会造成额外的计算消耗，并且可以避免的。</p>
<h2 id="Passing-Arguments-by-Reference"><a class="header-anchor" href="#Passing-Arguments-by-Reference">¶</a>Passing Arguments by Reference</h2>
<p>函数可以传递被传参数的地址，这个方式称为引用传递，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">double_negatives</span>(a: &amp;<span class="keyword">mut</span> [<span class="type">i32</span>; <span class="number">10</span>]) &#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (*a)[i] &lt; <span class="number">0</span> &#123; (*a)[i] *= <span class="number">2</span>; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">5</span>, -<span class="number">4</span>, <span class="number">9</span>, <span class="number">0</span>, -<span class="number">7</span>, -<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>];</span><br><span class="line"><span class="title function_ invoke__">double_negatives</span>(&amp;<span class="keyword">mut</span> arr);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br></pre></td></tr></table></figure>
<p>该代码没有发生数据拷贝的现象。</p>
<p>这种方式称为引用传递(by reference)。它的语法和C语言的类似。</p>
<p>这里出现了符号“<code>&amp;</code>”和“<code>*</code>”，在Rust中表示的意义和C语言一样。符号“<code>&amp;</code>”表示“<code>对象的(内存)地址...</code>”，符号“<code>*</code>”表示“<code>(内存)地址的对象...</code>”。</p>
<p>函数<code>double_negatives</code>的参数类型是<code>&amp;mut [i32; 10]</code>，在类型前面带一个<code>&amp;</code>符号，指明它是类型对象的地址(也叫指针、引用)。因此，<code>a</code>在这里表示的是“长度为10的32位整型数组的地址(指针、引用)”。</p>
<p>在函数体内，我们并不关心这个地址(指针、引用)，而是这个内存地址的对象，所以我们需要用<code>*</code>访问该对象。通常，给定一个引用<code>a</code>，表达式<code>*a</code>标识为该对象的引用。</p>
<p>函数方法内的第二行，<code>*a</code>标识为内存地址之上的对象，这个对象就是数组，因此可以用下标访问。</p>
<p>围绕表达式<code>*a</code>的圆括号是必须的，因为方括号优先于星号，所以<code>*a[i]</code>会被当做<code>*(a[i])</code>处理，并且这里会发生编译错误。</p>
<p>使用这类参数，函数<code>double_negatives</code>仅接收一个数组的地址，因此可以对该数组进行读写操作。</p>
<p>声明该函数后，要调用该函数。数组必须声明以及初始化为可变(mutable)，因为它内部会发生改变。</p>
<p>注意，调用函数需要显式带上<code>mut</code>关键字一并传递。</p>
<p>实际上，该函数可以简化成下面等价的版本：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">double_negatives</span>(a: &amp;<span class="keyword">mut</span> [<span class="type">i32</span>; <span class="number">10</span>]) &#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> a[i] &lt; <span class="number">0</span> &#123; a[i] *= <span class="number">2</span>; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们删除了两个星号，以及圆括号，</p>
<p>我们说过这里的<code>a</code>不是一个数组，而是数组的地址，那么这里的<code>a[i]</code>表达式应该不合法才对。目前Rust对这类地址作了如下简化：</p>
<p>每当一个引用被不正确使用，即它是一个非引用值时，Rust会假装前面有一个星号(asterisk)。也就是Rust对其进行了反向引用(dereference)，所以这里把内存地址(指针、引用)替代为引用自身。</p>
<p>由此产生的语法就是C<ins>的引用，Rust的不同之处在于，星号(asterisk)可以写、可以省略，但C</ins>必须在指针前面写，必须不能在引用前面写。</p>
<h2 id="Using-References"><a class="header-anchor" href="#Using-References">¶</a>Using References</h2>
<p>引用主要用于函数参数上，但也可能用在其他地方：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ref_a</span> = &amp;a;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, a, *ref_a, ref_a);</span><br></pre></td></tr></table></figure>
<p>结果输出：“15 15 15”。</p>
<p>前面阐述过，<code>ref_a</code>是一个内存地址，<code>*ref_a</code>标识为该内存地址上的对象引用，最后一个语句，编译器尝试直接输出<code>ref_a</code>时，会反向获取该引用的对象，并输出结果。</p>
<p>使用引用，你可以做一些技巧性的事情：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = &amp;&amp;&amp;<span class="number">7</span>;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, ***a, **a, *a, a);</span><br></pre></td></tr></table></figure>
<p>这里的<code>a</code>就变成了7的引用的引用的引用… 所以输出结果就变成了引用的引用的引用的对象… 但这里你不能再加多星号(asterisk)，否则会发生编译错误，因为反向引用只发生了3层。</p>
<p>最后一个表达式是隐式的、顺序性的、重复了上面几个步骤。</p>
<p>什么情况下星号才能被省略，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123; <span class="title function_ invoke__">a</span>(); <span class="title function_ invoke__">b</span>(); <span class="title function_ invoke__">c</span>(); <span class="title function_ invoke__">d</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">a</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = &amp;v;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a &#123;&#125;&quot;</span>, *x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a &#123;&#125;&quot;</span>, <span class="number">1</span> + *x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">b</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = &amp;v;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b &#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b &#123;&#125;&quot;</span>, <span class="number">1</span> + x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">c</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = &amp;<span class="keyword">mut</span> v;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c &#123;&#125;&quot;</span>, *x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c &#123;&#125;&quot;</span>, <span class="number">1</span> + *x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">d</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = &amp;<span class="keyword">mut</span> v;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;d &#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;d &#123;&#125;&quot;</span>, <span class="number">1</span> + x); <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一个会出错：<code>the trait bound \</code>_: std::ops::Add&lt;&amp;mut _&gt;` is not satisfied [E0277]`。</p>
<p>这是因为对于<code>Add</code>trait的操作，内部实现了<code>i32 + &amp;32</code>(<code>&amp;i32 + &amp;i32</code>)的处理，但是，对于immutable reference没有扩展有<code>&amp;&amp;i32</code> 或 <code>&amp;mut i32</code>的实现。</p>
<h2 id="Mutablility-of-References"><a class="header-anchor" href="#Mutablility-of-References">¶</a>Mutablility of References</h2>
<p>如何在reference上使用mut关键字：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span>: <span class="type">i32</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span>: <span class="type">i32</span> = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">p</span>: &amp;<span class="keyword">mut</span> <span class="type">i32</span> = &amp;<span class="keyword">mut</span> a;	<span class="comment">// line 3</span></span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, *p);</span><br><span class="line">*p += <span class="number">1</span>;	<span class="comment">// line 5</span></span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, *p);</span><br><span class="line">p = &amp;<span class="keyword">mut</span> b;	<span class="comment">// line 7</span></span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, *p);</span><br><span class="line">*p += <span class="number">1</span>;	<span class="comment">// line 9</span></span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, *p);</span><br></pre></td></tr></table></figure>
<p>结果输出为：“10 11 20 21”。</p>
<p>注意第5行和第9行，<code>*p</code>是mutable的。所以<code>p</code>的类型不能是<code>&amp;i32</code>，必须是<code>&amp;mut i32</code>。这里的<code>p</code>有很多处<code>mut</code>，表示了不同的意义：第一个<code>mut</code>表示<code>p</code>是一个可变的变量，可以被修改，第二个<code>mut</code>作为了它的类型，表示它的引用类型可以修改。</p>
</div></article><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2023/01/09/rust/beginning/chapter09_Defining Functions/';
var disqus_title = 'rust基础入门[09] - Defining Functions';
var disqus_url = 'https://galudisu.info/2023/01/09/rust/beginning/chapter09_Defining Functions/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>