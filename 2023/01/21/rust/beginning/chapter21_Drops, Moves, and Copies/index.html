<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>rust基础入门[21] - Drops, Moves, and Copies</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/maths/">Maths</a></li><li class="menu-item"><a class="menu-link" href="/projects/">Projects</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/maths/">Maths</a></li><li class="menu-item"><a class="menu-link" href="/projects/">Projects</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">rust基础入门[21] - Drops, Moves, and Copies</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2023-01-21</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/rust/">rust</a></p><p class="meta-item meta-category"><span class="meta-item-title"></span><i class="icon-bookmark"> </i><a class="category-link" href="/categories/learning/">learning</a></p></div><div class="article-content"><p>本章覆盖有：</p>
<ul>
<li>为什么决定性的(deterministic)、隐式(implicit)的对象销毁是Rust的一大亮点</li>
<li>对象所有者(ownership)的概念</li>
<li>为什么自定义销毁可能有用，怎么创建</li>
<li>三种赋值语义：共享(share)、拷贝(copy)、移动(move)</li>
<li>为什么隐式共享对软件正确性是糟糕的</li>
<li>为什么对象的移动(move semantics)比起拷贝(copy semantics)可能有更好的性能</li>
<li>为什么某些类型需要拷贝(copy semantics)，某些不需要，怎么区分</li>
<li>为什么某些类型需要是不可复制的(non-cloneable)，怎么区分</li>
</ul>
<span id="more"></span>
<h2 id="Deterministic-Destruction"><a class="header-anchor" href="#Deterministic-Destruction">¶</a>Deterministic Destruction</h2>
<p>前面，我们看到有几种内存分配对象的方式，这些分配都是在stack和heap发生：</p>
<ul>
<li>临时表达式，分配在stack；</li>
<li>变量(包括数组)，分配在stack；</li>
<li>函数和闭包的参数，分配在stack；</li>
<li><code>Box</code>对象，引用分配在stack，引用的对象分配在heap；</li>
<li>动态字符串和集合(包括vector）,header分配在stack，数据分配在heap。</li>
</ul>
<p>对象“<strong>真实</strong>”的瞬时分配是很难预测的，因为它取决于编译器优化。因此，我们考虑“<strong>概念</strong>”上的瞬时分配情况。</p>
<p>概念上，当对应表达式第一次出现在代码时发生stack分配，因此：</p>
<ul>
<li>临时表达式，变量，数组在它们第一次出现在代码时被分配；</li>
<li>函数和闭包的参数，在函数/闭包被调用时被分配；</li>
<li><code>Box</code>对象，动态字符串，集合header，在代码第一出现时被分配。</li>
</ul>
<p>heap的当需要这些数据时，进行heap分配。因此：</p>
<ul>
<li><code>Box</code>对象的分配，由<code>Box::new</code>函数触发；</li>
<li>动态字符串的字符分配，在字符被添加到该字符串时触发；</li>
<li>集合内容的分配，出现在有数据被添加到集合时。</li>
</ul>
<p>上面这些跟大多数编程语言没不同之处。那么数据的销毁在什么时候发生？</p>
<p>概念上，在Rust中，当这些数据不再可被访问时，自动销毁。因此：</p>
<ul>
<li>临时表达式被回收，当它在语句的结束位置(即，在下一个<code>;</code>位置或当前scope的结束位置)；</li>
<li>变量(包括数组)被回收，当它在scope的声明结束；</li>
<li>函数/闭包的参数的回收，出现在函数/闭包体结束；</li>
<li><code>Box</code>对象的回收，在当前scope的声明结束；</li>
<li>动态字符串的字符被回收，出现在从字符串中删除该字符时，或者整个字符串删除时；</li>
<li>集合中的条目被回收，出现在从集合中删除该条目时，或者整个集合被删除时。</li>
</ul>
<p>这一概念使得Rust和大部分语言区分开来。任何语言都有临时对象或栈分配(stack-allocated)对象，这种对象是自动回收的。但堆分配(heap-allocated)对象的回收，不同语言各不相同。</p>
<p>在某些语言中，诸如Pascal，C，C++，heap上的对象通常仅能显式地调用类似<code>free</code>或<code>delete</code>这些函数进行回收。另一些语言，诸如Java，JavaScript，C+，Python，堆上的对象不可访问时，并没有立即进行回收，而是有一个定期的行程，用来查找heap不可达对象，并回收这些对象。这种机制称为“垃圾回收”，因为它类似城市的清理系统：它定期清理城镇，当有垃圾堆积。</p>
<p>因此，在C++和类似语言中，heap回收既是<code>决定性的，deterministic</code>，也是<code>显式的，explicit</code>。决定性的，因为它在源代码的定义位置，以及是显式的，因为它要求程序员编写指定的回收语句。决定性的好处在于，可能有更好的性能，程序员可能更好地控制。但显式的却不好，因为不能避免出现错误的回收，丑陋的bug结果。</p>
<p>相反，在Java和类似语言中，heap回收既是<code>非决定性的，non-deterministic</code>，也是<code>隐式的，implicit</code>。非决定性的，因为它出现未知的执行瞬时，以及是隐式的，因为它不需要指定回收语句。非决定性是糟糕的，但隐式的美好的。</p>
<p>区别于这两种技术，在Rust中，通常，heap的回收既是<code>决定性的，deterministic</code>，也是<code>隐式的，implicit</code>，这是Rust比起其它语言更大的优势。</p>
<p>这种可能性的实现，是因为遵循了基于“<code>所有者，ownership</code>”的概念，</p>
<h2 id="Ownership"><a class="header-anchor" href="#Ownership">¶</a>Ownership</h2>
<p>首先介绍术语“<strong><code>to own</code></strong>”。在计算机科学中，对于一个标识符或一个对象A，拥有(to own)对象B，意味着A可以对B进行回收，它有两个意义：</p>
<ul>
<li>Only A can deallocate B.</li>
<li>When A becomes unreachable, A must deallocate B.</li>
</ul>
<p>在Rust中没有显示的回收机制，因此这种定义可以复述为“A owns B means that B is deallocated  when and only when A becomes unreachable”。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">3</span>;</span><br><span class="line">a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = <span class="built_in">vec!</span>[<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>];</span><br></pre></td></tr></table></figure>
<p>该程序，变量<code>a</code>拥有一个对象初始化值3，因为当<code>a</code>离开了它的scope，变成不可访问，该初始化值为3的对象被回收。我们也可以这样说“<code>a</code>是一个对象的所有者，它由值3初始化”。尽管，我们不能说“<code>a</code>拥有3”，因为3是一个值，不是对象；仅对象才能被拥有(owned)。在内存中，有很多对象值是3的，<code>a</code>拥有其中一个。在第二条语句中，该对象的值变为4；但它的拥有者没有变。</p>
<p>在最后一条语句中，<code>b</code>由一个5个元素的vector初始化。这个vector由一个头(header)和一个数据缓冲区(data buffer)；header的实现由一个结构体三个filed表示：一个执行data buffer的指针，两个数(capacity、len)；数据缓冲区包含5个条目，另外可能有额外的空间。这里我们可以说“<code>b</code>拥有vector的header，以及一个指针，该指针包含数据缓冲区的拥有者头(header)”。实际上，当<code>b</code>离开了它的scope，vector的头被回收；当vector的header被回收后，它包含的指针不可访问；当前的vector表示为一个空，因此缓冲区的条目被回收。</p>
<p>不是每个引用所有者是一个对象，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">3</span>;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">a_ref</span> = &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br></pre></td></tr></table></figure>
<p>这里的<code>a_ref</code>变量拥有一个引用，但这个引用什么都没有。实际上，在这个嵌入块的结束位置，<code>a_ref</code>变量离开了它的scope，该引用被回收，但引用对象，即这个包含值3的对象，没有立即被回收，因为它必须在最后一条语句打印输出。</p>
<p>为了确保每个对象自动回收，Rust中有一个简单规则，在每个执行的瞬时，每个对象有且仅能有一个“owner”。当这个owner被回收，该对象自身被回收。如果一个对象有几个owner，这个对象可能被回收几次，这是不被允许的。如果对象没有owner，该对象从不被回收，这种情况叫做“内存泄露，memory leak”。</p>
<h2 id="Destructors"><a class="header-anchor" href="#Destructors">¶</a>Destructors</h2>
<p>我们看到对象的创建有两步：给对象分配内存，初始化这个内存空间的值。对于复杂对象，初始化是如此复杂，通常需要使用一个函数实现。这个函数叫“构造器”，用来“构造”一个新的对象。</p>
<p>我们刚看到，当一个对象被回收，会发生一些复杂情况。如果在heap中一个对象引用另一个对象，一个级联(cascade)的回收可能会发生。因此，对象的“销毁”可能需要由一个函数处理，称作“destructor，焚烧炉，销毁装置”。</p>
<p>通常销毁器是属于标准库的一部分，但有时你可能需要在对象回收时做一些cleanup code操作，所以你需要写一个destructor。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CommunicationChannel</span> &#123;</span><br><span class="line">    address: <span class="type">String</span>,</span><br><span class="line">    port: <span class="type">u16</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">CommunicationChannel</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Closing port &#123;&#125;:&#123;&#125;&quot;</span>, <span class="keyword">self</span>.address, <span class="keyword">self</span>.port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">CommunicationChannel</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create</span>(address: &amp;<span class="type">str</span>, port: <span class="type">u16</span>) <span class="punctuation">-&gt;</span> CommunicationChannel &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Operning port &#123;&#125;:&#123;&#125;&quot;</span>, address, port);</span><br><span class="line">        CommunicationChannel &#123;</span><br><span class="line">            address: address.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            port: port,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, msg: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Sent to &#123;&#125;:&#123;&#125; the message &#x27;&#123;&#125;&#x27;&quot;</span>, <span class="keyword">self</span>.address, <span class="keyword">self</span>.port, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">channel</span> = CommunicationChannel::<span class="title function_ invoke__">create</span>(<span class="string">&quot;usb4&quot;</span>, <span class="number">879</span>);</span><br><span class="line">channel.<span class="title function_ invoke__">send</span>(<span class="string">&quot;Message 1&quot;</span>);</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">channel</span> = CommunicationChannel::<span class="title function_ invoke__">create</span>(<span class="string">&quot;eth1&quot;</span>, <span class="number">12000</span>);</span><br><span class="line">	channel.<span class="title function_ invoke__">send</span>(<span class="string">&quot;Message 2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">channel.<span class="title function_ invoke__">send</span>(<span class="string">&quot;Message 3&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>该程序将打印：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Operning port usb4:879</span><br><span class="line">Sent to usb4:879 the message &#x27;Message 1&#x27;</span><br><span class="line">Operning port eth1:12000</span><br><span class="line">Sent to eth1:12000 the message &#x27;Message 2&#x27;</span><br><span class="line">Closing port eth1:12000</span><br><span class="line">Sent to usb4:879 the message &#x27;Message 3&#x27;</span><br><span class="line">Closing port usb4:879</span><br></pre></td></tr></table></figure>
<p>第二条语句声明新的类型CommunicationChannel用于实现<code>Drop</code>。这个trait有一个特有的方法<code>drop</code>，它会在对象被回收时自动被调用，因此它是一个“destructor”。通常，给一个类型创建一个销毁器，为该类型实现这个<code>Drop</code>trait即可。因为任何没有被定义的trait，不能在程序外部实现。</p>
<p>第三条语句是一个语句块，为结构体定义了两个方法：<code>create</code>构造器，<code>send</code>方法。</p>
<p>最后是应用代码。创建了一个CommunicationChannel，这个创建会打印一行内容。接着调用了send方法，打印第二行内容。接着是内嵌语句块，创建了另一个channel，打印第三、四行内容。</p>
<p>嵌套语句块内的变量名跟存在的变量名相同，这会导致变量投影(shadow)。</p>
<p>接着嵌套语句结束。这发生率内部变量被销毁，因此它的<code>drop</code>方法被调用，于是打印第五行。</p>
<p>现在，嵌套语句块结束后，第一个变量再次可见。<code>send</code>方法再次调用，打印一行。</p>
<p>最后，变量被销毁，打印最后一行。</p>
<p>在Rust中，内存早已由语言和标准库释放掉了，因此没有必要像C语言那样调用<code>free</code>函数，或像C++那样调用<code>delete</code>。但其他资源不会自动释放。因此销毁器(destructor)对于那些副作用的实现非常有用：诸如文件处理，通讯处理，GUI窗口，图形资源等，标准库中早已为资源的处理的任何类型提供了<code>Drop</code>实现。</p>
<p>销毁器可以更好地理解内存的管理。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> ( <span class="type">i32</span> );</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">S</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;Dropped &#123;&#125;&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_a</span> = <span class="title function_ invoke__">S</span> (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_b</span> = <span class="title function_ invoke__">S</span> (<span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_c</span> = <span class="title function_ invoke__">S</span> (<span class="number">3</span>);</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">_d</span> = <span class="title function_ invoke__">S</span> (<span class="number">4</span>);</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">_e</span> = <span class="title function_ invoke__">S</span> (<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">_f</span> = <span class="title function_ invoke__">S</span> (<span class="number">6</span>);</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;INNER&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;OUTER&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>结果打印：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INNER</span><br><span class="line">Dropped 6</span><br><span class="line">Dropped 5</span><br><span class="line">Dropped 4</span><br><span class="line">OUTER</span><br><span class="line">Dropped 3</span><br><span class="line">Dropped 2</span><br><span class="line">Dropped 1</span><br></pre></td></tr></table></figure>
<p>注意到对象的销毁的顺序跟构造顺序相反，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> ( <span class="type">i32</span> );</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">S</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;Dropped &#123;&#125;&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_</span> = <span class="title function_ invoke__">S</span> (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_</span> = <span class="title function_ invoke__">S</span> (<span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_</span> = <span class="title function_ invoke__">S</span> (<span class="number">3</span>);</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">_</span> = <span class="title function_ invoke__">S</span> (<span class="number">4</span>);</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">_</span> = <span class="title function_ invoke__">S</span> (<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">_</span> = <span class="title function_ invoke__">S</span> (<span class="number">6</span>);</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;INNER&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;OUTER&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>结果将打印：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Dropped 1</span><br><span class="line">Dropped 2</span><br><span class="line">Dropped 3</span><br><span class="line">Dropped 4</span><br><span class="line">Dropped 5</span><br><span class="line">Dropped 6</span><br><span class="line">INNER</span><br><span class="line">OUTER</span><br></pre></td></tr></table></figure>
<p>因为只有占位符，因此所有对象都是临时的。临时对象在它们语句结束位置就销毁了，即统计到分号(<code>;</code>)立即销毁。</p>
<p>上面的程序和下面的是等价的，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> ( <span class="type">i32</span> );</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">S</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;Dropped &#123;&#125;&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">s</span> (<span class="number">1</span>);</span><br><span class="line"><span class="title function_ invoke__">S</span> (<span class="number">2</span>);</span><br><span class="line"><span class="title function_ invoke__">S</span> (<span class="number">3</span>);</span><br><span class="line">&#123;</span><br><span class="line">	<span class="title function_ invoke__">S</span> (<span class="number">4</span>);</span><br><span class="line">	<span class="title function_ invoke__">S</span> (<span class="number">5</span>);</span><br><span class="line">	<span class="title function_ invoke__">S</span> (<span class="number">6</span>);</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;INNER&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;OUTER&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Assignment-Semantics"><a class="header-anchor" href="#Assignment-Semantics">¶</a>Assignment Semantics</h2>
<p>下面程序做了什么？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v2</span> = v1;</span><br></pre></td></tr></table></figure>
<p>概念上，</p>
<p>首先，<code>v1</code>的标头(header)被分配到了栈。然后，<code>v1</code>的内容，会在堆为该内容分配一个缓冲区，<code>v1</code>的元素之被拷贝到这个缓冲区。然后标头(header)被初始化，作为引用指向新分配的堆缓冲。</p>
<p>然后，<code>v2</code>的标头被分配在栈。接着，用<code>v1</code>的值初始化<code>v2</code>。但，这是如何实现的？</p>
<p>通常至少有三种方式实现这种操作：</p>
<ul>
<li>
<p><strong><code>Share semantics</code></strong>：<code>v1</code>的标头被拷贝到<code>v2</code>的标头，其它不发生任何操作。因此，可以用<code>v1</code>，也可以用<code>v2</code>，它们都同时指向相同的堆缓冲区；因此，它们指向同样的内容，不是相等的，而是唯一的。这种术语的常见于垃圾回收语言，比如Java。</p>
</li>
<li>
<p><strong><code>Copy semantics</code></strong>：分配另外的堆缓冲。它和<code>v1</code>使用的缓冲区有同样的大小，并将先存的缓冲区内容拷贝到新的缓冲区。然后<code>v2</code>的标头被初始化指向新分配的缓冲区。因此，两个变量指向两个不同的缓冲区并且初始化的内容相同。这种实现，是C++的默认机制。</p>
</li>
<li>
<p><strong><code>Move semantics</code></strong>：<code>v1</code>的标头被拷贝到<code>v2</code>的标头，其它不发生任何操作。因此，<code>v2</code>可以使用，它的标头指向原先<code>v1</code>分配的堆缓冲区，但<code>v1</code>不能再被使用。这种实现，是Rust的默认机制。</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v2</span> = v1;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, v1.<span class="title function_ invoke__">len</span>());</span><br></pre></td></tr></table></figure>
<p>该代码产生编译错误：“use of moved value: <code>v1</code>”。当<code>v1</code>的值指派给<code>v2</code>是，变量<code>v1</code>终止并退出。再次使用是不被编译器允许的。</p>
<p>先看看，为什么Rust不实现<strong>share semantics</strong>。首先，如果变量是可变的，这种语义(semnatics)会有几分迷惑。在共享术语(share semantics)，通过一个变量更改一个条目，这个条目也可以被其它变量更改和访问。这不是直觉，可能是bug的根源。因此，共享术语(share senantics)仅在只读数据(read-only data)能被接收。</p>
<p>但这里有个大问题，对于内存回收。如果使用共享术语，<code>v1</code>和<code>v2</code>都将会拥有同一个单一的数据缓冲区，因此当他们被回收时，同样的堆缓冲区会被回收两次。一个缓冲区不能被分配两次，而不导致内存损耗以及引起程序崩溃(program malfunction)。要解决这个问题，语言本身需要在scope结束时不对变量使用的内进行回收，而是凭借GC处理。</p>
<p>相反，拷贝语义(copy semantics)和移动语义(move semantics)都是正确的。实际上，Rust规则上把回收看做是任何对象必须有且仅有一个owner。当使用拷贝语义时，原来的vector缓冲区还是原来的owner，即变量<code>v1</code>的标头，新创建的缓冲区，有新的owner引用，即<code>v2</code>的标头。另一方面，当使用移动语义时，原来单一vector缓冲区更改它的owner：分配之前，缓冲区的所有者是<code>v1</code>的标头reference，分配之后，所有者更改为<code>v2</code>的标头reference。在分配之前，<code>v2</code>的标头并不存在，分配之后，<code>v1</code>的标头不再存在。</p>
<p>那为什么Rust不实现拷贝语义(copy semantics)？</p>
<p>实际上，某些情况下，使用拷贝语义更合适，另一些情况下，使用移动语义更适合。甚至C++，从2011年开始，允许同时拷贝语义和移动语义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> v1 = std::vector&lt;<span class="type">int</span>&gt; &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> v2 = v1;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> v3 = <span class="built_in">move</span>(v1);</span><br><span class="line">	std::count &lt;&lt; v<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v<span class="number">2.</span><span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v<span class="number">3.</span><span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段C<ins>程序会打印：0 3 3。<code>v1</code>首先被拷贝到<code>v2</code>，然后移动到<code>v3</code>。C</ins>标准函数<code>move</code>会清空vector但不会让其undefined。因此，在最后，<code>v2</code>有三个元素的拷贝，<code>v3</code>就是原来的<code>v1</code>，<code>v1</code>变为空。</p>
<p>Rust中也允许拷贝语义和移动语义。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v2</span> = v1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v3</span> = v1;</span><br><span class="line"><span class="comment">// ILLEGAL: print!(&quot;&#123;&#125; &quot;, v1.len());</span></span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, v2.<span class="title function_ invoke__">len</span>(), v3.<span class="title function_ invoke__">len</span>());</span><br></pre></td></tr></table></figure>
<p>将会打印：3 3。</p>
<p>这段程序和C<ins>类似，但不能再访问<code>v1</code>了，因为它被移动了。因为C</ins>的默认语义是拷贝语义(copy semantics)，所以需要调用<code>move</code>标准函数来进行对象移动；而Rust的默认语义是移动语义(move semantics)，所以需要调用标准函数<code>clone</code>进行拷贝。</p>
<p>另外，<code>v1</code>虽已被移动，但仍然可访问，只不过内容为空，Rust中被移动的变量不可再被访问。</p>
<h2 id="Copying-vs-Moving-Performance"><a class="header-anchor" href="#Copying-vs-Moving-Performance">¶</a>Copying vs. Moving Performance</h2>
<p>Rust偏向于移动语义的选择是从性能方面考量的。对于拥有堆缓冲区的对象，比如vector，移动比拷贝要快，因为移动的仅是header，然而如果是拷贝一个vector，要求分配和初始化一个可能的堆缓冲区，它最终会被回收。</p>
<p>在C++中，被移动的对象意味着不在被使用了，但语言为了对遗留代码做后向兼容(backward-compatible)，被移动的对象仍然可以访问，这可能会给开发者再次使用该对象的机会。另外，清空一个被移动的vector有较小的消耗，即当一个vector被销毁，会检测它是否为空，这也有较小消耗。Rust被设计避免手动移动对象，因此不会有不正当的移动vector，因为编译器知道vector被移动了，可以产生更好的代码。</p>
<p>我们可以通过下面代码度量性能的影响，这并不简单，因为编译优化器会移除loop内的工作。</p>
<p>下面代码使用了拷贝语义。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::time::Instant;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">elapsed_ms</span>(t1: Instant, t2: Instant) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = t2 - t1;</span><br><span class="line">    t.<span class="title function_ invoke__">as_secs</span>() <span class="keyword">as</span> <span class="type">f64</span> * <span class="number">1000</span>. + t.<span class="title function_ invoke__">subsec_nanos</span>() <span class="keyword">as</span> <span class="type">f64</span> / <span class="number">1e6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> N_ITER: <span class="type">usize</span> = <span class="number">100_000_000</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">start_time</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..N_ITER &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">11</span>, <span class="number">22</span>];</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v2</span> = v1.<span class="title function_ invoke__">clone</span>();    <span class="comment">// Copy semantics is used</span></span><br><span class="line">	v2.<span class="title function_ invoke__">push</span>(i);</span><br><span class="line">	<span class="keyword">if</span> v1[<span class="number">1</span>] + v2[<span class="number">2</span>] == v2[<span class="number">0</span>] &#123;</span><br><span class="line">		<span class="built_in">print!</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">finish_time</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; ns per iteration\n&quot;</span>, <span class="title function_ invoke__">elapsed_ms</span>(start_time, finish_time) * <span class="number">1e6</span> / N_ITER <span class="keyword">as</span> <span class="type">f64</span>);</span><br></pre></td></tr></table></figure>
<p>下面是C++的等价实现，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> n_iter = <span class="number">100000000</span>;</span><br><span class="line">	<span class="keyword">auto</span> start_time = <span class="built_in">clock</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n_iter; ++i) &#123;</span><br><span class="line">		<span class="keyword">auto</span> v1 = std::vector&lt;<span class="type">int</span>&gt; &#123; <span class="number">11</span>, <span class="number">22</span> &#125;;</span><br><span class="line">		<span class="keyword">auto</span> v2 = v1;	<span class="comment">// Copy semantics is used</span></span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="keyword">if</span> (v2[<span class="number">1</span>] + v2[<span class="number">2</span>] = v2[<span class="number">0</span>]) &#123; std::cout &lt;&lt; <span class="string">&quot;Error&quot;</span>; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> finish_time = <span class="built_in">clock</span>();</span><br><span class="line">	std::cout &lt;&lt; (finish_time - start_time) * <span class="number">1.e9</span> / CLOCKS_PER_SEC / n_iter &lt;&lt; <span class="string">&quot; ns per iteration\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面Rust程序使用了移动术语，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::time::Instant;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">elapsed_ms</span>(t1: Instant, t2: Instant) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = t2 - t1;</span><br><span class="line">    t.<span class="title function_ invoke__">as_secs</span>() <span class="keyword">as</span> <span class="type">f64</span> * <span class="number">1000</span>. + t.<span class="title function_ invoke__">subsec_nanos</span>() <span class="keyword">as</span> <span class="type">f64</span> / <span class="number">1e6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> N_ITER: <span class="type">usize</span> = <span class="number">100_000_000</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">start_time</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..N_ITER &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">11</span>, <span class="number">22</span>];</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v2</span> = v1;    <span class="comment">// Move semantics is used</span></span><br><span class="line">	v2.<span class="title function_ invoke__">push</span>(i);</span><br><span class="line">	<span class="keyword">if</span> v1[<span class="number">1</span>] + v2[<span class="number">2</span>] == v2[<span class="number">0</span>] &#123;</span><br><span class="line">		<span class="built_in">print!</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">finish_time</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; ns per iteration\n&quot;</span>, <span class="title function_ invoke__">elapsed_ms</span>(start_time, finish_time) * <span class="number">1e6</span> / N_ITER <span class="keyword">as</span> <span class="type">f64</span>);</span><br></pre></td></tr></table></figure>
<p>C++的等价实现为，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> n_iter = <span class="number">100000000</span>;</span><br><span class="line">	<span class="keyword">auto</span> start_time = <span class="built_in">clock</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n_iter; ++i) &#123;</span><br><span class="line">		<span class="keyword">auto</span> v1 = std::vector&lt;<span class="type">int</span>&gt; &#123; <span class="number">11</span>, <span class="number">22</span> &#125;;</span><br><span class="line">		<span class="keyword">auto</span> v2 = <span class="built_in">move</span>(v1);	<span class="comment">// Move semantics is used</span></span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="keyword">if</span> (v2[<span class="number">1</span>] + v2[<span class="number">2</span>] = v2[<span class="number">0</span>]) &#123; std::cout &lt;&lt; <span class="string">&quot;Error&quot;</span>; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> finish_time = <span class="built_in">clock</span>();</span><br><span class="line">	std::cout &lt;&lt; (finish_time - start_time) * <span class="number">1.e9</span> / CLOCKS_PER_SEC / n_iter &lt;&lt; <span class="string">&quot; ns per iteration\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是编译优化后的大致的时间损耗，</p>
<table>
<thead>
<tr>
<th></th>
<th>Rust</th>
<th>C++</th>
</tr>
</thead>
<tbody>
<tr>
<td>Copy semantics</td>
<td>157</td>
<td>87</td>
</tr>
<tr>
<td>Move semantics</td>
<td>67</td>
<td>67</td>
</tr>
</tbody>
</table>
<p>不管是在C<ins>还是Rust中，移动术语都要比拷贝术语要快。在这方面，移动术语两者都差不多，拷贝术语方面C</ins>要比Rust好很多。</p>
<h2 id="Moving-and-Destroying-Objects"><a class="header-anchor" href="#Moving-and-Destroying-Objects">¶</a>Moving and Destroying Objects</h2>
<p>所有这些概念不单是对vector，任何有缓冲区引用的对象都适用，譬如<code>String</code>或<code>Box</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">&quot;abcd&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = s1;</span><br><span class="line"><span class="comment">// ILLEGAL: print!(&quot;&#123;&#125; &quot;, s1.len());</span></span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, s2.<span class="title function_ invoke__">len</span>(), s3.<span class="title function_ invoke__">len</span>());</span><br></pre></td></tr></table></figure>
<p>这和C++类似，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> s1 = std::string &#123; <span class="string">&quot;abcd&quot;</span> &#125;;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> s2 = s1;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> s3 = <span class="built_in">move</span>(s1);</span><br><span class="line">	std::cout &lt;&lt; s<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s<span class="number">2.</span><span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s<span class="number">3.</span><span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面说过，被移动的对象不能再访问，因此<code>s1</code>访问时会导致编译错误；而对于C++，原来的<code>s1</code>会置为空，所以会输出0 4 4。</p>
<p>对于<code>Box</code>类型，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">i1</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">12345i16</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">i2</span> = i1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">i3</span> = i1;</span><br><span class="line"><span class="comment">// ILLEGAL: print!(&quot;&#123;&#125; &quot;, i1);</span></span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, i2, i3);</span><br></pre></td></tr></table></figure>
<p>对应的C++，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> i1 = std::unique_ptr&lt;<span class="type">short</span>&gt; &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="built_in">short</span>(<span class="number">12345</span>)</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> i2 = std::unique_ptr&lt;<span class="type">short</span>&gt; &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="built_in">short</span>(*i1)</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> i3 = <span class="built_in">move</span>(i1);</span><br><span class="line">	std::cout &lt;&lt; (<span class="type">bool</span>)i1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">bool</span>)i2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">bool</span>)i3 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *i2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *i3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rust程序会输出12345 12345，任何访问<code>i1</code>都会导致编译错误。C++会输出0 1 1 12345 12345。因为仅<code>i1</code>是null，它被移动到<code>i3</code>了。</p>
<p>仅当他们被用于初始化一个变量，给一个有值的变量重新赋值，对象不被移动，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="literal">false</span>; <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v2</span> = <span class="built_in">vec!</span>[<span class="literal">false</span>; <span class="number">2</span>];</span><br><span class="line">v2 = v1;</span><br><span class="line">v1;</span><br></pre></td></tr></table></figure>
<p>以及给函数参数传递值时，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>(v2: <span class="type">Vec</span>&lt;<span class="type">bool</span>&gt;) &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="literal">false</span>; <span class="number">3</span>];</span><br><span class="line"><span class="title function_ invoke__">f</span>(v1);</span><br><span class="line">v1;</span><br></pre></td></tr></table></figure>
<p>以及指派的对象在当前没有实际堆分配时，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="literal">false</span>; <span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v2</span> = <span class="built_in">vec!</span>[<span class="literal">false</span>; <span class="number">0</span>];</span><br><span class="line">v2 = v1;</span><br><span class="line">v1;</span><br></pre></td></tr></table></figure>
<p>编译上面任何三条程序，最后一个语句都会导致“use of a moved value”的编译错误，</p>
<p>尤其是，在程序最后，<code>v1</code>被移动到<code>v2</code>，即使他们都为空，因此它们没有堆空间被使用。为什么？因为移动规则由编译器提供，因此它在运行期必须是独立的内容。</p>
<p>下面的代码，最后一行也会导致编译错误，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = S &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line">s1;</span><br></pre></td></tr></table></figure>
<p>编译器可以确切知道这个引用不会指向heap，但仍然编译报错。为什么Rust不为该类型使用拷贝语义？</p>
<p>它的基本原理是这样的。用户定义的类型<code>S</code>现在没有引用内存，但在将来软件维护的时候，指向堆的引用可能会被添加，即<code>S</code>可能会被作为字段(field)等。因此，如果为<code>S</code>实现了拷贝语义，当程序源被更改，一个<code>String</code>、<code>Box</code>、或集合，直接或间接地添加到<code>S</code>，会导致很多错误。因此，作为规则，最后保留移动语义。</p>
<h2 id="Need-for-Copy-Semantics"><a class="header-anchor" href="#Need-for-Copy-Semantics">¶</a>Need for Copy Semantics</h2>
<p>我们看到很多类型使用移动语义，包括vector，动态字符串，boxes，结构体… 下面的程序是合法的，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">i1</span> = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_i2</span> = i1;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_s2</span> = s1;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;i1;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_r2</span> = r1;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, i1, s1, r1);</span><br></pre></td></tr></table></figure>
<p>结果将打印：“123 abc 123”。怎么来的？</p>
<p>首先，对于原生类型，静态字符串，引用，Rust不使用移动语义。对于这些数据类型，Rust使用拷贝语义。</p>
<p>为什么？前面看到，如果一个对象可以“拥有”一个或多个堆对象，它的类型应该实现移动语义；但如果不能“拥有”任何堆内存，它仅可以实现拷贝语义。移动语义对于原生类型来说是个麻烦的东西，而且它也不适合于被改变来“拥有”某些堆对象。因此，对于这些类型来说，拷贝语义是安全的、高效的、并且更方便。</p>
<p>因此，Rust中的某些类型实现了拷贝语义，另一些实现了移动语义。另外，numbers、Booleans、static strings、arrays、tuples、references实现了拷贝语义。相反，dynamic strings、boxes、集合(包括vectors)、enums、structs、tuple-structs均默认实现了移动语义。</p>
<h2 id="Cloning-Objects"><a class="header-anchor" href="#Cloning-Objects">¶</a>Cloning Objects</h2>
<p>然而，对于对象的拷贝，有另一种重要的区分。所有实现拷贝语义的类型可以通过指派的方式简单地拷贝；但对于移动语义的对象来说也可以进行拷贝，但需要使用标准库的<code>clone</code>。对于动态字符串、boxed对象、vector可以使用<code>clone</code>函数。但对于某些类型，不能使用<code>clone</code>函数，因为没有合适的拷贝类型。例如一个文件处理，一个GUI窗口处理，或一个互斥锁处理。如果你拷贝了它，然后销毁某一份拷贝，源资源会被释放，其它拷贝的处理会前后不一致：</p>
<p>因此，关于可被拷贝的能力，会有三种不同的对象：</p>
<ul>
<li>对象不“拥有”任何东西，拷贝是廉价的、容易的。</li>
<li>对象“拥有”某些堆对象，但不“拥有”内部资源，所以可以被拷贝，但运行期有较大损耗。</li>
<li>对象“拥有”内部资源，譬如文件处理、GUI窗口处理，所以它不能被拷贝。</li>
</ul>
<p>第一类对象，称为“可拷贝对象，copyable objects”，因为对于这类对象来说，拷贝更加高效。</p>
<p>第二种对象，称为“克隆而非拷贝对象，cloneable but non-copyable objects”，顾名思义，这类对象可以实现拷贝语义，但也应该实现移动语义，以避免运行期非必要的副本消耗。甚至，需要显式提供一个方法进行复制。</p>
<p>第三种类型，应该实现移动语义，但不应该提供复制方法，因为它拥有的资源不能在Rust代码复制，这种资源仅能有一个“owner”，所以这类称之为“不可拷贝对象，non-cloneable objects”。</p>
<p>当然，任何对象可自动被拷贝也可显式地被拷贝，所以任何可拷贝对象(copyable object)也是一个可克隆对象(cloneable object)。</p>
<p>总结，某些对象不能被克隆(如文件处理)，某些可以拷贝(显式地)，某些可以隐式拷贝(如数字)，某些不能拷贝(如集合)。</p>
<p>为了区分这三者，Rust标准库包含有两个特殊的trait：<code>Copy</code>和<code>Clone</code>。任何类型实现了<code>Copy</code>的是可拷贝的；任何类型实现了<code>Clone</code>是可克隆的。</p>
<p>因此，这三种可以文字描述为如下：</p>
<ul>
<li>对象实现了<code>Copy</code>和<code>Clone</code>的，包含拷贝语义，也可以显式克隆。例如原生类型。</li>
<li>对象实现了<code>Clone</code>，但没有实现<code>Copy</code>的，它们实现了移动语义，可以显式克隆。例如集合类型。</li>
<li>既没有实现<code>Copy</code>，也没有实现<code>Clone</code>的，属于不可复制，它们实现了移动语义，例如文件处理等。</li>
<li>没有对象是实现了<code>Copy</code>，却没有<code>Clone</code>的。这意味着对象的拷贝是隐式的，却不能显式调用，这是无意义的。</li>
</ul>
<p>下面例子展示所有的情况，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a1</span> = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b1</span> = a1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">c1</span> = b1;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, a1, b1, c1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a2</span> = <span class="type">Vec</span>::&lt;<span class="type">bool</span>&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b2</span> = a2.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">c2</span> = b2;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot; &#123;:?&#125;&quot;</span>, a2);</span><br><span class="line"><span class="comment">// ILLEGAL: print!(&quot; &#123;:?&#125;&quot;, b2);</span></span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot; &#123;:?&#125;&quot;</span>, c2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a3</span> = std::fs::File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;.&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="comment">// ILLEGAL: let b3 = a3.clone();</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">c3</span> = a3;</span><br><span class="line"><span class="comment">// ILLEGAL: print!(&quot; &#123;:?&#125;&quot;, a3);</span></span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot; &#123;:?&#125;&quot;</span>, c3);</span><br></pre></td></tr></table></figure>
<p>结果打印：“<code>123 123 123 [] [] File</code>”。</p>
<p>此处三处注释的地方是不合法的语句。</p>
<p>首先，<code>a1</code>是原生类型，所以这种类型可以隐式拷贝，也可以显式克隆(clone)。所以此处三个对象有同样的值，并打印输出。</p>
<p>因为<code>a2</code>是一个集合类型，这种类型可以克隆，但不能拷贝，所以<code>b2</code>可以通过<code>a2</code>显式克隆，对<code>b2</code>到<code>c2</code>的赋值是移动语义，<code>b2</code>不可再访问。</p>
<p>对于<code>a3</code>而言，它是一个文件handle，这种类型不能被克隆，尝试编译<code>a3.clone()</code>会出现编译错误，以及对<code>a3</code>到<code>c3</code>的赋值是移动语义，对象被移动了，<code>a3</code>不可再访问。</p>
<h2 id="Making-Types-Cloneable-or-Copyable"><a class="header-anchor" href="#Making-Types-Cloneable-or-Copyable">¶</a>Making Types Cloneable or Copyable</h2>
<p>前面说过，枚举，结构体，元组-结构体，默认都没有实现<code>Copy</code>和<code>Clone</code>。因此它是不可克隆的。因此，你可能需要仅实现<code>Clone</code>，又或<code>Copy</code>和<code>Clone</code>都需要有。</p>
<p>下面代码是不合法的，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = S &#123;&#125;;</span><br><span class="line">s.<span class="title function_ invoke__">clone</span>();</span><br></pre></td></tr></table></figure>
<p>所以你会为其实现<code>Clone</code>，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;&#125; </span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Clone</span> <span class="keyword">for</span> <span class="title class_">S</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123; <span class="keyword">Self</span> &#123;&#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = S &#123;&#125;;</span><br><span class="line">s.<span class="title function_ invoke__">clone</span>();</span><br></pre></td></tr></table></figure>
<p>这些实现写法，在前面面向对象编程介绍过，你需要为其实现<code>clone</code>方法，</p>
<p>另外，实现的<code>Clone</code>方法，不能隐式使用拷贝语义，所以下面代码是不合法的，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Clone</span> <span class="keyword">for</span> <span class="title class_">S</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123; <span class="keyword">Self</span> &#123;&#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = S &#123;&#125;;</span><br><span class="line">s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_s2</span> = s;</span><br><span class="line">s;</span><br></pre></td></tr></table></figure>
<p>所以，你需要实现<code>Copy</code>，使其合法，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Clone</span> <span class="keyword">for</span> <span class="title class_">S</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123; <span class="keyword">Self</span> &#123;&#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Copy</span> <span class="keyword">for</span> <span class="title class_">S</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = S &#123;&#125;;</span><br><span class="line">s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_s2</span> = s;</span><br><span class="line">s;</span><br></pre></td></tr></table></figure>
<p>主要到<code>Copy</code>的实现可以为空；只要声明了<code>Copy</code>的实现，拷贝语义就激活了。</p>
<p>下面写法却是不合法的，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Copy</span> <span class="keyword">for</span> <span class="title class_">S</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>编译器会抱怨：“<code>the trait bound </code>main::S:std::clone::Clone<code> is not satisfied</code>”。<code>Copy</code>的实现，前提条件是<code>Clone</code>也实现了，</p>
<p>但下面写法也是不合法的，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123; x: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; &#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Copy</span> <span class="keyword">for</span> <span class="title class_">S</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Clone</span> <span class="keyword">for</span> <span class="title class_">S</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123; * <span class="keyword">self</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译产生错误信息，“the trait <code>Copy</code> may not be implemented for this type”。告诉你<code>Vec&lt;i2&gt;</code>类型没有实现<code>Copy</code>。</p>
<p>Rust允许实现<code>Copy</code>，仅能允许其类型是包含可拷贝对象的，因为拷贝对象，意味着会拷贝它的所有成员(members)。这里，<code>Vec</code>没有实现<code>Copy</code>，所以<code>S</code>也不能实现拷贝语义。</p>
<p>相反，下面代码是合法的，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123; x: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; &#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Clone</span> <span class="keyword">for</span> <span class="title class_">S</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">		S &#123; x: <span class="keyword">self</span>.x.<span class="title function_ invoke__">clone</span>() &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = S &#123; x: <span class="built_in">vec!</span>[<span class="number">12</span>] &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">s1.x[<span class="number">0</span>] += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, s1.x[<span class="number">0</span>], s2.x[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>结果将打印：“13 12”。</p>
<p>这里，<code>S</code>结构体不是可拷贝的，但却是可克隆的(clonable)，因为它实现了<code>Clone</code>。因此，<code>s1</code>可以对<code>s2</code>赋值。<code>s1</code>被修改，两者输出内容不同。</p>
</div></article><nav class="article-nav"><div class="article-nav-prev"><a href="/2023/01/22/rust/beginning/chapter22_Borrowing%20and%20Lifetimes/">rust基础入门[22] - Borrowing and Lifetimes</a></div><div class="article-nav-next"><a href="/2023/01/20/rust/beginning/chapter20_Standard%20Library%20Collections/">rust基础入门[20] - Standard Library Collections</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2023/01/21/rust/beginning/chapter21_Drops, Moves, and Copies/';
var disqus_title = 'rust基础入门[21] - Drops, Moves, and Copies';
var disqus_url = 'https://galudisu.info/2023/01/21/rust/beginning/chapter21_Drops, Moves, and Copies/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>