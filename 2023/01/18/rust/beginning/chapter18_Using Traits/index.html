<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>rust基础入门[18] - Using Traits</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/maths/">Maths</a></li><li class="menu-item"><a class="menu-link" href="/projects/">Projects</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/maths/">Maths</a></li><li class="menu-item"><a class="menu-link" href="/projects/">Projects</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">rust基础入门[18] - Using Traits</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2023-01-18</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/rust/">rust</a></p><p class="meta-item meta-category"><span class="meta-item-title"></span><i class="icon-bookmark"> </i><a class="category-link" href="/categories/learning/">learning</a></p></div><div class="article-content"><p>本章覆盖有：</p>
<ul>
<li><code>traits</code>如何避免在泛型函数调用中的不能理解的编译错误信息</li>
<li>泛型参数的边界如何被单子化(monolithic)，或如何分解为几个traits</li>
<li>如何创建函数体返回内的traits</li>
<li>如何简单地使用<code>self</code>关键字，通过&quot;点，dot notation&quot;操作来创建函数</li>
<li>如何迭代一个trait</li>
<li>如何定义类型别名</li>
<li>如何定义泛型迭代器</li>
<li>如何使用关联类型来简化泛型迭代器的使用</li>
<li>如何定义字节的迭代器</li>
</ul>
<span id="more"></span>
<h2 id="The-Need-for-Traits"><a class="header-anchor" href="#The-Need-for-Traits">¶</a>The Need for Traits</h2>
<p>假设我们要计算一个4次方根，该函数命名为“quartic_root”。以及调用标准库的<code>sqrt</code>函数，我们会写，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">quartic_root</span>(x: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123; x.<span class="title function_ invoke__">sqrt</span>().<span class="title function_ invoke__">sqrt</span>() &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">qr</span> = <span class="title function_ invoke__">quartic_root</span>(<span class="number">100f64</span>);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, qr * qr * qr * qr, qr);</span><br></pre></td></tr></table></figure>
<p>结果会打印：“100.00000000000003 3.1622776601683795”。</p>
<p>但我们还需要计算32位数的4次方根，于是又，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">quartic_root_f64</span>(x: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123; x.<span class="title function_ invoke__">sqrt</span>().<span class="title function_ invoke__">sqrt</span>() &#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">quartic_root_f32</span>(x: <span class="type">f32</span>) <span class="punctuation">-&gt;</span> <span class="type">f32</span> &#123; x.<span class="title function_ invoke__">sqrt</span>().<span class="title function_ invoke__">sqrt</span>() &#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>,</span><br><span class="line">    <span class="title function_ invoke__">quartic_root_f64</span>(<span class="number">100f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">quartic_root_f32</span>(<span class="number">100f32</span>));</span><br></pre></td></tr></table></figure>
<p>根据前面我们所学知识，我们可以定义泛型函数来处理，于是，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">quartic_root</span>&lt;Number&gt;(x: Number) <span class="punctuation">-&gt;</span> Number &#123;</span><br><span class="line">x.<span class="title function_ invoke__">sqrt</span>().<span class="title function_ invoke__">sqrt</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>,</span><br><span class="line">    <span class="title function_ invoke__">quartic_root</span>(<span class="number">100f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">quartic_root</span>(<span class="number">100f32</span>));</span><br></pre></td></tr></table></figure>
<p>但这段代码是不合法的，生成编译错误，“no method named <code>sqrt</code> found for type <code>Number</code> in the current scope”。它意思是说，泛型类型<code>Number</code>没有这个<code>sqrt</code>函数。</p>
<p>在这方面，Rust不同于C++。C++可以通过模板来关联这个泛型函数，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Number&gt;</span><br><span class="line"><span class="function">Number <span class="title">quartic_root</span><span class="params">(Number x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">sqrt</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::count &lt;&lt; <span class="built_in">quartic_root</span>((<span class="type">float</span>)<span class="number">100</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">quartic_root</span>((<span class="type">double</span>)<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使C++中的<code>NUmber</code>泛型类型没有这个可用的<code>sqrt</code>函数，编译器也不知这个表达式是否允许。但当调用<code>quartic_root</code>时，函数被计数，编译期生成两个具体函数<code>quartic_root&lt;float&gt;</code>和<code>quartic_root&lt;double&gt;</code>。这叫“泛型函数实例化 generic function instantiation”，或“function monomorphization”。这种实例化会检测具体的类型。</p>
<p>C++这种方案带来的缺陷很明显，即当出现程序错误时，譬如，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Number&gt;</span><br><span class="line"><span class="function">Number <span class="title">quartic_root</span><span class="params">(Number x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">sqrt</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::count &lt;&lt; <span class="built_in">quartic_root</span>(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>编译器会实例化这个<code>const char*</code>类型的具体函数，它会生成<code>sqrt(const char*)</code>的方法签名。但没有这个函数声明，所以会导致出现变异错误。</p>
<p>这个缺陷带来的问题是，这个泛型类型<code>Number</code>，它所提供的具体类型的函数<code>sqrt</code>可能是由某一位开发者编写的，以及另一种具体类型的<code>sqrt</code>又是另外一位开发者编写的。可能两位开发者的<code>sqrt</code>函数签名并不一样！！</p>
<p>另外类似于C++这种<code>quartic_root</code>的实现，代码阅读是晦涩难懂的，因为它大部分变量、函数、类型都属于库实现(实际上有很多库…)，而不是接口。要理解它，不仅需要知道它的API使用；还需要知道它的库的实现。</p>
<h2 id="Traits-to-the-Rescue"><a class="header-anchor" href="#Traits-to-the-Rescue">¶</a>Traits to the Rescue</h2>
<p>Rust中为了避免这种类似于C++的编译为题，提供了trait来澄清复杂错误消息的各种情况，因为它更贴近真实软件环境。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">HasSquareRoot</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">sq_root</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">HasSquareRoot</span> <span class="keyword">for</span> <span class="title class_">f32</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">sq_root</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123; <span class="type">f32</span>::<span class="title function_ invoke__">sqrt</span>(<span class="keyword">self</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">HasSquareRoot</span> <span class="keyword">for</span> <span class="title class_">f64</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">sq_root</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123; <span class="type">f64</span>::<span class="title function_ invoke__">sqrt</span>(<span class="keyword">self</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">quartic_root</span>&lt;Number&gt;(x: Number) <span class="punctuation">-&gt;</span> Number</span><br><span class="line">    <span class="keyword">where</span> Number: HasSquareRoot &#123;</span><br><span class="line">    x.<span class="title function_ invoke__">sq_root</span>().<span class="title function_ invoke__">sq_root</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, <span class="title function_ invoke__">quartic_root</span>(<span class="number">100f64</span>), <span class="title function_ invoke__">quartic_root</span>(<span class="number">100f32</span>));</span><br></pre></td></tr></table></figure>
<p>结果将打印：“3.1622776601683795 3.1622777”</p>
<p>第一个trait命名为“HasSquareRoot”，包含函数签名“sq_root”。一个Rust trait是一个函数签名的容器；它表示这个trait有能力使用某些函数。这里表示了<code>HasSquareRoot</code>trait可以在有“HasSquareRoot”的地方调用“sq_root”函数，或者更常规的说法是，任何满足“HasSquareRoot”trait的类型，都可以调用这个<code>sq_root</code>函数。</p>
<p>但究竟哪些类型满足“HasSquareRoot”？没有定义，因此接下来两个语句，使得<code>f32</code>类型和<code>f64</code>类型满足这个trait。换言之，这些<code>impl</code>语句，可以从给定的<code>f32</code>和<code>f64</code>类型调用这个<code>sq_root</code>。</p>
<p>这些<code>impl</code>反映了“HasSquareRoot”仅是一个程序接口，或API，它需要又具体的类型实现。所以当然地，<code>impl</code>语句的函数签名，需要跟原来的前一个方法签名一样。不同的是<code>impl</code>包含有函数实现。</p>
<p>Rust的trait类似于Java或C#接口，或没有方法体的抽象类。</p>
<p>现在有了具体的类型实现了。第四条语句定义了<code>quartic_root</code>泛型函数，参数化类型参数是<code>Number</code>。然而，这个声明有一个新的段：<code>where Number: HasSquareRoot</code>。这种从句叫做——“trait bound”，它是方法签名的一部分。它字面量的意思是，<code>Number</code>泛型类型必须实现<code>HasSquareRoot</code>特质。</p>
<p>代码调用函数是，这个<code>where</code>从句表示“当调用该函数，你必须确保你传递的参数化类型实现了<code>HashSquareRoot</code>trait”。例如这个的100f32和100f64，对应类型是f32和f64。这两种类型都有<code>hasSquareRoot</code>的实现，因此它们是合法参数。但如果替换为“quartic_root(“Hello”));”，这里没有<code>&amp;str</code>的“HasSquareRoot”的实现，因此违反了条约。以及会得到编译错误“the traitbound <code>&amp;str: main::HasSquareRoot</code> is not satisfied”。</p>
<p>又或者你替换为“quartic_root(81i32));”，也会得到编译错误，因为“HasSquareRoot”没有<code>i32</code>类型的实现。</p>
<p>注意的时，<code>x</code>表达式在函数体内，它的类型仅可能是<code>Number</code>，实际类型并不清楚，所以你不能将<code>x.sq_root()</code>，写为<code>x.abs().sq_root()</code>这种，编译错误<code>abs()</code>在<code>Number</code>范围内没有定义。</p>
<h2 id="Generic-Functions-with-No-Trait-Bounds"><a class="header-anchor" href="#Generic-Functions-with-No-Trait-Bounds">¶</a>Generic Functions with No Trait Bounds</h2>
<p>不带特质边界的泛型函数是很少见的，比如这段代码，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;; &quot;</span>, a, b);</span><br><span class="line">std::mem::<span class="title function_ invoke__">swap</span>(&amp;<span class="keyword">mut</span> a, &amp;<span class="keyword">mut</span> b);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;;, a, b);</span></span><br></pre></td></tr></table></figure>
<p>泛型函数<code>swap</code>的方法签名是：<code>fn swap&lt;T&gt;(x: &amp;mut T, y: &amp;mut T)</code>。它不需要使用<code>where</code>从句进行trait bound。因为它直接交换了两个对象的地址。实际编码过程中，泛型函数，类型参数总是需要边界绑定的。Rust代码设计，总是强调类型安全这个概念，也是我们编写代码的原则。</p>
<h2 id="Scope-of-Traits"><a class="header-anchor" href="#Scope-of-Traits">¶</a>Scope of Traits</h2>
<p>前面用了一个<code>sq_root</code>来区分标准库的<code>sqrt</code>函数，不过我们也可以将其命名为<code>sqrt</code>，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">sqrt</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">HasSquareRoot</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">sqrt</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">HasSquareRoot</span> <span class="keyword">for</span> <span class="title class_">f32</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">sqrt</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123; <span class="type">f32</span>::<span class="title function_ invoke__">sqrt</span>(<span class="keyword">self</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">HasSquareRoot</span> <span class="keyword">for</span> <span class="title class_">f64</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">sqrt</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123; <span class="type">f64</span>::<span class="title function_ invoke__">sqrt</span>(<span class="keyword">self</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">quartic_root</span>&lt;Number&gt;(x: Number) <span class="punctuation">-&gt;</span> Number</span><br><span class="line"><span class="keyword">where</span> Number: HasSquareRoot &#123;</span><br><span class="line">	x.<span class="title function_ invoke__">sqrt</span>().<span class="title function_ invoke__">sqrt</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">sqrt</span>();</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>,</span><br><span class="line">	<span class="title function_ invoke__">quartic_root</span>(<span class="number">100f64</span>),</span><br><span class="line">	<span class="title function_ invoke__">quartic_root</span>(<span class="number">100f32</span>));</span><br></pre></td></tr></table></figure>
<p>同一个作用范围内是不允许有同名方法的。不过上面代码是合法的；因为它们并不作用在同一个scope。<code>fn sqrt()</code>是个本地函数，在HasSquareRoot外；<code>fn sqrt(self)</code>作用在HasSquareRoot内；<code>f32::sqrt</code>和<code>f64::sqrt</code>是个标准库调用。</p>
<h2 id="Traits-with-Numltiple-Functions"><a class="header-anchor" href="#Traits-with-Numltiple-Functions">¶</a>Traits with Numltiple Functions</h2>
<p>前面的例子有个问题是，如果传入的是“-100f64”或“-100f32”，程序会打印“NaN，Not a Number”，我们想处理负数的情况，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">HasSquareRoot</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">sq_root</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">HasSquareRoot</span> <span class="keyword">for</span> <span class="title class_">f32</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">sq_root</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123; <span class="type">f32</span>::<span class="title function_ invoke__">sqrt</span>(<span class="keyword">self</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">HasSquareRoot</span> <span class="keyword">for</span> <span class="title class_">f64</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">sq_root</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123; <span class="type">f64</span>::<span class="title function_ invoke__">sqrt</span>(<span class="keyword">self</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">HasAbsoluteValue</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">abs</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">HasAbsoluteValue</span> <span class="keyword">for</span> <span class="title class_">f32</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">abs</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123; <span class="type">f32</span>::<span class="title function_ invoke__">abs</span>(<span class="keyword">self</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">HasAbsoluteValue</span> <span class="keyword">for</span> <span class="title class_">f64</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">abs</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123; <span class="type">f64</span>::<span class="title function_ invoke__">abs</span>(<span class="keyword">self</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">quartic_root</span>&lt;Number&gt;(x: Number) <span class="punctuation">-&gt;</span> Number</span><br><span class="line">    <span class="keyword">where</span> Number: HasSquareRoot + HasAbsoluteValue &#123;</span><br><span class="line">    x.<span class="title function_ invoke__">abs</span>().<span class="title function_ invoke__">sq_root</span>().<span class="title function_ invoke__">sq_root</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多种类型，可以组合不同trait，使用<code>+</code>。</p>
<h2 id="Methods"><a class="header-anchor" href="#Methods">¶</a>Methods</h2>
<p>目前我们接触到的函数的调用方式有两种，一种是<code>f(x, y)</code>，另一种是<code>x.f(y)</code>。例如之前例子的<code>String::new()</code>、<code>String::form(&quot;&quot;)</code>写法，和<code>&quot;abcd&quot;.to_string()</code>，<code>&quot;abcd&quot;.len()</code>。一种是点操作，一种是函数调用操作。</p>
<p>任何函数都可以使用者两种调用方式，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;,&quot;</span>, <span class="string">&quot;abcd&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;,&quot;</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_ invoke__">len</span>());</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">0u8</span>; <span class="number">0</span>];</span><br><span class="line">v1.<span class="title function_ invoke__">push</span>(<span class="number">7u8</span>);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;; &quot;</span>, v1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;,&quot;</span>, std::string::<span class="built_in">ToString</span>::<span class="title function_ invoke__">to_string</span>(<span class="string">&quot;abcd&quot;</span>));</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;,&quot;</span>, &lt;[<span class="type">i32</span>]&gt;::<span class="title function_ invoke__">len</span>(&amp;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v2</span> = <span class="built_in">vec!</span>[<span class="number">0u8</span>; <span class="number">0</span>];</span><br><span class="line"><span class="type">Vec</span>::<span class="title function_ invoke__">push</span>(&amp;<span class="keyword">mut</span> v2, <span class="number">7u8</span>);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v2);</span><br></pre></td></tr></table></figure>
<p>虽然可以这样做，但有scoping问题。在标准库中，有很多同名的函数<code>to_string</code>、<code>len</code>、<code>push</code>…。使用点操作，自然会选择适当的函数。但是使用函数调用，函数的范围必须显式写明。例如，<code>to_string</code>的范围在<code>std::string::ToString</code>，<code>len</code>函数的范围在<code>&lt;[i32]&gt;</code>，<code>push</code>的作用范围在<code>Vec</code>。</p>
<p>如果不写清楚，譬如这段代码，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">double</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">x * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">double</span>(<span class="number">7i32</span>));</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">double</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">x * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="number">7i32</span>.<span class="title function_ invoke__">double</span>());</span><br></pre></td></tr></table></figure>
<p>这里的点操作调用，会发生编译错误，它会说当前范围内，<code>i32</code>类型没有double方法。区别于方法和函数，Rust中点操作的调用，区分为方法，它仅能在有trait实现的声明的方法中调用，所以，要允许点操作，可以改为，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">CanBeDoubled</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">double</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">CanBeDoubled</span> <span class="keyword">for</span> <span class="title class_">i32</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">double</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">		<span class="keyword">self</span> * <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="number">7i32</span>.<span class="title function_ invoke__">double</span>());</span><br></pre></td></tr></table></figure>
<p>trait的名字是任意的。通常trait仅包含一个函数，trait的名字使用Pascal-case记法。对于类型来说，像<code>CanBeDoubled</code>，从命名上看出，它表示有一个<code>double</code>函数可以获取自身<code>self</code>类型的一个值，遵循这种命名规范便于阅读理解。</p>
<p>当编译这段表达式时，编译器会搜索支持<code>i32</code>的<code>double</code>操作，并找到对应的方法签名。</p>
<h2 id="The-“self”-and-“Slef”-Keywords"><a class="header-anchor" href="#The-“self”-and-“Slef”-Keywords">¶</a>The “self” and “Slef” Keywords</h2>
<p>前面一个小节，我们发现了两个关键字：“self”和“Self”。</p>
<p>在语句<code>trait CanBeDoubled &#123; fn double(self) -&gt; Self; &#125;</code>中，<code>self</code>表示<code>double</code>方法将作用的值，<code>Self</code>表示<code>self</code>的类型。</p>
<p>因此，<code>self</code>是一个方法的预设参数，<code>Self</code>表示这一个参数的类型。因此，<code>self</code>和<code>Self</code>仅能被用于一个<code>trait</code>或<code>impl</code>的块内。以及，如果有方法，<code>self</code>必须是方法的第一个参数。</p>
<p>在<code>impl CanBeDoubled for i32</code>块内，下面6行是等价的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">double</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">double</span>(<span class="keyword">self</span>: <span class="keyword">Self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">double</span>(<span class="keyword">self</span>: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">double</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">double</span>(<span class="keyword">self</span>: <span class="keyword">Self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">double</span>(<span class="keyword">self</span>: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br></pre></td></tr></table></figure>
<p>第一行和第四行给定的<code>self</code>参数带有隐式类型；只不过，<code>self</code>的类型就是<code>Self</code>，所以也可以显式指定，又因为在<code>impl</code>块内，<code>Self</code>就是<code>i32</code>，所以也可以替换为<code>i32</code>。</p>
<p>不过最常使用的是第一种写法，它更接近泛型编程概念。</p>
<p>让我们看看另一种情况，我们希望有这样一个表达式<code>&quot;foobarbaz&quot;.letters_count('a')&quot;</code>统计字符串中有多少个字符，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">LettersCount</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">letters_count</span>(&amp;<span class="keyword">self</span>, ch: <span class="type">char</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">LettersCount</span> <span class="keyword">for</span> <span class="title class_">str</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">letters_count</span>(&amp;<span class="keyword">self</span>, ch: <span class="type">char</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">		<span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> <span class="keyword">self</span>.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">			<span class="keyword">if</span> c == ch &#123;</span><br><span class="line">				count += <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		count</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, <span class="string">&quot;&quot;</span>.leters_count(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, <span class="string">&quot;ddd&quot;</span>.leters_count(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, <span class="string">&quot;ddd&quot;</span>.leters_count(<span class="string">&#x27;d&#x27;</span>));</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, <span class="string">&quot;foobarbaz&quot;</span>.leters_count(<span class="string">&#x27;a&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>因为我们想用点操作，首先声明一个trait，它的名字来源于函数名。这个函数需要两个参数：字符串切片用于搜索，字符用于查找。但我们不想将字符串切片的拷贝作为参数传递；我们仅想直接传递字符串切片引用，因此我们将参数声明为<code>&amp;self</code>，这里的<code>self</code>就是一个字符串切片，有任意长度；<code>&amp;self</code>是一个切片引用，有一对指针的大小(字符串切片有header和content的pointer)。</p>
<p>返回值类型是<code>usize</code>表示非负整数。</p>
<p><code>impl</code>实现了使用了命令式风格。浏览<code>chars()</code>迭代器的所有字符，出现要搜索的字符，则统计一次。</p>
<p>如果使用函数式风风格，可以更简短，如下，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">filter</span>(|c| *c == ch).<span class="title function_ invoke__">count</span>()</span><br></pre></td></tr></table></figure>
<h2 id="Standard-Traits"><a class="header-anchor" href="#Standard-Traits">¶</a>Standard Traits</h2>
<p>在最开始的章节，我们用到了宏<code>print</code>、<code>println</code>和<code>format</code>。我们可以用<code>&#123;&#125;</code>占位符表示支持的类型，使用<code>&#123;:?&#125;</code>来进行调试。</p>
<p>但怎么知道某些类型支持<code>&#123;&#125;</code>占位符，其它类型却不支持？我自己写的类型如何实现支持这种占位符？</p>
<p>实际上，这些宏使用了<code>fmt</code>函数，有标准库的<code>std::fmt::Display</code>提供了trait。所有原生类型都实现了这个trait，所以你可以给自己的类型实现，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">	re: <span class="type">f64</span>,</span><br><span class="line">	im: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">std</span>::fmt::Display <span class="keyword">for</span> <span class="title class_">Compex</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, &amp;<span class="keyword">mut</span> std::fmt::Formatter) <span class="punctuation">-&gt;</span> std::fmt::<span class="type">Result</span> &#123;</span><br><span class="line">		<span class="built_in">write!</span>(</span><br><span class="line">			f,</span><br><span class="line">			<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;i&quot;</span>,</span><br><span class="line">			<span class="keyword">self</span>.re,</span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">self</span>.im &gt;= <span class="number">0</span>. &#123; <span class="string">&#x27;+&#x27;</span> &#125; <span class="keyword">else</span> &#123; <span class="string">&#x27;-&#x27;</span> &#125;,</span><br><span class="line">			<span class="keyword">self</span>.im.<span class="title function_ invoke__">abs</span>()</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">c1</span> = Complex &#123; re: -<span class="number">2.3</span>, im: <span class="number">0</span>. &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">c2</span> = Complex &#123; re: -<span class="number">2.1</span>, im: -<span class="number">5.2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">c3</span> = Complex &#123; re: -<span class="number">2.2</span>, im: <span class="number">5.2</span> &#125;;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, c1, c2, c3);</span><br></pre></td></tr></table></figure>
<p>结果会打印：“-2.3 + 0i, -2.1 - 5.2i, -2.2 + 5.2i”。</p>
<p>对于原生类型的实现traits，标准库中有非常多函数提供。</p>
<h2 id="The-“Terator”-Trait"><a class="header-anchor" href="#The-“Terator”-Trait">¶</a>The “Terator” Trait</h2>
<p>一个非常有趣的标准库trait是“Iterator”。让我们看看它主要解决哪方面问题。</p>
<p>例如编写一个函数，给定参数<code>range</code>，返回第三个元素，长度不够，则返回None。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_third</span>(r: std::ops::Range&lt;<span class="type">u32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">u32</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">if</span> r.<span class="title function_ invoke__">len</span>() &gt;= <span class="number">3</span>&#123;</span><br><span class="line">		<span class="title function_ invoke__">Some</span>(r.start + <span class="number">2</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="literal">None</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125; &#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">get_third</span>(<span class="number">10</span>..<span class="number">12</span>), <span class="title function_ invoke__">get_third</span>(<span class="number">20</span>..<span class="number">23</span>));</span><br></pre></td></tr></table></figure>
<p>将类型换成<code>slice</code>怎样，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_third</span>(s: &amp;[<span class="type">f64</span>]) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">f64</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">if</span> s.<span class="title function_ invoke__">len</span>() &gt;= <span class="number">3</span> &#123;</span><br><span class="line">		<span class="title function_ invoke__">Some</span>(s[<span class="number">2</span>])</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="literal">None</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125; &#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">get_third</span>(&amp;[<span class="number">1.0</span>, <span class="number">2.0</span>]), <span class="title function_ invoke__">get_thrid</span>(&amp;[<span class="number">1.1</span>, <span class="number">2.1</span>, <span class="number">3.1</span>]);</span><br></pre></td></tr></table></figure>
<p>这两个程序非常相似。但使用的是迭代器，应该将它们写成一个泛型函数，你可能会写成</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_third</span>&lt;Iter, Item&gt;(<span class="keyword">mut</span> iterator: Iter) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Item&gt; &#123;</span><br><span class="line">	iterator.<span class="title function_ invoke__">next</span>();</span><br><span class="line">	iterator.<span class="title function_ invoke__">next</span>();</span><br><span class="line">	iterator.<span class="title function_ invoke__">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125; &#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">get_third</span>(<span class="number">0</span>..<span class="number">9</span>), <span class="title function_ invoke__">get_third</span>([<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>].<span class="title function_ invoke__">iter</span>()));</span><br></pre></td></tr></table></figure>
<p>你会得到几个编译错误。这种想法是好的，但有几个问题，</p>
<ul>
<li><code>iterator</code>变量没有边界，所以它没有<code>next</code>函数。当我们调用<code>get_third</code>函数式，我们看到参数确实是iterator，以为有<code>next</code>函数。然而，Rust需要知道泛型参数对象有哪些函数可以被调用，</li>
<li>再看<code>get_thrid</code>函数的调用，它的泛型参数<code>Item</code>不能被推断，因为没有表达式表明给这个泛型参数传递了值。</li>
</ul>
<p>对于第一种错误，表明“迭代器”的概念没有被Rust语言定义。这个概念由Rust标准库的一个标准trait——<code>Iterator</code>定义了。我们知道迭代器都有一个<code>next</code>函数，所以任何迭代器都必须要有这个函数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_third</span>&lt;Iter, Item&gt;(<span class="keyword">mut</span> iterator: Iter) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Iterm&gt; </span><br><span class="line"><span class="keyword">where</span> Iter: std::iter::<span class="built_in">Iterator</span> &#123;</span><br></pre></td></tr></table></figure>
<p>但仍然有第二个错误存在：怎么确定<code>Item</code>的具体类型。为了解决这个问题，需要首先介绍<code>type</code>关键字。</p>
<h2 id="The-“type”-Keyword"><a class="header-anchor" href="#The-“type”-Keyword">¶</a>The “type” Keyword</h2>
<p>Rust中的<code>type</code>对于C语言的<code>typedef</code>关键字，它相当于一个类型的别名，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Number</span> = <span class="type">f32</span>;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f1</span>(x: Number) <span class="punctuation">-&gt;</span> Number &#123; x &#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f2</span>(x: Number) <span class="punctuation">-&gt;</span> NUmber &#123; x &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: Number = <span class="number">2.3</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span>: Number = <span class="number">3.4</span>;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, <span class="title function_ invoke__">f1</span>(a), <span class="title function_ invoke__">f2</span>(b));</span><br></pre></td></tr></table></figure>
<p>使用<code>type</code>结构有两点好处：</p>
<ul>
<li>简洁代码，它使用了一个有意义的名字来表示原生类型了</li>
<li>方便性，不用频繁切换类型，只需要修改type的类型即可</li>
</ul>
<p>但<code>type</code>实际上有另一个重要用途，</p>
<h2 id="Generic-Traits"><a class="header-anchor" href="#Generic-Traits">¶</a>Generic Traits</h2>
<p>前面的章节我们知道有泛型函数和泛型结构体。trait也可以由一个或多个类型参数化表示，即要求它的函数需要泛型参数的情况。这个概念和Java的接口类似，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Searchable</span>&lt;Key&gt; &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">contains</span>(&amp;<span class="keyword">self</span>, key: Key) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">is_present</span>&lt;Collection&gt;(coll: &amp;Collection, id: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span></span><br><span class="line"><span class="keyword">where</span> Collection: Searchable&lt;<span class="type">u32</span>&gt; &#123;</span><br><span class="line">	coll.<span class="title function_ invoke__">contains</span>(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是该代码的完整实现，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Searchable</span>&lt;Key&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">contains</span>(&amp;<span class="keyword">self</span>, key: Key) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RecordWithId</span> &#123;</span><br><span class="line">    id: <span class="type">u32</span>,</span><br><span class="line">    _descr: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NameSetWithId</span> &#123;</span><br><span class="line">    data: <span class="type">Vec</span>&lt;RecordWithId&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Searchable</span>&lt;<span class="type">u32</span>&gt; <span class="keyword">for</span> <span class="title class_">NameSetWithId</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">contains</span>(&amp;<span class="keyword">self</span>, key: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">record</span> <span class="keyword">in</span> <span class="keyword">self</span>.data.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> record.id == key &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">is_present</span>&lt;Collection&gt;(coll: &amp;Collection, id: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span></span><br><span class="line"><span class="keyword">where</span> Collection: Searchable&lt;<span class="type">u32</span>&gt; &#123;</span><br><span class="line">    coll.<span class="title function_ invoke__">contains</span>(id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">names</span> = NameSetWithId &#123;</span><br><span class="line">	data: <span class="built_in">vec!</span>[</span><br><span class="line">	RecordWithId &#123;</span><br><span class="line">		id: <span class="number">34</span>,</span><br><span class="line">		_descr: <span class="string">&quot;John&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">	&#125;,</span><br><span class="line">		RecordWithId &#123;</span><br><span class="line">			id: <span class="number">49</span>,</span><br><span class="line">			_descr: <span class="string">&quot;Jane&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">		&#125;,</span><br><span class="line">	],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, <span class="title function_ invoke__">is_present</span>(&amp;names, <span class="number">48</span>), <span class="title function_ invoke__">is_present</span>(&amp;names, <span class="number">49</span>));</span><br></pre></td></tr></table></figure>
<p>声明了<code>Searchable</code>泛型trait后，也声明了两个结构体：“RecordWithId”，表示由唯一数字标识的数据元素；“NameSetWithId”，表示一个类型为<code>RecordWithId</code>的集合。</p>
<p>然后，trait实现了这个集合类型。有两个方式实现：保留泛型参数，编写类似于<code>impl&lt;T&gt; Searchable&lt;T&gt; for NameSetWithId &#123;</code>；这里是另一种实现方法，因为<code>contains</code>不仅需要指定<code>NameSetWithId</code>，还需要知道<code>Key</code>的具体类型。</p>
<p>定义了<code>is_present</code>函数，要是有这个函数，需要定义对应的结构体。</p>
<p>这个解决方案虽然生效了，但有一些缺陷。</p>
<p>这里，<code>Searchable</code>需要指定<code>Key</code>的类型是<code>u32</code>，另外还要指定参数化类型的值，但在<code>where</code>从句中又重复指定了一次，</p>
<p>考虑更复杂的情况，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Searchable</span>&lt;Key, Count&gt; &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">contains</span>(&amp;<span class="keyword">self</span>, key: Key) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">count</span>(&amp;<span class="keyword">self</span>, key: Key) <span class="punctuation">-&gt;</span> Count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RecordWithId</span> &#123;</span><br><span class="line">	id: <span class="type">u32</span>,</span><br><span class="line">	_descr: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NameSetWithId</span> &#123;</span><br><span class="line">	data: <span class="type">Vec</span>&lt;RecordWithId&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Searchable</span>&lt;<span class="type">u32</span>, <span class="type">usize</span>&gt; <span class="keyword">for</span> <span class="title class_">NameSetWithId</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">contains</span>(&amp;<span class="keyword">self</span>, key: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> <span class="variable">record</span> <span class="keyword">in</span> <span class="keyword">self</span>.data.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">			<span class="keyword">if</span> record.id == key &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">count</span>(&amp;<span class="keyword">self</span>, key: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">		<span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> <span class="variable">record</span> <span class="keyword">in</span> <span class="keyword">self</span>.data.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">			<span class="keyword">if</span> record.id == key &#123;</span><br><span class="line">				c += <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		c</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">is_present</span>&lt;Collection&gt;(coll: &amp;Collection, id: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span></span><br><span class="line"><span class="keyword">where</span> Collection: Searchable&lt;<span class="type">u32</span>, <span class="type">usize</span>&gt;, &#123;</span><br><span class="line">	coll.<span class="title function_ invoke__">contains</span>(id)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">names</span> = NameSetWithId &#123;</span><br><span class="line">	data: <span class="built_in">vec!</span>[</span><br><span class="line">		RecordWithId &#123;</span><br><span class="line">			id: <span class="number">34</span>,</span><br><span class="line">			_desrc: <span class="string">&quot;John&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">		&#125;,</span><br><span class="line">		RecordWithId &#123;</span><br><span class="line">			id: <span class="number">49</span>,</span><br><span class="line">			_desrc: <span class="string">&quot;Jane&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">	],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print!</span>(</span><br><span class="line">	<span class="string">&quot;&#123;&#125;, &#123;&#125;; &#123;&#125; &#123;&#125;&quot;</span>,</span><br><span class="line">	names.<span class="title function_ invoke__">count</span>(<span class="number">48</span>),</span><br><span class="line">	names.<span class="title function_ invoke__">count</span>(<span class="number">49</span>),</span><br><span class="line">	<span class="title function_ invoke__">is_present</span>(&amp;names, <span class="number">48</span>),</span><br><span class="line">	<span class="title function_ invoke__">is_present</span>(&amp;names, <span class="number">49</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这里不明显地<code>is_present</code>的泛型函数签名，必须指定新的类型。但这个函数并没有使用这个类型，这个类型参数在这里没有很大意义。</p>
<h2 id="Using-Associated-Types-to-Simplify-Generic-Traits-Use"><a class="header-anchor" href="#Using-Associated-Types-to-Simplify-Generic-Traits-Use">¶</a>Using Associated Types to Simplify Generic Traits Use</h2>
<p>前面以及描述了这个无实际意义的泛型参数签名的问题。一个最好的解决方案如下，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Searchable</span> &#123; <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Key</span>; <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Count</span>; <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">contains</span>(&amp;<span class="keyword">self</span>, key: <span class="keyword">Self</span>::Key) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;  <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">count</span>(&amp;<span class="keyword">self</span>, key: <span class="keyword">Self</span>::Key) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Count; <span class="comment">//5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RecordWithId</span> &#123;</span><br><span class="line">    id: <span class="type">u32</span>,</span><br><span class="line">    _desrc: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NameSetWithId</span> &#123;</span><br><span class="line">    data: <span class="type">Vec</span>&lt;RecordWithId&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Searchable</span> <span class="keyword">for</span> <span class="title class_">NameSetWithId</span> &#123; <span class="comment">//6</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Key</span> = <span class="type">u32</span>; <span class="comment">//7</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Count</span> = <span class="type">usize</span>; <span class="comment">//8</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">contains</span>(&amp;<span class="keyword">self</span>, key: <span class="keyword">Self</span>::Key) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;    <span class="comment">//9</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">record</span> <span class="keyword">in</span> <span class="keyword">self</span>.data.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> record.id == key &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">count</span>(&amp;<span class="keyword">self</span>, key: <span class="keyword">Self</span>::Key) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;  <span class="comment">//10</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">record</span> <span class="keyword">in</span> <span class="keyword">self</span>.data.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> record.id == key &#123;</span><br><span class="line">                c += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        c</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">is_present</span>&lt;Collection&gt;(</span><br><span class="line">    coll: &amp;Collection, </span><br><span class="line">    id: &lt;Collection <span class="keyword">as</span> Searchable&gt;::Key,    <span class="comment">// 11</span></span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">bool</span></span><br><span class="line"><span class="keyword">where</span> Collection: Searchable,   <span class="comment">//12</span></span><br><span class="line">&#123;</span><br><span class="line">    coll.<span class="title function_ invoke__">contains</span>(id)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">names</span> = NameSetWithId &#123;</span><br><span class="line">	data: <span class="built_in">vec!</span>[</span><br><span class="line">		RecordWithId &#123;</span><br><span class="line">			id: <span class="number">34</span>,</span><br><span class="line">			_desrc: <span class="string">&quot;John&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">		&#125;,</span><br><span class="line">		RecordWithId &#123;</span><br><span class="line">			id: <span class="number">49</span>,</span><br><span class="line">			_desrc: <span class="string">&quot;Jane&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">		&#125;,</span><br><span class="line">	],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;; &#123;&#125; &#123;&#125;&quot;</span>,</span><br><span class="line">	   names.<span class="title function_ invoke__">count</span>(<span class="number">48</span>),</span><br><span class="line">	   names.<span class="title function_ invoke__">count</span>(<span class="number">49</span>),</span><br><span class="line">	   <span class="title function_ invoke__">is_present</span>(&amp;names, <span class="number">48</span>),</span><br><span class="line">	   <span class="title function_ invoke__">is_present</span>(&amp;names, <span class="number">49</span>));</span><br></pre></td></tr></table></figure>
<p>首先是，“Searchable”特质不再使用泛型，而是将泛型定义在自身内部，</p>
<blockquote>
<p>这点写法和Scala的trait真的非常非常像…</p>
</blockquote>
<p>因此，每次使用“Key”和“Count”类型参数时，都需要带前缀“Self::”。</p>
<p>这些改变的好处体现在<code>is_present</code>方法签名上。首先如其用具体的类型，这里用一个关联类型<code>Key</code>指定，这个不需要在指定<code>Searchable</code>，因为它没有泛型。</p>
<p>这里将类型的定义绑定在一个<code>trait</code>上，这种实现机制，对于大型软件开发更有优势。</p>
<h2 id="the-“Iterator”-Standard-Trait-Declaration"><a class="header-anchor" href="#the-“Iterator”-Standard-Trait-Declaration">¶</a>the “Iterator” Standard Trait Declaration</h2>
<p>关于“<code>Iterator</code>”这个标准trait，我们说过它仅包含一个item：<code>next</code>函数签名。这样说不对的。应该说是一个泛型的item。</p>
<p>因为它由<code>type</code>元素签名，你可以认为它在标准库中的定义是这样的，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种定义强制要求具体的迭代实现要为<code>Item</code>类型定义，以及实现<code>next</code>的方法体，</p>
<p>下面是一种可能的实现range的方式，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">MyIterator</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyRangeIterator</span>&lt;T&gt; &#123;</span><br><span class="line">	current: T,</span><br><span class="line">	limit: T,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyIterator</span> <span class="keyword">for</span> <span class="title class_">MyRangeIterator</span>&lt;<span class="type">u32</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">self</span>.current == <span class="keyword">self</span>.limit &#123;</span><br><span class="line">			<span class="literal">None</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">self</span>.current += <span class="number">1</span>;</span><br><span class="line">			<span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.current - <span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">range_it</span> = MyRangeIterator &#123;</span><br><span class="line">	current: <span class="number">10</span>,</span><br><span class="line">	limit: <span class="number">13</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;, &quot;</span>, range_it.<span class="title function_ invoke__">next</span>());</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;, &quot;</span>, range_it.<span class="title function_ invoke__">next</span>());</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;, &quot;</span>, range_it.<span class="title function_ invoke__">next</span>());</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;, &quot;</span>, range_it.<span class="title function_ invoke__">next</span>());</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;, &quot;</span>, range_it.<span class="title function_ invoke__">next</span>());</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;, &quot;</span>, range_it.<span class="title function_ invoke__">next</span>());</span><br></pre></td></tr></table></figure>
<p>这里使用了<code>MyRangeIterator&lt;u32&gt;</code>，指定了它的具体类型，但实际上，我们不需要定义<code>MyIterator</code>特质，因为我们可以直接使用标准库的<code>Iterator</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyRangeIterator</span>&lt;T&gt; &#123;</span><br><span class="line">	current: T,</span><br><span class="line">	limit: T,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">MyRangeIterator</span>&lt;<span class="type">u32</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">self</span>.current == <span class="keyword">self</span>.limit &#123;</span><br><span class="line">			<span class="literal">None</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">self</span>.current += <span class="number">1</span>;</span><br><span class="line">			<span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.current - <span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;; &quot;</span>, </span><br><span class="line">	MyRangeIterator &#123;</span><br><span class="line">			current: <span class="number">10</span>,</span><br><span class="line">			limit: <span class="number">13</span>,</span><br><span class="line">	&#125;.collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;()</span><br><span class="line">);</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> (MyRangeIterator &#123;</span><br><span class="line">	current: <span class="number">20</span>,</span><br><span class="line">	limit: <span class="number">24</span>,</span><br><span class="line">&#125;) &#123;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为“MyRangeIterator”对象有实现“Iterator”特质的类型，所以它可以使用<code>collect</code>迭代器消费者。</p>
<h2 id="Using-Generic-Iterators"><a class="header-anchor" href="#Using-Generic-Iterators">¶</a>Using Generic Iterators</h2>
<p>现在，回到原先那个<code>Item</code>无用的问题。我们想要实现泛型函数<code>get_third</code>，它接收任何迭代器，返回迭代器第三个元素，问题可以由下面代码解决，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_third</span>&lt;Iter&gt;(<span class="keyword">mut</span> iterator: Iter) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Iter::Item&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">	Iter: std::iter::<span class="built_in">Iterator</span>,</span><br><span class="line">&#123;</span><br><span class="line">	iterator.<span class="title function_ invoke__">next</span>();</span><br><span class="line">	iterator.<span class="title function_ invoke__">next</span>();</span><br><span class="line">	iterator.<span class="title function_ invoke__">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(</span><br><span class="line">	<span class="string">&quot;&#123;:?&#125; &#123;:?&#125; &#123;:?&#125; &#123;:?&#125;&quot;</span>,</span><br><span class="line">	<span class="title function_ invoke__">get_third</span>(<span class="number">10</span>..<span class="number">12</span>),</span><br><span class="line">	<span class="title function_ invoke__">get_third</span>(<span class="number">20</span>..<span class="number">29</span>),</span><br><span class="line">	<span class="title function_ invoke__">get_third</span>([<span class="number">31</span>, <span class="number">32</span>].<span class="title function_ invoke__">iter</span>()),</span><br><span class="line">	<span class="title function_ invoke__">get_third</span>([<span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>].<span class="title function_ invoke__">iter</span>())</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这里直接用<code>where</code>来绑定的<code>Item</code>的范围，这样一来，就可以访问<code>Item</code>关联的类型了，包括它的方法<code>next</code>。以及它的返回类型就是<code>Option&lt;Iter::Item&gt;</code>。</p>
<p>这段代码，对于迭代参数类型的函数编写提供了参考。实际上，标准库中已经定义了类型的迭代器消费者<code>nth</code>。所以下面写法是等价的，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print!</span>(</span><br><span class="line">	<span class="string">&quot;&#123;:?&#125; &#123;:?&#125; &#123;:?&#125; &#123;:?&#125;&quot;</span>,</span><br><span class="line">	(<span class="number">10</span>..<span class="number">12</span>).<span class="title function_ invoke__">nth</span>(<span class="number">2</span>),</span><br><span class="line">	(<span class="number">20</span>..<span class="number">29</span>).<span class="title function_ invoke__">nth</span>(<span class="number">2</span>),</span><br><span class="line">	([<span class="number">31</span>, <span class="number">32</span>].<span class="title function_ invoke__">iter</span>()).<span class="title function_ invoke__">nth</span>(<span class="number">2</span>),</span><br><span class="line">	([<span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>].<span class="title function_ invoke__">iter</span>()).<span class="title function_ invoke__">nth</span>(<span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</div></article><nav class="article-nav"><div class="article-nav-prev"><a href="/2023/01/19/rust/beginning/chapter19_Object-Oriented%20Programming/">rust基础入门[19] - Object-Oriented Programming</a></div><div class="article-nav-next"><a href="/2023/01/17/rust/beginning/chapter17_IO%20and%20Error%20Handling/">rust基础入门[17] - IO and Error Handling</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2023/01/18/rust/beginning/chapter18_Using Traits/';
var disqus_title = 'rust基础入门[18] - Using Traits';
var disqus_url = 'https://galudisu.info/2023/01/18/rust/beginning/chapter18_Using Traits/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>