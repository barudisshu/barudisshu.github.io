<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>rust基础入门[20] - Standard Library Collections</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/maths/">Maths</a></li><li class="menu-item"><a class="menu-link" href="/projects/">Projects</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/maths/">Maths</a></li><li class="menu-item"><a class="menu-link" href="/projects/">Projects</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">rust基础入门[20] - Standard Library Collections</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2023-01-20</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/rust/">rust</a></p><p class="meta-item meta-category"><span class="meta-item-title"></span><i class="icon-bookmark"> </i><a class="category-link" href="/categories/learning/">learning</a></p></div><div class="article-content"><p>本章覆盖有：</p>
<ul>
<li>如何度量运行部分代码所花费的时间</li>
<li>基于性能因素，如何使用哪种类型的集合</li>
<li>集合中的各种操作中哪个更好：顺序扫描(sequential scan)、两端插入和删除(insertion and removal of items at both ends)、删除最大项(removal of the largest item)、搜索(search)、键搜索(search by key)、保持顺序(keeping items sorted)</li>
</ul>
<span id="more"></span>
<h2 id="Collections"><a class="header-anchor" href="#Collections">¶</a>Collections</h2>
<p>数组、向量、结构体、元组结构体、元组、枚举属于数据类型，它们的对象可能包含几个其它对象。然而，对于结构体、元组-结构体、元组、枚举，每个包含的对象，需要指定声明类型和构造类型，它们不能存储多个对象。相反数组和向量的数据类型会包含多个对象，这一类对象称为“集合”。</p>
<p>数组和向量是最佳集合：内存高效，读取速度快，CPU缓存高效，能通过索引快速访问内部元素。当然，在某些情况不尽是高效的，这种情况下需要使用其它集合。Rust标准库提供了各种各样的集合类型：<code>VecDeque&lt;T&gt;</code>、<code>LinkedList&lt;T&gt;</code>、<code>BinaryHeap&lt;T&gt;</code>、<code>BTreeSet&lt;T&gt;</code>、<code>BTreeMap&lt;K,V&gt;</code>、<code>HashSet&lt;T&gt;</code>和<code>HashMap&lt;K,V&gt;</code>。</p>
<p>说到集合，数组是一个单独案例，因为它完全是栈分配的，以及在编译期已经定义了大小。而对于其它集合，包括vector，元素个数可变，它将header存储在stack，数据部分则存储在堆。这种称为“动态数据集dynamically-sized collections”。</p>
<h2 id="Measuring-Execution-Time"><a class="header-anchor" href="#Measuring-Execution-Time">¶</a>Measuring Execution Time</h2>
<p>集合的选取更多地由它的性能决定，先绕开这方面内容，看看如何精确度量不同Rust代码所花费的性能。</p>
<p>对于软件开发者来说性能是很重要的一方面。单个函数的运行，高级语言都要求命令处理花费至毫秒和秒级别，像Rust这类低级语言，都要求毫秒甚至纳秒。</p>
<p>在Rust标准库中，有几个函数可以度量源代码消耗的时间，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::time::Instant;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">elapsed_ms</span>(t1: Instant, t2: Instant) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = t2 - t1;</span><br><span class="line">    t.<span class="title function_ invoke__">as_secs</span>() <span class="keyword">as</span> <span class="type">f64</span> * <span class="number">1000</span>. + t.<span class="title function_ invoke__">subsec_nanos</span>() <span class="keyword">as</span> <span class="type">f64</span> / <span class="number">1e6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">time0</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10_000</span> &#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">time1</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">elapsed_ms</span>(time0, time1));</span><br></pre></td></tr></table></figure>
<p>程序会打印0到9999的整数，然后将所花费的毫秒数输出。</p>
<p>所花费的时间跟计算机能力有关，当然也跟编译器的优化有关。</p>
<p>前面章节说到，可以用<code>rustc</code>来编译源代码文件，但是这个命令并没有编译器优化，只是单纯生成机器码用于调试，它不是高效的。</p>
<p>如果你对性能感兴趣，可以带上编译参数<code>-O</code>。省略这个参数，所有优化都是禁用的。</p>
<p>因此，这章示例可以通过下面命令行编译优化，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc -O main.rs</span><br></pre></td></tr></table></figure>
<p>要度量一个时间，你应该用<code>Instant</code>类的<code>now</code>函数。这个类型定义在Rust的标准库中。</p>
<h2 id="Performing-Arbitrary-Insertions-and-Removals"><a class="header-anchor" href="#Performing-Arbitrary-Insertions-and-Removals">¶</a>Performing Arbitrary Insertions and Removals</h2>
<p>回到原来的集合处理。下面程序是非常高效的，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SIZE: <span class="type">usize</span> = <span class="number">100_000_000</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t0</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::&lt;<span class="type">usize</span>&gt;::<span class="title function_ invoke__">with_capacity</span>(SIZE);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t1</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..SIZE &#123;</span><br><span class="line">	v.<span class="title function_ invoke__">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t2</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..SIZE &#123;</span><br><span class="line">	v.<span class="title function_ invoke__">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t3</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, <span class="title function_ invoke__">elapsed_ms</span>(t0, t1), <span class="title function_ invoke__">elapsed_ms</span>(t1, t2), <span class="title function_ invoke__">elapsed_ms</span>(t2, t3));</span><br></pre></td></tr></table></figure>
<p>记得添加<code>-O</code>进行编译。</p>
<p>程序将打印三段数字，它是由编译器、或者有操作系统所决定。</p>
<p>假设你本机输出的数据是：“0.002667 454.516057 87.302678”。</p>
<p>这意味着创建一个vector为这个<code>usize</code>对象分配“房间”，它占64位系统800M，以及少于3毫秒的消耗时间。要将一千万的值塞入这个空间，不使用内存派遣，少于1秒的损耗时间，同时还要删除所有数据，花费1/10秒的时间。</p>
<p>如果不加<code>-O</code>参数编译，你会发现它花费时间非常大。</p>
<p>相反，下面的程序非常低效，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SIZE: <span class="type">usize</span> = <span class="number">100_000_000</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t0</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::&lt;<span class="type">usize</span>&gt;::<span class="title function_ invoke__">with_capacity</span>(SIZE);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t1</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..SIZE &#123;</span><br><span class="line">	v.<span class="title function_ invoke__">insert</span>(<span class="number">0</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t2</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..SIZE &#123;</span><br><span class="line">	v.<span class="title function_ invoke__">remove</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t3</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, <span class="title function_ invoke__">elapsed_ms</span>(t0, t1), <span class="title function_ invoke__">elapsed_ms</span>(t1, t2), <span class="title function_ invoke__">elapsed_ms</span>(t2, t3));</span><br></pre></td></tr></table></figure>
<p>它会打印：“0.00178 2038.879344 2029.447851”。</p>
<p>要创建一个800KB的vector，花费少于2毫秒的时间，但是插入数据却花费了多于2秒的时间，以及差不多等同的时间用来删除数据。这里发现插入动作，比前面花费更多的时间。</p>
<p>导致两者的差异很好解析。</p>
<p>从栈顶添加元素，只需要确保有足够的空间，然后将数据拷贝到缓冲区，增加元素个数。对于计算机来说，处理这些时间少于5纳秒，包括迭代器的移位动作。</p>
<p>同样，对于从栈顶删除元素，确保vector不为空，然后递减元素，花费不到1纳秒的时间。</p>
<p>相反，从vector的开始部分插入元素，首先你需要将地址进行转换，每次有新的元素过来，都要释放地址空间。虽然转换很快，随着元素个数的增加，要插入首位置的元素也越来越多。</p>
<p>类似的，要从首位置移除元素，需要将所有元素都转换一遍，不仅仅是首位置，</p>
<p>从计算复杂度表示，栈顶(尾部)插入或删除元素是<code>O(K)</code>复杂度，它是常量复杂度(constant complexity)；而对于从栈尾(首部)插入或删除元素是<code>O(N)</code>复杂度，它是线性复杂度(linear complexity)。</p>
<p>即使是在中间部分插入或删除数据，性能可能会稍微好一点，但仍然比在栈顶插入或删除数据要慢。</p>
<h2 id="Queues"><a class="header-anchor" href="#Queues">¶</a>Queues</h2>
<p>如果是在首部和尾部同时有插入或删除动作，这个vector不会是一个优化集合。典型情况类似于Queue，它在尾部插入元素，在首部萃取元素，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SIZE: <span class="type">usize</span> = <span class="number">40_000</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t0</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::&lt;<span class="type">usize</span>&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..SIZE &#123;</span><br><span class="line">	v.<span class="title function_ invoke__">push</span>(i);</span><br><span class="line">	v.<span class="title function_ invoke__">push</span>(SIZE + i);</span><br><span class="line">	v.<span class="title function_ invoke__">remove</span>(<span class="number">0</span>);</span><br><span class="line">	v.<span class="title function_ invoke__">push</span>(SIZE * <span class="number">2</span> + i);</span><br><span class="line">	v.<span class="title function_ invoke__">remove</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t1</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="keyword">while</span> v.<span class="title function_ invoke__">len</span>() &gt; <span class="number">0</span> &#123;</span><br><span class="line">	v.<span class="title function_ invoke__">remove</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t2</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, <span class="title function_ invoke__">elapsed_ms</span>(t0, t1), <span class="title function_ invoke__">elapsed_ms</span>(t1, t2));</span><br></pre></td></tr></table></figure>
<p>可能的输出会是：“561.189636 276.056133”。</p>
<p>代码中，创建了一个空的vector，用了4千次循环，将三个数插入栈顶，以及在栈顶删除两个元素。第二个循环体内，每次从栈顶删除元素。第一个循环片段花费了大约半秒的时间，第二个循环体花费了大约四分之一秒。实际上，大部分时间都用在了萃取元素上，插入其实是非常快的。</p>
<p>我们希望插入元素总是发生在栈尾，萃取(extract)元素总是在栈顶，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SIZE: <span class="type">usize</span> = <span class="number">40_000</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t0</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::&lt;<span class="type">usize</span>&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..SIZE &#123;</span><br><span class="line">	v.<span class="title function_ invoke__">insert</span>(<span class="number">0</span>, i);</span><br><span class="line">	v.<span class="title function_ invoke__">insert</span>(<span class="number">0</span>, SIZE + i);</span><br><span class="line">	v.<span class="title function_ invoke__">pop</span>();</span><br><span class="line">	v.<span class="title function_ invoke__">insert</span>(<span class="number">0</span>, SIZE * <span class="number">2</span> + i);</span><br><span class="line">	v.<span class="title function_ invoke__">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t1</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="keyword">while</span> v.<span class="title function_ invoke__">len</span>() &gt; <span class="number">0</span> &#123;</span><br><span class="line">	v.<span class="title function_ invoke__">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t2</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, <span class="title function_ invoke__">elapsed_ms</span>(t0, t1), <span class="title function_ invoke__">elapsed_ms</span>(t1, t2));</span><br></pre></td></tr></table></figure>
<p>结果可能打印：“790.365012 0.000112”。</p>
<p>现在插入很慢，删除却很快。可是总共花费的时间并没有提升多少。我们尝试用<code>VecDeque</code>类型，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SIZE: <span class="type">usize</span> = <span class="number">40_000</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t0</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = std::collections::VecDeque::&lt;<span class="type">usize</span>&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..SIZE &#123;</span><br><span class="line">	v.<span class="title function_ invoke__">insert</span>(<span class="number">0</span>, i);</span><br><span class="line">	v.<span class="title function_ invoke__">insert</span>(<span class="number">0</span>, SIZE + i);</span><br><span class="line">	v.<span class="title function_ invoke__">pop</span>();</span><br><span class="line">	v.<span class="title function_ invoke__">insert</span>(<span class="number">0</span>, SIZE * <span class="number">2</span> + i);</span><br><span class="line">	v.<span class="title function_ invoke__">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t1</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="keyword">while</span> v.<span class="title function_ invoke__">len</span>() &gt; <span class="number">0</span> &#123;</span><br><span class="line">	v.<span class="title function_ invoke__">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t2</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, <span class="title function_ invoke__">elapsed_ms</span>(t0, t1), <span class="title function_ invoke__">elapsed_ms</span>(t1, t2));</span><br></pre></td></tr></table></figure>
<p>结果打印：“0.40793 0.050257”。</p>
<p>整段程序花费不到半毫秒的时间，这里需要显式声明<code>VecDeque</code>的类型，它是“vector-like double-ended queue”的缩写，“queue”表示的是“sequential collection into which items are inserted at one end and from which items are extracted at the other end”。“double-ended”表示在尾部插入元素，也可以在尾部萃取元素，不带有penalty。“vector-like”表示具有vector相似的操作。</p>
<p>要在vector栈顶添加或删除元素，可以简单使用<code>push</code>和<code>pop</code>，而对于<code>双端队列，double-ended queue</code>，需要理解两端的实现是等效的，插入元素可以用<code>push_front</code>和<code>push_back</code>，也可以在两端用<code>pop_front</code>和<code>pop_back</code>删除元素。虽然<code>VecDeque</code>类型支持<code>insert</code>和<code>remove</code>函数，但不被推荐使用，因为它不是高效的。</p>
<p>给出的队列非常高效，为什么我们总是用它，而是选择用vector？</p>
<p>原因是vector更普遍的操作是迭代、元素访问，这种时间损耗一直保持为常量因素。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SIZE: <span class="type">usize</span> = <span class="number">40_000</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::&lt;<span class="type">usize</span>&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vd</span> = std::collections::VecDeque::&lt;<span class="type">usize</span>&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t0</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..SIZE &#123;</span><br><span class="line">	v.<span class="title function_ invoke__">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t1</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..SIZE &#123;</span><br><span class="line">	vd.<span class="title function_ invoke__">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="number">2</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> v.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">	count += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t3</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> vd.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">	count += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t4</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, count,</span><br><span class="line">	<span class="title function_ invoke__">elapsed_ms</span>(t0, t1), <span class="title function_ invoke__">elapsed_ms</span>(t1, t2),</span><br><span class="line">	<span class="title function_ invoke__">elapsed_ms</span>(t2, t3), <span class="title function_ invoke__">elapsed_ms</span>(t3, t4));</span><br></pre></td></tr></table></figure>
<p>可能打印：“1599960000 0.230073 0.203979 0.013144 0.035295”。</p>
<p>会发现，<code>Vec</code>和<code>VecDeque</code>几乎花费相当的时间，但对于扫描整个集合元素，<code>Vec</code>效率要高出两倍。</p>
<h2 id="Linked-Lists"><a class="header-anchor" href="#Linked-Lists">¶</a>Linked Lists</h2>
<p>对于某些应用，可能会频繁地在中间位置插入或删除元素。这种情况，向量(vector)和对象(queue)不是高效的，所以需要引入新的集合类型——<code>LinkedList</code>。</p>
<p>然而，如果你需要在一个集合进行大量操作，譬如添加或删除很多个条目，会比<code>Vec</code>或<code>VecDeque</code>要快很多，它会创建一个新的临时集合，并由临时集合替换原来的集合。</p>
<p><code>LinkedList</code>的使用，不应该用于那些需要频繁读取的位置做插入或删除操作。</p>
<h2 id="Binary-Heaps"><a class="header-anchor" href="#Binary-Heaps">¶</a>Binary Heaps</h2>
<p>访问集合还有另外一种方式，即所谓的“优先队列”。它出现在仅有两个函数的地方：插入元素和萃取元素。但每个元素都有优先值，萃取(extract)元素需要根据优先级获取。使用Vector时，可以类似下面这种方式包含这种行为，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(v: &amp;<span class="keyword">mut</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;, a: <span class="type">i32</span>) &#123;</span><br><span class="line">	v.<span class="title function_ invoke__">push</span>(a);</span><br><span class="line">	v.<span class="title function_ invoke__">sort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">48</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">35</span>, <span class="number">17</span>, <span class="number">13</span>, <span class="number">39</span>, <span class="number">12</span>, <span class="number">42</span>, <span class="number">33</span>, <span class="number">29</span>, <span class="number">27</span>, <span class="number">50</span>, <span class="number">16</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::&lt;<span class="type">i32</span>&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..a.<span class="title function_ invoke__">len</span>() / <span class="number">2</span> &#123;</span><br><span class="line">	<span class="title function_ invoke__">add</span>(&amp;<span class="keyword">mut</span> v, a[i * <span class="number">2</span>]);</span><br><span class="line">	<span class="title function_ invoke__">add</span>(&amp;<span class="keyword">mut</span> v, a[i * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, v.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ! v.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, v.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次将数组元素添加到vector时，vector都进行一次排序，它的元素保持升阶的顺序。所以vector的值的萃取也总可以得到最大值。</p>
<p>下面是另一种等价实现，只不过是在萃取前进行排序，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">extract</span>(v: &amp;<span class="keyword">mut</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> OPtion&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">	v.<span class="title function_ invoke__">sort</span>();</span><br><span class="line">	v.<span class="title function_ invoke__">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">48</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">35</span>, <span class="number">17</span>, <span class="number">13</span>, <span class="number">39</span>, <span class="number">12</span>, <span class="number">42</span>, <span class="number">33</span>, <span class="number">29</span>, <span class="number">27</span>, <span class="number">50</span>, <span class="number">16</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::&lt;<span class="type">i32</span>&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..a.<span class="title function_ invoke__">len</span>() / <span class="number">2</span> &#123;</span><br><span class="line">	v.<span class="title function_ invoke__">push</span>(a[i * <span class="number">2</span>]);</span><br><span class="line">	v.<span class="title function_ invoke__">push</span>(a[i * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, <span class="title function_ invoke__">extract</span>(&amp;<span class="keyword">mut</span> v).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ! v.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, <span class="title function_ invoke__">extract</span>(&amp;<span class="keyword">mut</span> v).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个代码都有不好之处在于频繁调用了<code>sort</code>函数，它有较大消耗。</p>
<p>下面是一个等价实现，并且更快，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">48</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">35</span>, <span class="number">17</span>, <span class="number">13</span>, <span class="number">39</span>, <span class="number">12</span>, <span class="number">42</span>, <span class="number">33</span>, <span class="number">29</span>, <span class="number">27</span>, <span class="number">50</span>, <span class="number">16</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = std::collections::BinaryHeap::&lt;<span class="type">i32</span>&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..a.<span class="title function_ invoke__">len</span>() / <span class="number">2</span> &#123;</span><br><span class="line">	v.<span class="title function_ invoke__">push</span>(a[i * <span class="number">2</span>]);</span><br><span class="line">	v.<span class="title function_ invoke__">push</span>(a[i * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, v.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ! v.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, v.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的二叉堆(binary heap)类似vector一样，可以调用<code>push</code>和<code>pop</code>函数，不同的是，二叉堆的<code>pop</code>函数萃取的是容器中最大的值。</p>
<h2 id="Ordered-Sets-and-Unordered-Sets"><a class="header-anchor" href="#Ordered-Sets-and-Unordered-Sets">¶</a>Ordered Sets and Unordered Sets</h2>
<p>集合概念中的Set是一种不包含重复元素的概念，存储这个元素的一个高效实现是“hashtable”，对应集合类型的<code>HashSet</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::&lt;_&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hs</span> = std::collections::HashSet::&lt;_&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">bs</span> = std::collections::BTreeSet::&lt;_&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> arr.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">	v.<span class="title function_ invoke__">push</span>(i);</span><br><span class="line">	hs.<span class="title function_ invoke__">insert</span>(i);</span><br><span class="line">	bs.<span class="title function_ invoke__">insert</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;Vec:&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> v.<span class="title function_ invoke__">iter</span>() &#123; <span class="built_in">print!</span>(<span class="string">&quot; &#123;&#125;&quot;</span>, i); &#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;. &#123;:?&#125;, v);</span></span><br><span class="line"><span class="string">print!(&quot;</span>HashSet :<span class="string">&quot;);</span></span><br><span class="line"><span class="string">for i in hs.iter() &#123; print!(&quot;</span> &#123;&#125;<span class="string">&quot;, i); &#125;</span></span><br><span class="line"><span class="string">println!(&quot;</span>. &#123;:?&#125;, hs);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;BTreeSet:&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> bs.<span class="title function_ invoke__">iter</span>() &#123; <span class="built_in">print!</span>(<span class="string">&quot; &#123;&#125;&quot;</span>, i); &#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;. &#123;:?&#125;&quot;</span>, bs);</span><br></pre></td></tr></table></figure>
<p>会打印，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vec: 6 8 2 8 4 9 6 1 8 0. [6, 8, 2, 8, 4, 9, 6, 1, 8, 0]</span><br><span class="line">HashSet : 8 2 9 6 4 0 1. &#123;8, 2, 9, 6, 4, 0, 1&#125;</span><br><span class="line">BTreeSet: 0 1 2 4 6 8 9. &#123;0, 1, 2, 4, 6, 8, 9&#125;</span><br></pre></td></tr></table></figure>
<p><code>Vec v</code>集合包含所有插入元素，保留插入顺序；<code>Hashset hs</code>集合不包含重复元素；<code>BTreeSet bs</code>进行了插入排序。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">elapsed_ms</span>(t1: Instant, t2: Instant) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = t2 - t1;</span><br><span class="line">    t.<span class="title function_ invoke__">as_secs</span>() <span class="keyword">as</span> <span class="type">f64</span> * <span class="number">1000</span>. + t.<span class="title function_ invoke__">subsec_nanos</span>() <span class="keyword">as</span> <span class="type">f64</span> / <span class="number">1e6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> SIZE: <span class="type">i32</span> = <span class="number">40_000</span>;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">ns_per_op</span>(t1: Instant, t2: Instant) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">elapsed_ms</span>(t1, t2) / SIZE <span class="keyword">as</span> <span class="type">f64</span> * <span class="number">1_000_000</span>.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::&lt;_&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hs</span> = std::collections::HashSet::&lt;_&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">bs</span> = std::collections::BTreeSet::&lt;_&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t0</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..SIZE &#123; v.<span class="title function_ invoke__">push</span>(i); &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t1</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..SIZE &#123; hs.<span class="title function_ invoke__">insert</span>(i); &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t2</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..SIZE &#123; bs.<span class="title function_ invoke__">insert</span>(i); &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t3</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..SIZE &#123; <span class="keyword">if</span> ! v.<span class="title function_ invoke__">contains</span>(&amp;i) &#123; <span class="keyword">return</span>; &#125; &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t4</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    v.<span class="title function_ invoke__">swap</span>(<span class="number">10_000</span>, <span class="number">20_000</span>);</span><br><span class="line">    v.<span class="title function_ invoke__">sort</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t5</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..SIZE &#123;</span><br><span class="line">        <span class="keyword">if</span> v.<span class="title function_ invoke__">binary_search</span>(&amp;i).<span class="title function_ invoke__">is_err</span>() &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t6</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..SIZE &#123; <span class="keyword">if</span> ! hs.<span class="title function_ invoke__">contains</span>(&amp;i) &#123; <span class="keyword">return</span>; &#125; &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t7</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..SIZE &#123; <span class="keyword">if</span> ! bs.<span class="title function_ invoke__">contains</span>(&amp;i) &#123; <span class="keyword">return</span>; &#125; &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t8</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Pushes in Vec: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">ns_per_op</span>(t0, t1));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Insertions in HashSet: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">ns_per_op</span>(t1, t2));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Insertions in BTreeSet: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">ns_per_op</span>(t2, t3));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Linear search in Vec: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">ns_per_op</span>(t3, t4));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Sort of Vec: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">ns_per_op</span>(t4, t5));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Binary search in Vec: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">ns_per_op</span>(t5, t6));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Search in HashSet: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">ns_per_op</span>(t6, t7));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Search in BTreeSet: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">ns_per_op</span>(t7, t8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将会打印：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Pushes in Vec: 6.4021</span><br><span class="line">Insertions in HashSet: 139.214</span><br><span class="line">Insertions in BTreeSet: 127.3047</span><br><span class="line">Linear search in Vec: 17389.3111</span><br><span class="line">Sort of Vec: 3.1132</span><br><span class="line">Binary search in Vec: 47.7641</span><br><span class="line">Search in HashSet: 36.5041</span><br><span class="line">Search in BTreeSet: 56.2444</span><br></pre></td></tr></table></figure>
<p>栈顶插入元素，花费6纳秒，<code>HashSet</code>和<code>BTreeSet</code>插入元素，花费接近20倍。</p>
<p>线性方式搜索vector，花费时间非常大，改为二分查找算法后，平均在50纳秒的时间。所以，如果插入比查找少的情况，每次插入元素之后进行排序，再用二分查找会更加高效。</p>
<p><code>HashSet</code>的查找花费40纳秒左右；<code>BTreeSet</code>的查找花费接近60纳秒左右。</p>
<p>优化数据结构的原则是，</p>
<p>首先声明一个trait，它包含有该数据结构的方法签名，接着实现这个trait，再测试这个trait的实现方法的性能，如果性能太低。重构代码进行优化，知道满意的实现。</p>
<h2 id="Ordered-Dictionaries-and-Unordered-Dictionaries"><a class="header-anchor" href="#Ordered-Dictionaries-and-Unordered-Dictionaries">¶</a>Ordered Dictionaries and Unordered Dictionaries</h2>
<p>集合处理简单的存储、访问使用外，另一种常见用法是“字典”，即由“key”进行访问。</p>
<p>字典可以看做是key-value对，它的处理由key决定。所以，字典不能有两个相同的key。</p>
<p>Rust标准库中提供了<code>HashMap</code>和<code>BTreeMap</code>的算法实现，类同于<code>HashSet</code>，<code>HashMap</code>不进行排序，但速度较快；<code>BTreeMap</code>较慢，但按顺序存储。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [(<span class="number">640</span>, <span class="string">&#x27;T&#x27;</span>), (<span class="number">917</span>, <span class="string">&#x27;C&#x27;</span>), (<span class="number">412</span>, <span class="string">&#x27;S&#x27;</span>), (<span class="number">670</span>, <span class="string">&#x27;T&#x27;</span>), (<span class="number">917</span>, <span class="string">&#x27;L&#x27;</span>)];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::&lt;_&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hs</span> = std::collections::HashMap::&lt;_, _&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">bs</span> = std::collections::BTreeMap::&lt;_, _&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">for</span> &amp;(key, value) <span class="keyword">in</span> arr.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">	v.<span class="title function_ invoke__">push</span>((key, value));</span><br><span class="line">	hs.<span class="title function_ invoke__">insert</span>(key, value);</span><br><span class="line">	bs.<span class="title function_ invoke__">insert</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;Vec:&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> &amp;(key, value) <span class="keyword">in</span> v.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot; &#123;&#125;: &#123;&#125;,&quot;</span>, key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;\n &#123;:?&#125;&quot;</span>, v);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;HashMap:&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> hs.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot; &#123;&#125;: &#123;&#125;,&quot;</span>, key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;\n &#123;:?&#125;&quot;</span>, hs);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;BTreeMap:&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> bs.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot; &#123;&#125;: &#123;&#125;,&quot;</span>, key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;\n &#123;:?&#125;&quot;</span>, bs);</span><br></pre></td></tr></table></figure>
<p>结果打印：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vec: 640: T, 917: C, 412: S, 670: T, 917: L,</span><br><span class="line"> [(640, &#x27;T&#x27;), (917, &#x27;C&#x27;), (412, &#x27;S&#x27;), (670, &#x27;T&#x27;), (917, &#x27;L&#x27;)]</span><br><span class="line">HashMap: 640: T, 412: S, 917: L, 670: T,</span><br><span class="line"> &#123;640: &#x27;T&#x27;, 412: &#x27;S&#x27;, 917: &#x27;L&#x27;, 670: &#x27;T&#x27;&#125;</span><br><span class="line">BTreeMap: 412: S, 640: T, 670: T, 917: L,</span><br><span class="line"> &#123;412: &#x27;S&#x27;, 640: &#x27;T&#x27;, 670: &#x27;T&#x27;, 917: &#x27;L&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>字典中不允许重复的key，但允许重复的value，以及<code>BTreeMap</code>按照key顺序排列，而<code>HashMap</code>顺序随机。</p>
<p>它们的性能类似于<code>HashSet</code>和<code>BTreeSet</code>。</p>
<h2 id="Collections-in-C-and-in-Rust"><a class="header-anchor" href="#Collections-in-C-and-in-Rust">¶</a>Collections in C++ and in Rust</h2>
<p>C++标准库中对应Rust集合列表如下，某些集合库在Rust中并没有对应，用<code>~</code>标记表示最相似的集合，</p>
<table>
<thead>
<tr>
<th style="text-align:left">C++</th>
<th style="text-align:left">Rust</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>array&lt;T&gt;</code></td>
<td style="text-align:left"><code>[T]</code></td>
</tr>
<tr>
<td style="text-align:left"><code>vector&lt;T&gt;</code></td>
<td style="text-align:left"><code>Vec&lt;T&gt;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>deque&lt;T&gt;</code></td>
<td style="text-align:left"><code>VecDeque&lt;T&gt;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>forward_list&lt;T&gt;</code></td>
<td style="text-align:left"><code>~ LinkedList&lt;T&gt;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>list&lt;T&gt;</code></td>
<td style="text-align:left"><code>LinkedList&lt;T&gt;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>stack&lt;T&gt;</code></td>
<td style="text-align:left"><code>~ Vec&lt;T&gt;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>queue&lt;T&gt;</code></td>
<td style="text-align:left"><code>~ VecDeque&lt;T&gt;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>priority_queue&lt;T&gt;</code></td>
<td style="text-align:left"><code>BinaryHeap&lt;T&gt;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>set&lt;T&gt;</code></td>
<td style="text-align:left"><code>BTreeSet&lt;T&gt;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>multiset&lt;T&gt;</code></td>
<td style="text-align:left"><code>~ BTreeMap&lt;T,u32&gt;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>map&lt;K,V&gt;</code></td>
<td style="text-align:left"><code>BTreeMap&lt;K,V&gt;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>multimap&lt;K,V&gt;</code></td>
<td style="text-align:left"><code>~ BTreeMap&lt;K, (V,u32)&gt;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>unordered_set&lt;T&gt;</code></td>
<td style="text-align:left"><code>HashSet&lt;T&gt;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>unordered_multiset&lt;T&gt;</code></td>
<td style="text-align:left"><code>~ HashMap&lt;T,u32&gt;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>unordered_map&lt;K,V&gt;</code></td>
<td style="text-align:left"><code>HashMap&lt;K,V&gt;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>unordered_multimap&lt;K,V&gt;</code></td>
<td style="text-align:left"><code>~ HashMap&lt;K,(V,u32)&gt;</code></td>
</tr>
</tbody>
</table>
</div></article><nav class="article-nav"><div class="article-nav-prev"><a href="/2023/01/21/rust/beginning/chapter21_Drops,%20Moves,%20and%20Copies/">rust基础入门[21] - Drops, Moves, and Copies</a></div><div class="article-nav-next"><a href="/2023/01/19/rust/beginning/chapter19_Object-Oriented%20Programming/">rust基础入门[19] - Object-Oriented Programming</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2023/01/20/rust/beginning/chapter20_Standard Library Collections/';
var disqus_title = 'rust基础入门[20] - Standard Library Collections';
var disqus_url = 'https://galudisu.info/2023/01/20/rust/beginning/chapter20_Standard Library Collections/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>