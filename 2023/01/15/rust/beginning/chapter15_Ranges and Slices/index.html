<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>rust基础入门[15] - Ranges and Slices</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">rust基础入门[15] - Ranges and Slices</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2023-01-15</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/rust/">rust</a></p><p class="meta-item meta-category"><span class="meta-item-title"></span><i class="icon-bookmark"> </i><a class="category-link" href="/categories/learning/">learning</a></p></div><div class="article-content"><p>本章覆盖有：</p>
<ul>
<li>如何使用closed ranges和open-ended ranges</li>
<li>如何用slice处理array或vector的portions</li>
</ul>
<span id="more"></span>
<h2 id="The-Ranges"><a class="header-anchor" href="#The-Ranges">¶</a>The Ranges</h2>
<p>for loop的一种写法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">12</span> &#123; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i); &#125;</span><br></pre></td></tr></table></figure>
<p>其实还有另一种可能的写法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">dozen</span> = <span class="number">0</span>..<span class="number">12</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> dozen &#123; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i); &#125;</span><br></pre></td></tr></table></figure>
<p>这是显示了<code>0..12</code>从句不是<code>for</code>语句的语法，而是一个表达式，而且它的值可以指派给一个变量。以及这个值可以用于<code>for</code>语句。这中值类型称为“range”。</p>
<p>下面是使用range的更多相关代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">range</span>: std::ops::Range&lt;<span class="type">usize</span>&gt; = <span class="number">3</span>..<span class="number">8</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>,</span><br><span class="line">	range, range.start, range.end, range.<span class="title function_ invoke__">len</span>());</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> range &#123; <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;, &quot;</span>, i); &#125;</span><br></pre></td></tr></table></figure>
<p>打印输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3..8, 3, 8, 5</span><br><span class="line">3, 4, 5, 6, 7,</span><br></pre></td></tr></table></figure>
<p>从第一行得知，任何range都是一个<code>Range&lt;T&gt;</code>泛型类型的具象化，其中<code>T</code>必须是一个整形类型以表示range的极限。</p>
<p>第二条语句输出变量range的相关信息，第一个是它自身的debug值3…8；<code>start</code>和<code>end</code>为range的字段内容，为3和8。它表明了<code>Range</code>类型对象包含有两个字段。实际上，除此之外再没其它东西了。</p>
<p>然后<code>len</code>函数被调用，它是<code>end - start</code>的简单求值，即 <code>8 - 3 = 5</code>。</p>
<p>最后，range被用于for loop，用于浏览从<code>start</code>到<code>end</code>的值。这里的迭代值个数和<code>len</code>函数给的相同。</p>
<p><code>Range&lt;T&gt;</code>类型的参数化类型<code>T</code>，可以有两个参数进行推断：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = <span class="number">3u8</span>..<span class="number">12u8</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = <span class="number">3u8</span>..<span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r3</span> = <span class="number">3</span>..<span class="number">12u8</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r4</span> = <span class="number">3</span>..<span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r5</span> = -<span class="number">3</span>..<span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r6</span> = <span class="number">3</span>..<span class="number">12</span> <span class="keyword">as</span> <span class="type">i64</span>;</span><br><span class="line"><span class="built_in">print!</span>(</span><br><span class="line">	<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>,</span><br><span class="line">	std::mem:;<span class="title function_ invoke__">size_of_val</span>(&amp;r1),</span><br><span class="line">	std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;r2),</span><br><span class="line">	std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;r3),</span><br><span class="line">	std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;r4),</span><br><span class="line">	std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;r5),</span><br><span class="line">	std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;r6));</span><br></pre></td></tr></table></figure>
<p>打印：“2 2 2 8 8 16”。</p>
<p>变量<code>r1</code>的两个极值(extrames)声明为<code>u8</code>类型，因此它有确定的类型，<code>u8</code>占一个字节，整个range占两个字节。</p>
<p>变量<code>r2</code>和<code>r3</code>仅其中一个声明为<code>u8</code>，另外一个留待不指定。因此它强制为<code>u8</code>类型。</p>
<p>变量<code>r4</code>和<code>r5</code>都不指定，因此泛型参数<code>T</code>由默认值<code>i32</code>表示。</p>
<p>变量<code>r6</code>其中一个极值显式表述为<code>i64</code>，另一个未指定，所以<code>T</code>必须是<code>i64</code>。</p>
<p>注意下面所有语句都是不合法的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = <span class="number">3u8</span>..<span class="number">12i8</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span>: std::ops::Range&lt;<span class="type">u32</span>&gt; = -<span class="number">3</span>..<span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r3</span>: std::ops::Range&lt;<span class="type">i32</span>&gt; = <span class="number">3i16</span>..<span class="number">12</span>;</span><br></pre></td></tr></table></figure>
<p>第一条语句两个极值类型不同。第二条语句，-3不是<code>u32</code>类型的，最后一个语句，<code>3i16</code>不是<code>i32</code>类型的。</p>
<p>下面的语句可能允许，但可能出错，会出现编译告警：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">_r1</span> = <span class="number">3u8</span>..<span class="number">1200</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_r2</span> = <span class="number">3</span>..<span class="number">5_000_000_000</span>;</span><br></pre></td></tr></table></figure>
<p>两者都超出了整形的长度限制，其中第一条语句类型是<code>Range&lt;u8&gt;</code>，第二条是<code>Range&lt;i32&gt;</code>。</p>
<p>下面语句被允许并且不带告警。即使他们可能无意义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">_r1</span> = <span class="literal">false</span> .. <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_r2</span> = <span class="string">&quot;hello&quot;</span> .. <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_r3</span> = <span class="number">4.2</span> .. <span class="number">7.9</span>;</span><br></pre></td></tr></table></figure>
<p>实际上，这种荒诞的range不可以用于<code>for</code>循环中。</p>
<h2 id="Passing-a-Sequence-to-a-Function"><a class="header-anchor" href="#Passing-a-Sequence-to-a-Function">¶</a>Passing a Sequence to a Function</h2>
<p>让我们假设你需要创建一个函数，获取一个8个记录的数组参数，并返回数组中最小的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">min</span>(arr: [<span class="type">i32</span>; <span class="number">8</span>]) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">minimum</span> = arr[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..arr.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> arr[i] &lt; minimum &#123; minimum = arr[i]; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	minimum</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">min</span>([<span class="number">23</span>, <span class="number">17</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">28</span>, <span class="number">17</span>, <span class="number">30</span>]));</span><br></pre></td></tr></table></figure>
<p>程序会正确地打印12。但，这个<code>min</code>函数有某些缺陷：</p>
<ul>
<li>它拿的是整个数组的拷贝，需要大量的时间转换，并在栈空间和堆空间缓存了大量空间。</li>
<li>它不能处理数组的部分请求。</li>
<li>它仅能接收一个仅8个数的数组。如果传递了7或9个记录的数组，或得到一个编译错误。</li>
<li>它不能传递一个vector作为参数。</li>
</ul>
<p>为了克服第一个缺陷，你可以传递数组的引用，由值传递(by value)变为引用传递(by reference)，使用下面代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">min</span>(arr: &amp;[<span class="type">i32</span>; <span class="number">8</span>]) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">minimum</span> = arr[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..arr.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> arr[i] &lt; minimum &#123; minimum = arr[i]; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	minimum</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">min</span>(&amp;[<span class="number">23</span>, <span class="number">17</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">28</span>, <span class="number">17</span>, <span class="number">30</span>]));</span><br></pre></td></tr></table></figure>
<p>这里不用更改函数体内容，仅添加两处<code>&amp;</code>，一处在入参声明部分，即函数签名；另一个处是方法调用。函数体中的<code>arr</code>引用会隐式反引用处理。</p>
<p>为了克服第二个缺陷，你可以添加参数指定从哪个条目开始，另一个参数指定需要处理多少个：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">min</span>(arr: &amp;[<span class="type">i32</span>; <span class="number">8</span>], start: <span class="type">usize</span>, count: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">	<span class="comment">// Let&#x27;s assume &#x27;start&#x27; is between 0 and 7,</span></span><br><span class="line">	<span class="comment">// and &#x27;count&#x27; is between 1 and 8 - start.</span></span><br><span class="line">	<span class="keyword">let</span> <span class="variable">mu</span> minimum = arr[start];</span><br><span class="line">	<span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> start + <span class="number">1</span>..start + count &#123;</span><br><span class="line">		<span class="keyword">if</span> arr[i] &lt; minimum &#123; minimum = arr[i]; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	minimum</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">min</span>(&amp;[<span class="number">23</span>, <span class="number">17</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">28</span>, <span class="number">17</span>, <span class="number">30</span>], <span class="number">3</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>结果将打印输出15。实际上，它指定了处理两个条目，从位置3开始。即从<code>[16，15]</code>处理。</p>
<p>然而，还遗留两个缺陷。</p>
<p>考虑到我们的函数仅需要知道内存的开始地址，要处理多少个条目，序列条目的类型。因此不要求知道这个序列是不是大序列的一部分，更不想知道更大的序列在哪里开始和结束。</p>
<p>另外，考虑到任何vector将它的数据存储在栈分配的数组，因此只要知道要处理的条目在哪里，这个函数也可以处理。</p>
<h2 id="The-Slices"><a class="header-anchor" href="#The-Slices">¶</a>The Slices</h2>
<p>考虑所有这些，为了克服所有指出的错误，“切片(slice)”的概念被引入到该语言中。它的语法参考：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">min</span>(arr: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">	<span class="comment">// Let&#x27;s assume &#x27;arr&#x27; is not empty.</span></span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">minimum</span> = arr[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..arr.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> arr[i] &lt; minimum &#123; minimum = arr[i]; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	minimum</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">min</span>(&amp;[<span class="number">23</span>, <span class="number">17</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">28</span>, <span class="number">17</span>, <span class="number">30</span>]));</span><br></pre></td></tr></table></figure>
<p>和上一小节的不同是，“<code>; 8</code>”消失了。现在<code>arr</code>参数看起来是一个数组引用，并且没有指定数组的大小。</p>
<p>这种类型是一个<code>切片引用(a reference to a slice, or slice reference)</code>。它的泛型形式是“<code>&amp;[T]</code>”，<code>T</code>表示包含在数组中的任何类型。这里的“slice”表示的序列条目的子序列(sub-sequence)，就像一个数组或一个向量缓冲区。基于这个目的，一个切片引用的实现是一对值：序列的第一个条目的地址，以及条目的个数。</p>
<p>注意通常我们有变量类型是“切片引用(slice reference)”很少会“切”。一个slice会有类型“<code>[T]</code>”，但这种类型不能作为参数传递给一个函数，因为它的大小在编译时没有定义，函数参数的一个需求是它们在编译期定义大小。因此，我们仅能给一个函数传递<code>切片引用(references to slices)</code>，而不是<code>slices(切片)</code>。这种对象是一个指针和长度的对，因此它们占的内存为常规引用对象的两倍。</p>
<p>切片引用的用法和一个数组用法十分类似。主要实现的不同是，数组上的<code>len</code>函数的调用，可以通过替换为数组长度的常量进行优；而对于切片引用上的<code>len</code>函数，通过访问该对象第二个字段实现。</p>
<p>实际上，前一个章节我们看到跟slices和slice references可以类比：字符串缓冲区，静态字符串。</p>
<p>我们可以建一个相似性表格：</p>
<table>
<thead>
<tr>
<th>undefined-length sequence of bytes</th>
<th>(address of beginning, length in bytes)</th>
<th>(address of beginning, length in bytes, number of bytes used)</th>
</tr>
</thead>
<tbody>
<tr>
<td>String buffer: <code>str</code></td>
<td>Static string: <code>&amp;str</code></td>
<td>Dynamic string: <code>String</code></td>
</tr>
<tr>
<td>Slice of bytes: <code>[ u8 ]</code></td>
<td>Reference to slice of bytes: <code>&amp;[u8]</code></td>
<td>Vector or bytes: <code>Vec&lt;u8&gt;</code></td>
</tr>
</tbody>
</table>
<p>第一列是未定义长度的类型。<code>字符缓冲区(string buffers)</code>，类型是<code>str</code>，是由UTF-8字符的序列推断的未定义长度字节序列。<code>切片(slices)</code>是无符号8位数，它的类型是<code>[u8]</code>，是未定义长度的字节序列。</p>
<p>第二列是第一列的类型引用。<code>静态字符串(static strings)</code>，类型是<code>&amp;str</code>，由两个字段构造：字符缓冲区的内存首地址，以及缓冲区字节的长度。<code>切片引用(references to slices)</code>是无符号8位数，类型是<code>&amp;[u8]</code>，由两个字段构成：无符号8位数的切片的内存首地址，以及切片的长度。</p>
<p>第三列是动态分配的堆分配对象。其中<code>动态字符串(dynamic strings)</code>，它的类型是<code>String</code>，有三个字段构造而成：堆空间分配的字符缓冲区的内存首地址，缓冲区的字节长度，以及被用于缓冲区的字节数。对于无符号8位数的vector，类型是<code>Vec&lt;u8&gt;</code>，也是由三个字段构造而成：对空间分配的无符号8位数的一个切片的内存首地址，切片的长度，以及切片当前使用的字节数。</p>
<p>回到最后一个示例代码，注意<code>min</code>函数的调用没有发生改变。仍然将数组的引用作为参数传递。实际上，这个数组引用会隐式地转换为一个切片引用，使用数组的地址作为切片地址，数组的长度作为切片长度。</p>
<p>因此，程序最后语句传递给函数一个两个字段的结构：首先是包含数字23的数组元素的内存地址，其次是数字8.</p>
<p>使用切片，便利性增加了。因此，现在可以这样写：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">min</span>(arr: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">	<span class="comment">// Let&#x27;s assume &#x27;arr&#x27; is not empty.</span></span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">minimum</span> = arr[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..arr.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> arr[i] &lt; minimum &#123; minimum = arr[i]; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	minimum</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, <span class="title function_ invoke__">min</span>(&amp;[<span class="number">23</span>, <span class="number">17</span>]));</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">min</span>(&amp;<span class="built_in">vec!</span>[<span class="number">55</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>]));</span><br></pre></td></tr></table></figure>
<p>打印：“17 22”。</p>
<p>第一次调用仅传递两个参数，17是它们中最小的。因此，<code>min</code>函数不再局限于8个元素的数组，它可以处理任何长度不为0的数组和切片。</p>
<p>第二次调用展示了<code>min</code>也可以处理vector。传递给该函数的值是一个vector的引用，因为函数的参数类型是“reference to slice”，参数变成了一个切片的引用表示整个vector内容。</p>
<p>因此，我们已经克服了前面提到过得所有缺陷。</p>
<h2 id="Slicing"><a class="header-anchor" href="#Slicing">¶</a>Slicing</h2>
<p>有了切片的便利，渴望一个新的可能的用法。</p>
<p>我们说有一个数组或一个向量，例如<code>vector[23, 17, 12, 16, 15, 2]</code>，以及一个函数以切片(slice)作为参数，例如上面看到的<code>min</code>函数，我们想用该函数处理仅数组或函数的一小段。例如，我们想在数组的第三、第四和第五元素中查找最小值。</p>
<p>我们需要做的是伪造一个切片表示一个数组或向量的片段，不需要整个数组和向量。</p>
<p>为了获得一个数组<code>arr</code>或向量<code>v</code>下标2的条目，分别可以写<code>arr[2]</code>或<code>v[2]</code>。为了获得2到5之间的所有元素，可以写<code>arr[2..5]</code>或<code>v[2..5]</code>。下面是另一种用法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">min</span>(arr: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">	<span class="comment">// Let&#x27;s assume &#x27;arr&#x27; is not empty.</span></span><br><span class="line">	<span class="keyword">let</span> <span class="variable">mu</span> minimum = arr[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..arr.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> arr[i] &lt; minimum &#123; minimum = arr[i]; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	minimum</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">23</span>, <span class="number">17</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">range</span> = <span class="number">2</span>..<span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice_ref</span> = &amp;arr[range];</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">min</span>(slice_ref));</span><br></pre></td></tr></table></figure>
<p>打印“12”，最后4行可以合并：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">min</span>(arr: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">	<span class="comment">// Let&#x27;s assume &#x27;arr&#x27; is not empty.</span></span><br><span class="line">	<span class="keyword">let</span> <span class="variable">mu</span> minimum = arr[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..arr.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> arr[i] &lt; minimum &#123; minimum = arr[i]; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	minimum</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, <span class="title function_ invoke__">min</span>(&amp;[<span class="number">23</span>, <span class="number">17</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">2</span>][<span class="number">2</span>..<span class="number">5</span>]));</span><br></pre></td></tr></table></figure>
<p>这种从一个数组或一个向量获取切片(slice)的过程，称为“切分(slicing)”。</p>
<p>注意，和<code>for</code>循环一样，slicing不包含上限值。所以，范围<code>2..5</code>的记录包含的位置是2,3,4。从0开始计数。</p>
<p>切片操作可以作用在数组和向量中，也可以作用在其它切片：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">55</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">66</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">55</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">66</span>, <span class="number">7</span>,<span class="number">9</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">sr1</span> = &amp;arr[<span class="number">2</span>..<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">sr2</span> = &amp;v[<span class="number">2</span>..<span class="number">5</span>];</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125; &#123;:?&#125; &#123;:?&#125; &#123;:?&#125;&quot;</span>, sr1, sr2, &amp;arr1[<span class="number">1</span>..<span class="number">2</span>], &amp;sr1[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p>结果将输出“<code>[33, 44, 66] [33, 44, 66] [44] 44</code>”。</p>
<p>其中<code>sr1</code>变量是一个切片引用，它引用的是数组<code>arr</code>的第三、第四和第五个元素。</p>
<p><code>sr2</code>是一个类似地切片引用，但它引用的是向量<code>v</code>的条目。</p>
<h2 id="Out-of-range-Slicing"><a class="header-anchor" href="#Out-of-range-Slicing">¶</a>Out-of-range Slicing</h2>
<p>除了常规的切分(slicing)，甚至可以做某些怪异的事情：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">55</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">66</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_r1</span> = <span class="number">4</span>..<span class="number">4</span>; <span class="keyword">let</span> <span class="variable">_a1</span> = &amp;arr[_r1];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_r2</span> = <span class="number">4</span>..<span class="number">3</span>;	<span class="comment">//let _a2 = &amp;arr[_r2];</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">_r3</span> = -<span class="number">3i32</span>..<span class="number">2</span>;	<span class="comment">//let _a3 = &amp;arr[_r3];</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">_r4</span> = <span class="number">3</span>..<span class="number">8</span>;	<span class="comment">//let _a4 = &amp;arr[_r4];</span></span><br></pre></td></tr></table></figure>
<p>该程序中，除了第一行，其它行都是以第一行作为切分数组方式声明一个range。</p>
<p>所有range都是合法的，但不是所有切分操作合法，所以注释掉了某些语句。</p>
<p>第二行是非常正确的，从位置4开始，再从位置4结束。它是一个空slice，空slice是允许的。</p>
<p>第三行用了一个“倒退”的切片。在编译器中它是允许的，但在运行期会导致panic，就和超范围数组访问一样。运行期出现的错误信息，会打印在控制台，<code>slice index that starts at 4 but ends at 3</code>。</p>
<p>第四行使用了类型限制为<code>i32</code>的一个range。它会导致编译错误，因为对于切分(slicing)操作，和序列索引一样，必须是<code>usize</code>类型。</p>
<p>第五行使用的range超出了<code>arr</code>的范围。它编译会通过，但在运行期会带有一个panic信息“<code>index 8 out of range for slice of length 5</code>”。</p>
<p>注意到，在这里，不论是array、vector还是slice，情况都一样。</p>
<h2 id="Mutable-Slicing"><a class="header-anchor" href="#Mutable-Slicing">¶</a>Mutable Slicing</h2>
<p>切片是另一个序列的一段(a portion)，更改切片内容意味着更改原来序列相应的记录。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>];</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">sl_ref</span> = &amp;<span class="keyword">mut</span> arr[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, sl_ref);</span><br><span class="line">	sl_ref[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot; &#123;:?&#125;&quot;</span>, sl_ref);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot; &#123;:?&#125;&quot;</span>, arr);</span><br></pre></td></tr></table></figure>
<p>这会打印“<code>[22, 33] [22, 0] [11, 22, 0, 44]</code>”。</p>
<p>可变变量<code>sl_ref</code>指向一个可变切片(mutable slice)。因此，引用不变，但切片会被改变，意味着这里可以更改数组的记录。</p>
<p>为了获得一个可变切片的引用，基础序列(underlying sequence)必须是可变的。所以要求第一行带<code>mut</code>从句。</p>
<p>更改切片引用意味着什么？切片引用是引用的一种，更改该引用意味着序列片段引用的更改，这里的序列(sequence)可能是切片片段，也可能是基础序列(数组或向量)片段。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>];</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sl_ref</span> = &amp;arr[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, sl_ref);</span><br><span class="line">	sl_ref = &amp;arr[<span class="number">0</span>..<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot; &#123;:?&#125;&quot;</span>, sl_ref);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&quot;</span> &#123;:?&#125;<span class="string">&quot;, arr);</span></span><br></pre></td></tr></table></figure>
<p>这里将打印：“<code>[22, 33] [11] [11, 22, 33, 44]</code>”。</p>
<p>这段程序中，变量<code>arr</code>是一个不可变数组，所以它不会更改。变量<code>sl_ref</code>是指向一个可变切片的可变引用。</p>
<h2 id="Open-Ended-Ranges-and-Slicing"><a class="header-anchor" href="#Open-Ended-Ranges-and-Slicing">¶</a>Open-Ended Ranges and Slicing</h2>
<p>有时希望从给定的<code>n</code>开始获取一个序列的所有条目，或从<code>n</code>到最后的条目，可以这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">n</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">sr1</span> = &amp;arr[<span class="number">0</span>..n];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">sr2</span> = &amp;arr[n..arr.<span class="title function_ invoke__">len</span>()];</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125; &#123;:?&#125;&quot;</span>, sr1, sr2);</span><br></pre></td></tr></table></figure>
<p>结果打印输出：“<code>[11, 22] [33, 44]</code>”。</p>
<p>但有更简单的写法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">n</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">sr1</span> = &amp;arr[..n];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">sr2</span> = &amp;arr[n..];</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125; &#123;:?&#125;&quot;</span>, sr1, sr2);</span><br></pre></td></tr></table></figure>
<p>第三行没有上限，第四行没有下限。实际上，这些Range是不同类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">r1</span>: std::ops::RangeFrom&lt;<span class="type">i32</span>&gt; = <span class="number">3</span>..;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span>: std::ops::RangeTo&lt;<span class="type">i32</span>&gt; = ..<span class="number">12</span>;</span><br><span class="line"><span class="title function_ invoke__">println</span>(<span class="string">&quot;&#123;:?&#125; &#123;:?&#125; &#123;&#125; &#123;&#125;&quot;</span>, r1, r2, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;r1), std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;r2));</span><br></pre></td></tr></table></figure>
<p>结果将打印：“<code>3.. ..12 4 4</code>”。变量<code>r1</code>的类型是<code>RangeFrom</code>，有下限没有上限。变量<code>r2</code>的类型是<code>RangeTo</code>，有上限没有下限。都占4个字节，因为它们仅需要存储<code>i32</code>类型的对象。</p>
<p><code>RangeTo</code>仅用于开口切片(open-ended slicing)，而<code>RangeFrom</code>也可能用于特定的循环中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">3</span>.. &#123;</span><br><span class="line">	<span class="keyword">if</span> i * i &gt; <span class="number">40</span> &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果输出：“<code>3 4 5 6</code>”。</p>
<p>除了上面介绍的两种，还有一种泛型类型的range：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">range</span>: std::ops::RangeFull = ..;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a1</span> = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a2</span> = &amp;a1[range];</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;:?&#125; &#123;:?&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;range), a1, a2);</span><br></pre></td></tr></table></figure>
<p>结果打印：“<code>0 [11, 22, 33, 44] [11, 22, 33, 44]</code>”。</p>
<p>因为<code>RangeFull</code>没有存储东西，所以它的大小是0。它被用于基础序列范围特别大的情形。</p>
<p>下面总结一下容易混淆的概念，</p>
<blockquote>
<p><code>[T; n]</code> is an array of length <code>n</code>, represented as <code>n</code> adjacent <code>T</code> instances.<br>
<code>&amp;[T; n]</code> is purely a reference to that array, represented as a thin pointer to the data.<br>
<code>[T]</code> is a slice, an unsized type; it can only be used through some form of indirection.<br>
<code>&amp;[T]</code>, called a slice, is a sized type. It’s a fat pointer, represented as a pointer to the first item and the length of the slice.</p>
</blockquote>
</div></article><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2023/01/15/rust/beginning/chapter15_Ranges and Slices/';
var disqus_title = 'rust基础入门[15] - Ranges and Slices';
var disqus_url = 'https://galudisu.info/2023/01/15/rust/beginning/chapter15_Ranges and Slices/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>