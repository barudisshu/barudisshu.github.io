<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>rust基础入门[17] - IO and Error Handling</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">rust基础入门[17] - IO and Error Handling</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2023-01-17</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/rust/">rust</a></p><p class="meta-item meta-category"><span class="meta-item-title"></span><i class="icon-bookmark"> </i><a class="category-link" href="/categories/learning/">learning</a></p></div><div class="article-content"><p>本章覆盖有：</p>
<ul>
<li>如何通过命令行参数启动程序</li>
<li>如何给操作系统返回一个状态码</li>
<li>如何获取和设置进程环境变量</li>
<li>如何处理运行时错误</li>
<li>如何在控制台读取键盘输入信息并打印输出</li>
<li>原生类型如何转换为字符串</li>
<li>如何读写二进制文件</li>
<li>如何按行读取文本文件</li>
</ul>
<span id="more"></span>
<h2 id="Command-Line-Arguments"><a class="header-anchor" href="#Command-Line-Arguments">¶</a>Command-Line Arguments</h2>
<p>通过命令行输入的最基本形式是，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">command_line</span>: std::env::Args = std::env::<span class="title function_ invoke__">args</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">argument</span> <span class="keyword">in</span> command_line &#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;[&#123;&#125;]&quot;</span>, argument);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序被编译用来创建一个文件，它通过命令行“./main first second”，它将输出：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[./main]</span><br><span class="line">[first]</span><br><span class="line">[second]</span><br></pre></td></tr></table></figure>
<p>标准库中定义的<code>args</code>返回命令行参数的迭代。这种迭代器的类型是<code>Args</code>，它产生<code>String</code>值。第一个产生的值是程序名，它用路径访问。其它则是程序参数。</p>
<p>任何空白块会被移除，所以如果你想保留，可以用引号，<code>./main &quot; first argument&quot; &quot;second argument &quot;</code>，它将打印：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[./main]</span><br><span class="line">[ first argument]</span><br><span class="line">[second argument ]</span><br></pre></td></tr></table></figure>
<p>该程序可以简化为，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">a</span> <span class="keyword">in</span> std::env::<span class="title function_ invoke__">args</span>() &#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;[&#123;&#125;]&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Process-Return-Code"><a class="header-anchor" href="#Process-Return-Code">¶</a>Process Return Code</h2>
<p>退出程序的最基本形式是返回码，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::process::<span class="title function_ invoke__">exit</span>(<span class="number">107</span>);</span><br></pre></td></tr></table></figure>
<p>当调用<code>exit</code>函数是程序立即退出，并返回启动进程数字107。</p>
<p>在类Unix系统中，可以通过<code>echo $?</code>得到上一次输入内容，要在Windows，则输入<code>echo %errorlevel%</code>。</p>
<h2 id="Environment-Variables"><a class="header-anchor" href="#Environment-Variables">¶</a>Environment Variables</h2>
<p>另外一种最常见的输入/输出的形式是环境变量，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">var</span> <span class="keyword">in</span> std::env::<span class="title function_ invoke__">vars</span>() &#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;[&#123;&#125;]=[&#123;&#125;]&quot;</span>, var.<span class="number">0</span>, var.<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序将给逐行打印输出每个变量。然后，要读或写这些特殊环境变量，可以，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;[&#123;:?&#125;]&quot;</span>, std::env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;abcd&quot;</span>));</span><br><span class="line">std::env::<span class="title function_ invoke__">set_var</span>(<span class="string">&quot;abcd&quot;</span>, <span class="string">&quot;This is the value&quot;</span>);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot; [&#123;:?&#125;]&quot;</span>, std::env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;abcd&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>该程序可能输出：<code>[Err(NotPresent)] [Ok(&quot;This is the value&quot;)]</code>。首先是，环境变量<code>abcd</code>不存在，因此调用<code>var</code>函数时，返回<code>Result</code>类型的一个<code>Err</code>值，这种错误的特定类型是枚举<code>NotPresent</code>。</p>
<p>因为在当前程序中又给这个环境变量设置了值，即使用了<code>set_var</code>函数。所以，下一次获取时，得到内部变量<code>Ok</code>类型的值。</p>
<p>一段类似的程序如下，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,</span><br><span class="line">	<span class="keyword">if</span> std::env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;abcd&quot;</span>).<span class="title function_ invoke__">is_ok</span>() &#123;</span><br><span class="line">		<span class="string">&quot;Already defined&quot;</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="string">&quot;Undefined&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">);</span><br><span class="line">std::env::<span class="title function_ invoke__">set_var</span>(<span class="string">&quot;abcd&quot;</span>, <span class="string">&quot;This is the value&quot;</span>);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;, &#123;&#125;.&quot;</span>, <span class="keyword">match</span> std::env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;abcd&quot;</span>) &#123;</span><br><span class="line">	<span class="title function_ invoke__">Ok</span>(value) =&gt; value,</span><br><span class="line">	<span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">format!</span>(<span class="string">&quot;Still undefined: &#123;&#125;&quot;</span>, err),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>结果将打印：<code>Undefined, This is the value.</code>。</p>
<h2 id="Reading-from-the-Console"><a class="header-anchor" href="#Reading-from-the-Console">¶</a>Reading from the Console</h2>
<p>对于面向命令行的编程，最典型地方式是从控制台输入，读取其输入信息。这种输入可能被另一段进程重定向为读取一个文件的方式。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">line</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> line));</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;[&#123;&#125;]&quot;</span>, line);</span><br></pre></td></tr></table></figure>
<p>当该段程序启动时，它将等待你从键盘的输入，直到回车。例如，键入“Hello”，然后按回车，将会打印，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ok(6)</span><br><span class="line">[Hello</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><code>stdin</code>函数为对当前进程的标准输入流返回一个句柄(handle)。这个句柄上，可以调用<code>read_line</code>函数。它等待标准输入流的行尾(end-of-line)或卷尾(end-of-file)字符的输入，并读取当前输入缓冲区提供的所有字符。这种读取可能失败，因为同时可能会有其它进程在读取。</p>
<p>如果读取成功，读取到的字符丢到一个字符串对象，指派给<code>line</code>变量，作为参数的形式，接收这个可变对象的引用，<code>read_line</code>函数返回一个<code>Ok</code>结果对象，该对象的数据是按字节的数字读取的。注意这个数字是6，所以“Hello&quot;是5个字节，但还包含一个行尾(end-of-line)控制字符。实际上，当<code>line</code>变量被输出后，中括号另起一样输出，因为行尾(end-of-line)字符在最后一行被打印出来了。</p>
<p>如果<code>read_line</code>函数不能从标准输入流读取字符串，它返回一个<code>Err</code>结果对象，以及不会更改变量<code>line</code>的值。</p>
<p>让我们看看标准输入流读取几行时发生了什么，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">text</span> = <span class="built_in">format!</span>(<span class="string">&quot;First: &quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">inp</span> = std::io::<span class="title function_ invoke__">stdin</span>();</span><br><span class="line">inp.<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> text).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">text.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;Second: &quot;</span>);</span><br><span class="line">inp.<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> text).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125; bytes&quot;</span>, text, text.<span class="title function_ invoke__">len</span>());</span><br></pre></td></tr></table></figure>
<p>运行该程序，键入“eè€”，回车，键入“Hello”，回车，将打印，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">First: eè€</span><br><span class="line">Second: Hello</span><br><span class="line">: 28 bytes</span><br></pre></td></tr></table></figure>
<p>首先，注意到字符串输入了三行，因为它包含两个行尾字符串。另外，它包含7字节的ASCII字符串“First: ”，以及8字节的ASCII字符串“Second: ”。“Hello”也是一个ASCII字符串，包含5个字节。另外“eè€”字符串包含6个字节，所以我们一共有7+6+1+8+5+1=28字节。</p>
<p>然后，让我们看看<code>text</code>变量的文本如何构建起来的。注意<code>read_line</code>函数将键入行追加到参数指定的对象上，而不是重写它。<code>text</code>变量由“First: ”初始化。然后，在第三行，首次键入的行被追加到文本中。然后，在第四行，字符串字面量“Second：”追加到变量。最后，在第五行，第二次键入的行再次被追加的内容中。</p>
<p>其三，注意到当函数<code>read_line</code>从缓冲区读取时，它会清空缓冲区，这样再次读取缓冲区时不会重复读取缓冲区的内容。</p>
<p>其四，注意每次调用<code>read_line</code>后，后面都会调用<code>unwrap</code>，但它的返回值可以忽略。</p>
<p>所以这个调用可以省略，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">text</span> = <span class="built_in">format!</span>(<span class="string">&quot;First: &quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">inp</span> = std::io::<span class="title function_ invoke__">stdin</span>();</span><br><span class="line">inp.<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> text);</span><br><span class="line">text.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;Second: &quot;</span>);</span><br><span class="line">inp.<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> text).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125; bytes&quot;</span>, text, text.<span class="title function_ invoke__">len</span>());</span><br></pre></td></tr></table></figure>
<p>然而，当这段程序被编译，编译输出，对于两处调用的<code>read_line</code>，会警告：<code>&quot;unused </code>std::result::Result<code> which must be used&quot;.</code>。它意味着<code>read_line</code>返回个<code>Result</code>的值，以及这个值被忽略或不被使用。Rust中认为忽略<code>Result</code>类型的值是危险的，因为这种类型可能表示一个运行时错误，所以程序逻辑不会统计这种错误。这在生产环境是危险的，但它也不适用于调试代码，因为它隐藏了你需要寻找的错误。</p>
<p>因此，在调试代码时，最好总是在最后加上<code>.unwrap()</code>从句。</p>
<p>在生产环境代码，问题并不是那么简单。</p>
<h2 id="Proper-Runtime-Error-Handling"><a class="header-anchor" href="#Proper-Runtime-Error-Handling">¶</a>Proper Runtime Error Handling</h2>
<p>在真实软件世界，大部分函数调用返回一个<code>Result</code>类型值。这类函数称为“不可靠，fallible”函数，即正常返回<code>Ok</code>，异常情况返回<code>Err</code>。</p>
<p>在C++、Java以及其他面向对象语言中，标准错误的处理技术基于“异常”这一概念，并有<code>throw</code>、<code>try</code>、<code>catch</code>这些关键字。在Rust中没有这些东西；所有错误处理基于<code>Result</code>类型，以及<code>match</code>语句匹配。</p>
<p>假设，典型地，你写一个函数<code>f</code>，要实现它的功能，会调用几个不可靠函数，<code>f1</code>、<code>f2</code>、<code>f3</code>和<code>f4</code>。这些函数可能会返回错误，或者成功结果。希望如果某个函数失败，应该立即将错误信息返回给<code>f</code>函数，若是成功，则传递给下一个函数继续执行。</p>
<p>一个可能的写法是，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f1</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="title function_ invoke__">Err</span>(<span class="built_in">format!</span>(<span class="string">&quot;Err. 1&quot;</span>))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="title function_ invoke__">Ok</span>(x)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f2</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="number">2</span> &#123;</span><br><span class="line">		<span class="title function_ invoke__">Err</span>(<span class="built_in">format!</span>(<span class="string">&quot;Err. 2&quot;</span>))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="title function_ invoke__">Ok</span>(x)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f3</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="number">3</span> &#123;</span><br><span class="line">		<span class="title function_ invoke__">Err</span>(<span class="built_in">format!</span>(<span class="string">&quot;Err. 3&quot;</span>))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="title function_ invoke__">Ok</span>(x)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f4</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="number">4</span> &#123;</span><br><span class="line">		<span class="title function_ invoke__">Err</span>(<span class="built_in">format!</span>(<span class="string">&quot;Err. 4&quot;</span>))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="title function_ invoke__">Ok</span>(x)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">match</span> <span class="title function_ invoke__">f1</span>(x) &#123;</span><br><span class="line">		<span class="title function_ invoke__">Ok</span>(result) =&gt; &#123;</span><br><span class="line">			<span class="keyword">match</span> <span class="title function_ invoke__">f2</span>(result) &#123;</span><br><span class="line">				<span class="title function_ invoke__">Ok</span>(result) =&gt; &#123;</span><br><span class="line">					<span class="keyword">match</span> <span class="title function_ invoke__">f3</span>(result) &#123;</span><br><span class="line">						<span class="title function_ invoke__">Ok</span>(result) =&gt; <span class="title function_ invoke__">f4</span>(result),</span><br><span class="line">						<span class="title function_ invoke__">Err</span>(err_msg) =&gt; <span class="title function_ invoke__">Err</span>(err_msg),</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="title function_ invoke__">Err</span>(err_msg) =&gt; <span class="title function_ invoke__">Err</span>(err_msg),</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="title function_ invoke__">Err</span>(err_msg) =&gt; <span class="title function_ invoke__">Err</span>(err_msg),</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">match</span> <span class="title function_ invoke__">f</span>(<span class="number">2</span>) &#123;</span><br><span class="line">	<span class="title function_ invoke__">Ok</span>(y) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y),</span><br><span class="line">	<span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, e),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">match</span> <span class="title function_ invoke__">f</span>(<span class="number">4</span>) &#123;</span><br><span class="line">	<span class="title function_ invoke__">Ok</span>(y) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y),</span><br><span class="line">	<span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, e),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">match</span> <span class="title function_ invoke__">f</span>(<span class="number">5</span>) &#123;</span><br><span class="line">	<span class="title function_ invoke__">Ok</span>(y) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y),</span><br><span class="line">	<span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, e),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果将打印：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error: Err. 2</span><br><span class="line">Error: Err. 4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>这种写法肯定不方便，可以替换为行内写法，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">result1</span> = <span class="title function_ invoke__">f1</span>(x);</span><br><span class="line">	<span class="keyword">if</span> result1.<span class="title function_ invoke__">is_err</span>() &#123; <span class="keyword">return</span> result1; &#125;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">result2</span> = <span class="title function_ invoke__">f2</span>(result1.<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">	<span class="keyword">if</span> result2.<span class="title function_ invoke__">is_err</span>() &#123; <span class="keyword">return</span> result2; &#125;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">result3</span> = <span class="title function_ invoke__">f3</span>(result2.<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">	<span class="keyword">if</span> result3.<span class="title function_ invoke__">is_err</span>() &#123; <span class="keyword">return</span> result3; &#125;</span><br><span class="line">	<span class="title function_ invoke__">f4</span>(result3.<span class="title function_ invoke__">unwrap</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法是将结果写入临时变量中，结果值通过<code>is_err</code>函数检测。失败则返回，成功则<code>unwrap</code>出真实结果。</p>
<p>下面是另一种等价<code>f</code>的实现，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">	<span class="title function_ invoke__">f4</span>(<span class="title function_ invoke__">f3</span>(<span class="title function_ invoke__">f2</span>(<span class="title function_ invoke__">f1</span>(x)?)?)?)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的问号是一个特定的宏(macro)，诸如“<code>e?</code>”的表达式，如果“<code>e</code>”是泛型类型“<code>Result&lt;T,E&gt;</code>”，宏展开为表达式“<code>match e &#123; Some(v) =&gt; v, _ =&gt; return e &#125;</code>”；相反，如果“<code>e</code>”是泛型类型“<code>Option&lt;T&gt;</code>”，宏展开为表达式“<code>match e &#123; Ok(v) =&gt; v, _ =&gt; return e &#125;</code>”。换言之，这种宏语法将“<code>Some</code>”或“<code>Ok</code>”的参数，进行转换，或返回包含的函数的一个值。</p>
<p>它仅能作用于类型为“<code>Result&lt;T,E&gt;</code>”或“<code>Option&lt;T&gt;</code>”的表达式中，所以也仅能作用于有恰当返回值类型的函数内部。如果闭合函数返回值类型是“<code>Result&lt;T1,E&gt;</code>”，问号宏仅能作用于类型“<code>Result&lt;T2,E&gt;</code>”的表达式，其中“<code>T2</code>”可以和“<code>T1</code>”不同，但“<code>E</code>”必须相同；以及，如果闭合函数返回值类型是“<code>Option&lt;T1&gt;</code>”，问号宏仅能作用于类型“<code>Option&lt;T2&gt;</code>”的表达式。</p>
<p>因此，要构建一个稳健的错误处理模式。每个函数包含对一个不可靠(fallible)函数的调用，应该是一个fallible函数或使用“<code>match</code>”语句处理“<code>Result</code>”结果值。在最先的一种示例代码中，每个不可靠函数的调用，都应该用问号宏来传递错误条件。“<code>main</code>”函数不可能是falliable的，所以在调用链中，应该用“<code>match</code>”语句处理“<code>Result</code>”的值。</p>
<h2 id="Writing-to-the-Console"><a class="header-anchor" href="#Writing-to-the-Console">¶</a>Writing to the Console</h2>
<p>我们一直用“<code>print</code>”或“<code>println</code>”宏来打印消息。然而，你也可以直接用库函数将信息输出到控制台。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line"><span class="comment">//ILLEGAL: std::io::stdout().write(&quot;Hi&quot;).unwrap();</span></span><br><span class="line"><span class="comment">//ILLEGAL: std::io::stdout().write(String::from(&quot;Hi&quot;)).unwrap();</span></span><br><span class="line">std::io::<span class="title function_ invoke__">stdout</span>().<span class="title function_ invoke__">write</span>(<span class="string">&quot;Hello &quot;</span>.<span class="title function_ invoke__">as_bytes</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">std::io::<span class="title function_ invoke__">stdout</span>().<span class="title function_ invoke__">write</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>).<span class="title function_ invoke__">as_bytes</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>
<p>结果将打印：“<code>Hello world</code>”。</p>
<p>“<code>stdout</code>”标准库函数返回一个句柄处理当前进程的标准输出流，“<code>write</code>”可以实现。</p>
<p>“<code>write</code>”函数不能直接打印静态字符串，也不能打印动态字符串，当然数字、常见组合对象也不能。</p>
<p>“<code>write</code>”函数接收一个“<code>&amp;[u8]</code>”类型，它是字节切片的一个引用。这些字节会打印为控制台的UTF-8字符串。所以如果打印的对象不是UTF-8格式的切片字节，首先你需要转换。</p>
<p>为了将静态字符串和动态字符串转换为一个字节切片的引用，你可以使用“<code>as_bytes</code>”函数。该函数返回字符串第一个字节的地址，以及字符串对象的字节数。由于这个字节数早已经包含在字符串对象的头部，所以这个函数极其高效。</p>
<p>最后，注意到“<code>write</code>”函数返回一个“<code>Result</code>”类型值，表示它是一个不可靠函数(fallible function)。如果你确定它不可能是fail，最好调用“<code>unwrap</code>”函数获取其返回值。</p>
<h2 id="Converting-a-Value-to-a-String"><a class="header-anchor" href="#Converting-a-Value-to-a-String">¶</a>Converting a Value to a String</h2>
<p>如果你希望将其它值类型打印为文本，可以使用“<code>to_string</code>”函数，它被定义在所有原生类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">int_str</span>: <span class="type">String</span> = <span class="number">45</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">float_str</span>: <span class="type">String</span> = <span class="number">4.5</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">bool_str</span>: <span class="type">String</span> = <span class="literal">true</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, int_str, float_str, bool_str);</span><br></pre></td></tr></table></figure>
<p>将会打印：“<code>45 4.5 true</code>”。</p>
<p><code>to_string</code>函数指派一个字符串对象，头部会放在栈，内容放在堆。因此，它不是高效的。</p>
<h2 id="File-Input-Output"><a class="header-anchor" href="#File-Input-Output">¶</a>File Input/Output</h2>
<p>Rust提供了对于二进制文件或文本的读写，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = std::fs::File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;data.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">file.<span class="title function_ invoke__">write_all</span>(<span class="string">&quot;eè€&quot;</span>.<span class="title function_ invoke__">as_bytes</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>
<p>第二行调用了<code>create</code>函数，在当前文件目录下，创建一个“data.txt”的文件。该函数是falliable的，如果创建文件成功，它返回刚创建文件的句柄。</p>
<p>最后一行调用了<code>write_all</code>函数，对新创建的文件写入某些字节，注意“eè€”有6个字节，包含行尾结束符。</p>
<p>若要读取刚刚创建的文件“<code>data.txt</code>”，可以，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = std::fs::File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;data.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, contents);</span><br></pre></td></tr></table></figure>
<p>打印输出：“eè€”。</p>
<p>第二行调用了<code>open</code>函数，打开当前目录下的&quot;data.txt&quot;文件。如果文件不存在或不可访问则fail。如果成功，则指派给一个<code>file</code>变量处理该函数。</p>
<p>第4行调用<code>read_to_string</code>函数，将文件内容读取到一个变量，由一个可变对象引用传递。</p>
<p>最后一行将文本内容打印输出。</p>
<p>对于文件拷贝，但是如果文件太大，是不可能将所有东西都塞到一个字符串。它要求读写分段处理。但分段处理并不高效。</p>
<p>下面是一个拷贝文件的高效实现，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">command_line</span>: std::env::Args = std::env::<span class="title function_ invoke__">args</span>();</span><br><span class="line">command_line.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">source</span> = command_line.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">destination</span> = command_line.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file_in</span> = std::fs::File::<span class="title function_ invoke__">open</span>(source).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file_out</span> = std::fs::File::<span class="title function_ invoke__">create</span>(destination).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> = [<span class="number">0u8</span>; <span class="number">4096</span>];</span><br><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">nbytes</span> = file_in.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buffer).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">	file_out.<span class="title function_ invoke__">write</span>(&amp;buffer[..nbytes]).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">	<span class="keyword">if</span> nbytes &lt; buffer.<span class="title function_ invoke__">len</span>() &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该段程序启动时必须传入两个命令行参数。第一个参数是源文件，第二个参数是目标文件。</p>
<p>从第3到第6行，将第一个命令行参数指派给<code>source</code>变量，第二个命令行参数指派给<code>destination</code>变量。</p>
<p>后面两行，将源文件打开，指派给变量<code>file_in</code>，创建文件指派给变量<code>file_out</code>。</p>
<p>然后将一个4096字节缓存指派到栈。</p>
<p>最后，用一个循环，重复地将一个4096byte的chunk，从源文件，写入到目标文件。缓冲区由多少字节，就自动读取多少字节。如果剩余文件片段不够长，读取少于4096的字节，或者0个字节。</p>
<p>读取的字节被塞到了<code>nbytes</code>变量。</p>
<p>对于超过4096字节的大文件，首次迭代读取4096个字节，然后继续迭代读取。对于小于4096字节的文件，迭代一次就可以了。</p>
<p>任何情况下，读取的字节数量，就是写入缓冲的字节数。因此，缓冲区切片由开始位置到读取字节数长度。</p>
<p>如果读取的字节数小于缓冲区长度，循环结束，因为已经达到输入文件的末尾。</p>
<p>注意，这里不用显式关闭文件。只要文件处理结束，文件自动关闭，以及存储和释放所有内部临时缓冲区。</p>
<h2 id="Processing-Text-Files"><a class="header-anchor" href="#Processing-Text-Files">¶</a>Processing Text Files</h2>
<p>对于文本文件的处理，例如我们想知道有多少行，有多少空白，我们可以，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">command_line</span> = std::env::<span class="title function_ invoke__">args</span>();</span><br><span class="line">command_line.<span class="title function_ invoke__">next</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">pathname</span> = command_line.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">counts</span> = <span class="title function_ invoke__">count_lines</span>(&amp;pathname).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;file: &#123;&#125;&quot;</span>, pathname);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;n. of lines: &#123;&#125;&quot;</span>, counts.<span class="number">0</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;n. of empty lines: &#123;&#125;&quot;</span>, counts.<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">count_lines</span>(pathname: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(<span class="type">u32</span>, <span class="type">u32</span>), std::io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">use</span> std::io::BufRead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = std::fs::File::<span class="title function_ invoke__">open</span>(pathname)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = std::io::BufReader::<span class="title function_ invoke__">new</span>(f);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n_lines</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n_empty_lines</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> f.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        n_lines += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> line?.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">len</span>() == <span class="number">0</span> &#123;</span><br><span class="line">            n_empty_lines += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>((n_lines, n_empty_lines))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用到了<code>BufReader</code>。它会将输入放入缓冲区。创建一个“<code>BufReader</code>”对象后，不需要显式使用<code>File</code>对象，新创建的对象被指派给另一个变量<code>f</code>，它会覆盖原来的变量。</p>
<p>当两个计数器<code>n_lines</code>和<code>n_empty_lines</code>被声明以及初始化后。</p>
<p>进入循环体对文件内容进行统计。<code>BufReader</code>类型提供了<code>line</code>函数，它是一个迭代生产者，返回所在行的一个迭代器。注意Rust的迭代器是lazy的；所以，每次迭代，循环体将下一行塞到<code>line</code>变量。</p>
<p>以及文件读取是包含副作用的，所以<code>line</code>的值是一个<code>Result&lt;String, std::io::Error&gt;</code>类型值。因此，带上问号宏<code>?</code>获取它的真是字符串值，或者是返回的一个I/O错误。</p>
<p>循环体内，<code>n_lines</code>统计行数，<code>n_empty_lines</code>将空白和0长度行进行统计，它调用了<code>trim</code>函数。</p>
<p>最后一个语句返回成功值：<code>Ok</code>。它包含两个计数器。</p>
</div></article><nav class="article-nav"><div class="article-nav-prev">🔙<a href="/2023/01/18/rust/beginning/chapter18_Using%20Traits/">rust基础入门[18] - Using Traits</a></div><div class="article-nav-next">🔜<a href="/2023/01/16/rust/beginning/chapter16_Using%20Iterators/">rust基础入门[16] - Using Iterators</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2023/01/17/rust/beginning/chapter17_IO and Error Handling/';
var disqus_title = 'rust基础入门[17] - IO and Error Handling';
var disqus_url = 'https://galudisu.info/2023/01/17/rust/beginning/chapter17_IO and Error Handling/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>