<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>rust基础入门[16] - Using Iterators</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">rust基础入门[16] - Using Iterators</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2023-01-16</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/rust/">rust</a></p><p class="meta-item meta-category"><span class="meta-item-title"></span><i class="icon-bookmark"> </i><a class="category-link" href="/categories/learning/">learning</a></p></div><div class="article-content"><p>本章覆盖有：</p>
<ul>
<li>字符串如何存储字符，为什么不能直接访问</li>
<li>如何用iterators读取字符串字符或字符串字节</li>
<li>如何使用可变iterators修改slices，arrays，vectors</li>
<li>如何使用适配器：<code>filter</code>，<code>map</code>和<code>enumerate</code></li>
<li>如何使用消费者：<code>any</code>，<code>all</code>，<code>count</code>，<code>sum</code>，<code>min</code>，<code>max</code>和<code>collect</code></li>
<li>惰性处理的概念</li>
</ul>
<span id="more"></span>
<h2 id="String-Characters"><a class="header-anchor" href="#String-Characters">¶</a>String Characters</h2>
<p>前面介绍了Rust有静态字符串和动态字符串，它们的编码都是UTF-8。这种编码使用1到6个字节序列表示每个Unicode字符，因此一个字符串不是简单的字符数组，而是表示字符序列的字节的数组。</p>
<p>既然是一个字符串，那么表达式<code>s[0]</code>表示的是什么？它是第一个字符(character)，还是第一个字节(byte)？</p>
<p>都不是，Rust中不允许这种字符串表达式。要获取第一个字节，必须将字符串转换为一个字节切片(a slice of bytes)。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;abc012è€&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..s.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, i, s.<span class="title function_ invoke__">as_bytes</span>()[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果将打印：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0: 97</span><br><span class="line">1: 98</span><br><span class="line">2: 99</span><br><span class="line">3: 48</span><br><span class="line">4: 49</span><br><span class="line">5: 50</span><br><span class="line">6: 195</span><br><span class="line">7: 168</span><br><span class="line">8: 226</span><br><span class="line">9: 130</span><br><span class="line">10: 172</span><br></pre></td></tr></table></figure>
<p>再次重温，这里的变量<code>s</code>的类型是<code>&amp;str</code>的，表示静态字符串。它是Rust中的一种特殊引用，由<code>指针: 长度</code>键值对组成，指向字符串缓冲区。</p>
<p>函数<code>as_bytes</code>将字符串转换为一个不可变的<code>u8</code>切片。这种转换在运行期0消耗，因为字符缓冲区里面的东西不是别的，就是字节序列(sequence of bytes)的。</p>
<p>UTF-8可以表述任何ASCII字符，上述代码中字符<code>a</code>，<code>b</code>，<code>c</code>，<code>0</code>，<code>1</code>，<code>2</code>，打印的值就是ASCII码。</p>
<p>字符<code>è</code>由一对字节表示，包含值195和168。字符<code>€</code>由三个字节表示，包含值226，130和172。</p>
<h2 id="Scanning-a-String"><a class="header-anchor" href="#Scanning-a-String">¶</a>Scanning a String</h2>
<p>要对字符串进行处理，需要对其进行扫描。</p>
<p>类似于字符串“€èe”，我们想要打印第三个字符。首先，我们需要扫描第一个字符的三个字节，因为字符“€”由三个字节序列表示；接着扫描第二个字符“è”，它由两字节序列表示；接着扫描第三个字节，字符“e”仅由一个字节序列表示。</p>
<p>在计算机科学里，有“迭代”(有时叫“游标”)的概念，它解压处理一个序列的当前位置，并在当前位置向前递进。这种操作可以用于字符串的扫描。因此，我们需要一个 <strong>字符串迭代器(string iterator)</strong>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_nth_char</span>(s: &amp;<span class="type">str</span>, <span class="keyword">mut</span> n: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span>: std::<span class="type">str</span>::Chars = s.<span class="title function_ invoke__">chars</span>();</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">item</span>: <span class="type">Option</span>&lt;<span class="type">char</span>&gt; = iter.<span class="title function_ invoke__">next</span>();</span><br><span class="line">        <span class="keyword">match</span> item &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(c) =&gt; <span class="keyword">if</span> n == <span class="number">1</span> &#123; <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c); &#125;,</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123; <span class="keyword">break</span>; &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">        n -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">print_nth_char</span>(<span class="string">&quot;€èe&quot;</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>该函数的作用是，给定一个字符串<code>s</code>，数字<code>n</code>，如果有对应位置，则打印<code>s</code>中位置<code>n</code>的字符，否则不作任何处理。</p>
<p>Rust标准库中提供了字符串迭代类型“Chars”。给定一个字符串“s”，通过<code>s.chars()</code>获得字符串迭代器。</p>
<p>任何迭代器有<code>next</code>函数，该函数范围基础序列当前位置的下一个条目，并向前推进。然而，大部分序列有终点。所以，迭代器返回的下一个值，需要存在有这个位置。考虑到这个原因，Rust迭代器的<code>next</code>返回的是一个<code>Option&lt;T&gt;</code>类型，没有则是<code>None</code>。</p>
<p>使用<code>match</code>语句，用<code>Some</code>触发处理下一个字符，<code>None</code>来退出无尽的循环。</p>
<p>给定一个字符串，打印它的字符编码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_codes</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = s.<span class="title function_ invoke__">chars</span>();</span><br><span class="line">	<span class="keyword">loop</span> &#123;</span><br><span class="line">		<span class="keyword">match</span> iter.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">			<span class="title function_ invoke__">Some</span>(c) =&gt; &#123; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, c, c <span class="keyword">as</span> <span class="type">u32</span>); &#125;,</span><br><span class="line">			<span class="literal">None</span> =&gt; &#123; <span class="keyword">break</span>; &#125;,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">print_codes</span>(<span class="string">&quot;€èe&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>结果输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">€: 8364</span><br><span class="line">è: 232</span><br><span class="line">e: 101</span><br></pre></td></tr></table></figure>
<h2 id="Using-Iterators-in-for-Loops"><a class="header-anchor" href="#Using-Iterators-in-for-Loops">¶</a>Using Iterators in <code>for</code> Loops</h2>
<p>上面的写法有点累赘，因此，应该在语句上进行彻底的简化：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_codes</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, c, c <span class="keyword">as</span> <span class="type">u32</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">print_codes</span>(<span class="string">&quot;€èe&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>for</code>循环后面跟着的<code>in</code>关键后的表达式可以是一个迭代器。</p>
<p>那么迭代器究竟是什么？它不是一个类型，而是一个类型规范。迭代器可以认为是包含<code>next</code>方法，返回<code>Option&lt;T&gt;</code>值的任何表达式。</p>
<p>之前，我们在for循环中用过<code>range</code>。这样，所有有上限值得range都是迭代器了，因为它们有<code>next</code>函数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::ops::Range&lt;u32&gt; 是一个迭代器</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">_v1</span> = (<span class="number">0u32</span>..<span class="number">10</span>).<span class="title function_ invoke__">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::ops::RangeFrom&lt;u32&gt; 是一个迭代器</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">_v2</span> = (<span class="number">5u32</span>..).<span class="title function_ invoke__">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不合法的：std::ops::RangeTo&lt;u32&gt; 不是一个迭代器</span></span><br><span class="line"><span class="comment">// let _v3 = (..8u32).next();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不合法的：std::ops::RangeFull 不是一个迭代器</span></span><br><span class="line"><span class="comment">// let _v4 = (..).next();</span></span><br></pre></td></tr></table></figure>
<p>除了字符之外，也可以对字符串的对应的字节进行迭代：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">byte</span> <span class="keyword">in</span> <span class="string">&quot;€èe&quot;</span>.<span class="title function_ invoke__">bytes</span>() &#123;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, byte);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果打印为：“<code>226 130 172 195 168 101</code>”。前面三个数表示的是<code>€</code>字符；紧接着的两个表示的是<code>è</code>字符；最后一个数表示的是<code>e</code>对应ASCII码。</p>
<p>该段程序可以拆分为：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">string</span>: &amp;<span class="type">str</span> = <span class="string">&quot;€èe&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">string_it</span>: std::<span class="type">str</span>::Bytes = string.<span class="title function_ invoke__">bytes</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">byte</span> <span class="keyword">in</span> string_it &#123;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, byte);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，前一个<code>chars</code>函数的返回值类型是<code>std::str::Chars</code>，这个的<code>bytes</code>函数，返回的值类型是<code>std::str::Bytes</code>。</p>
<p><code>Chars</code>和<code>Bytes</code>都是字符串的迭代类型，以及<code>Chars</code>的<code>next</code>函数返回的是字符串的下一个字符，而对于<code>Bytes</code>的<code>next</code>函数返回的是字符串的下一个字节。</p>
<p>这类函数和<code>as_bytes</code>函数不同，它们返回的是字符串对应其字节上的引用切片。</p>
<p>典型地，对于slice、array或vector也一样。字符串、slice、arrays、vectors都不是迭代器。但，就如字符串包含一个迭代器<code>chars</code>函数一样，slice、array、vector同样包含一个迭代函数<code>iter</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">item_ref</span> <span class="keyword">in</span> (&amp;[<span class="number">11u8</span>, <span class="number">22</span>, <span class="number">33</span>]).<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">	<span class="comment">// *item_ref += 1;</span></span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, *item_ref);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">item_ref</span> <span class="keyword">in</span> [<span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>].<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">	<span class="comment">// *item_ref += 1;</span></span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, *item_ref);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">item_ref</span> <span class="keyword">in</span> <span class="built_in">vec!</span>[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">	<span class="comment">// *item_ref = if *item_ref == &#x27;b&#x27; &#123; &#x27;B&#x27; &#125; else &#123; &#x27;-&#x27; &#125;;</span></span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, *item_ref);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果将打印出：“11 22 33 44 55 66 a b c”。</p>
<p>该程序可以改为，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">slice</span>: &amp;[<span class="type">u8</span>] = &amp;[<span class="number">11u8</span>, <span class="number">22</span>, <span class="number">33</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice_it</span>: std::slice::Iter&lt;<span class="type">u8</span>&gt; = slice.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">item_ref</span> <span class="keyword">in</span> slice_it &#123;</span><br><span class="line">	<span class="comment">// *item_ref += 1;</span></span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, *item_ref);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">3</span>] = [<span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr_it</span>: std::slice::Iter&lt;<span class="type">i32</span>&gt; = arr.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">item_ref</span> <span class="keyword">in</span> arr_it &#123;</span><br><span class="line">	<span class="comment">// *item_ref += 1;</span></span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, *item_ref);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">vec</span>: <span class="type">Vec</span>&lt;<span class="type">char</span>&gt; = <span class="built_in">vec!</span>[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">vec_it</span>: std::slice::Iter&lt;<span class="type">char</span>&gt; = vec.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">item_ref</span> <span class="keyword">in</span> vec_it &#123;</span><br><span class="line">	<span class="comment">// *item_ref = if *item_ref == &#x27;b&#x27; &#123; &#x27;B&#x27; &#125; else &#123; &#x27;-&#x27; &#125;;</span></span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, *item_ref);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>iter</code>函数，作用于类型<code>T</code>的切片的每个元素，或作用于类型<code>T</code>的数组的每个元素，或作用于类型<code>T</code>的向量的每个元素。返回值类型为<code>std::slice::Iter&lt;T&gt;</code>。正如其名，它的返回值类型是一个迭代器类型，因此它可以用于<code>for</code>循环中。</p>
<p>当在类型为<code>T</code>的范围上迭代时，loop变量的类型是<code>T</code>；当在字符迭代器上迭代时，loop内变量的类型是<code>char</code>；相反，当在类型为<code>T</code>的序列上迭代时，它的循环变量是<code>&amp;T</code>类型，即它的引用。</p>
<p>因此，要访问一个序列的上迭代的变量，需要使用反引用符号(<code>*</code>)。</p>
<p>上面代码有三处注释掉的语句，因为是不合法的。事实上，循环体内的变量是不可变的。这种不可变性，是基于<code>slice</code>、<code>arr</code>和<code>vec</code>的不可变声明的变量定义。</p>
<p>前面看到，<code>byte</code>类型的字符串迭代器的创建是使用了<code>bytes</code>函数，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">byte</span> <span class="keyword">in</span> <span class="string">&quot;€èe&quot;</span>.<span class="title function_ invoke__">bytes</span>() &#123;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, byte);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有另外一种对字符串的字节迭代的方法，首先是创建字符串字节的切片引用，即使用<code>as_bytes</code>函数，然后再对其切片引用迭代，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">byte</span> <span class="keyword">in</span> <span class="string">&quot;€èe&quot;</span>.<span class="title function_ invoke__">as_bytes</span>().<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, byte);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Iterations-Without-Mutation"><a class="header-anchor" href="#Iterations-Without-Mutation">¶</a>Iterations Without Mutation</h2>
<p>迭代器的典型用法通常仅用来读取序列。</p>
<p>当要对字符串上的字符进行迭代时，尝试改变它是荒诞的，因为这些字符是由确切存在的不同字节数表示。假设，字符<code>è</code>由两个字节表示，那么<code>e</code>必须由一个字节表示。这在Rust标准库，没法通过字符迭代器改变一个字符的做法(比如<code>e</code>)，来改变另一个字符(比如<code>è</code>)。</p>
<p>当对字符串的字节进行迭代时，要对其进行变更是不安全的，因为新创建的字节可能不是一个有效的UTF-8字符。因此，Rust标准库中也没有办法，通过迭代更改字节的方式，来更改字符串。</p>
<p>当通过<code>chars()</code>迭代器函数对字符串的Range进行迭代时，循环体内的变量值，会使用Range类型的最先初始化时候的值，尽管在循环体内发生了更改，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">r</span> = <span class="string">&quot;abc&quot;</span>.<span class="title function_ invoke__">chars</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> r &#123;</span><br><span class="line">	r = <span class="string">&quot;XY&quot;</span>.<span class="title function_ invoke__">chars</span>();</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;; &quot;</span>, i, r.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将会打印输出：“a x; b X; c X;”。虽然<code>r</code>的的值在循环内部进行了resign，但循环体仍然使用的时初始化时候的值。</p>
<p>在任何迭代中循环变量被初始化，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">r</span> = <span class="number">0</span>..<span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="title class_">mut</span> i <span class="keyword">in</span> r &#123;</span><br><span class="line">	i += <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会打印：“10 11 12 13 14”，因为<code>i</code>在循环体内使用了<code>mut</code>从句定义，但<code>i</code>在下一次迭代仍然会被重新初始化，<code>r</code>的值依然不变。</p>
<p>因此，对于字符串和Range来说，不能通过迭代器的方式来更改它内部序列的条目。</p>
<h2 id="Iterations-with-Mutation"><a class="header-anchor" href="#Iterations-with-Mutation">¶</a>Iterations with Mutation</h2>
<p>但有时候，确实会有这样的需求，要求更改序列的内部条目。前面我看到迭代器不能处理这样的需求，即使是一个可变的迭代器也不能。</p>
<p>实际上，一个可变迭代器，可以或可能通过另一个序列的迭代进行创建，而不是用来改变这个序列。</p>
<p>一个可变迭代器的可能用法是，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">slice1</span> = &amp;[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice2</span> = &amp;[<span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iterator</span> = slice1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">item_ref</span> <span class="keyword">in</span> iterator &#123;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;[&#123;&#125;] &quot;</span>, *item_ref);</span><br><span class="line">&#125;</span><br><span class="line">iterator = slice2.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">item_ref</span> <span class="keyword">in</span> iterator &#123;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;(&#123;&#125;) &quot;</span>, *item_ref);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量<code>iterator</code>首先引用参考了序列<code>slice1</code>，然后是<code>slice2</code>。</p>
<p>一个迭代器类似于一个引用，这里一个可变引用(mutable reference)不等同于一个可变对象(a reference to a mutable object)的引用这个概念。</p>
<p>但如果你想通过一个迭代器来变更这样一个序列，你不能使用常规的迭代器(可变的mutable或不可变的immutable)，即使是，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">slice</span> = &amp;<span class="keyword">mut</span> [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iterator</span> = slice.<span class="title function_ invoke__">iter</span>();</span><br><span class="line">	<span class="keyword">for</span> <span class="title class_">mut</span> item_ref <span class="keyword">in</span> iterator &#123;</span><br><span class="line">		*item_ref += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, slice);</span><br></pre></td></tr></table></figure>
<p>尽管这段程序有好几处用到了<code>mut</code>从句，它在循环语句内产生了一个编译错误，因为<code>*item_ref</code>仍然是不可变的。</p>
<p>所以，你需要另外一种迭代器类型，可变迭代器(<strong><code>mutating iterator</code></strong> )，它必须由一个可变序列进行初始化，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;<span class="keyword">mut</span> [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">iterator</span> = slice.<span class="title function_ invoke__">iter_mut</span>();</span><br><span class="line">	<span class="keyword">for</span> <span class="variable">item_ref</span> <span class="keyword">in</span> iterator &#123;</span><br><span class="line">		*item_ref += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, slice);</span><br></pre></td></tr></table></figure>
<p>结果将打印：“<code>[4, 5, 6]</code>”。</p>
<p>除了删掉一些不必要的<code>mut</code>从句，与上一段代码侧重于相比，此处将<code>iter</code>调用替换为了<code>iter_mut</code>。顾名思义，函数表述为，“get an iterator to read it”，“get an iterator to mutate it”。</p>
<p>你还可以显式指定迭代器的类型，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;<span class="keyword">mut</span> [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">iterator</span>: std::slice::IterMut&lt;<span class="type">i32</span>&gt; = slice.<span class="title function_ invoke__">iter_mut</span>();</span><br><span class="line">	<span class="keyword">for</span> <span class="variable">item_ref</span> <span class="keyword">in</span> iterator &#123;</span><br><span class="line">		*item_ref += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, slice);</span><br></pre></td></tr></table></figure>
<p>其中，<code>iter</code>返回一个<code>Iter&lt;T&gt;</code>的值类型，<code>iter_mut</code>返回一个<code>IterMut&lt;T&gt;</code>的值类型。</p>
<p>回到上个小节关于变更slice、array、vector元素的值的问题，下面是其同样的实现，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">item_ref</span> <span class="keyword">in</span> (&amp;<span class="keyword">mut</span> [<span class="number">11u8</span>, <span class="number">22</span>, <span class="number">33</span>]).<span class="title function_ invoke__">iter_mut</span>() &#123;</span><br><span class="line">	*item_ref += <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, *item_ref);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">item_ref</span> <span class="keyword">in</span> [<span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>].<span class="title function_ invoke__">iter_mut</span>() &#123;</span><br><span class="line">	*item_ref += <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, *item_ref);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">item_ref</span> <span class="keyword">in</span> <span class="built_in">vec!</span>[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].<span class="title function_ invoke__">iter_mut</span>() &#123;</span><br><span class="line">	*item_ref = <span class="keyword">if</span> *item_ref == <span class="string">&#x27;b&#x27;</span> &#123; <span class="string">&#x27;B&#x27;</span> &#125; <span class="keyword">else</span> &#123; <span class="string">&#x27;-&#x27;</span> &#125;;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, *item_ref);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将会打印：“12 13 34 45 56 67 - B -”。</p>
<p>该段程序可以拆分为下面的代码，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">slice</span>: &amp;<span class="keyword">mut</span> [<span class="type">u8</span>] = &amp;<span class="keyword">mut</span> [<span class="number">11u8</span>, <span class="number">22</span>, <span class="number">33</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice_it</span>: std::slice::IterMut&lt;<span class="type">u8</span>&gt; = slice.<span class="title function_ invoke__">iter_mut</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">item_ref</span> <span class="keyword">in</span> slice_it &#123;</span><br><span class="line">	*item_ref += <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, *item_ref);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">3</span>] = [<span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr_it</span>: std::slice::IterMut&lt;<span class="type">i32</span>&gt; = arr.<span class="title function_ invoke__">iter_mut</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">item_ref</span> <span class="keyword">in</span> arr_it &#123;</span><br><span class="line">	*item_ref += <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, *item_ref);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span>: <span class="type">Vec</span>&lt;<span class="type">char</span>&gt; = <span class="built_in">vec!</span>[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">vec_it</span>: std::slice::IterMut&lt;<span class="type">char</span>&gt; = vec.<span class="title function_ invoke__">iter_mut</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">item_ref</span> <span class="keyword">in</span> vec_it &#123;</span><br><span class="line">	*item_ref = <span class="keyword">if</span> *item_ref == <span class="string">&#x27;b&#x27;</span> &#123; <span class="string">&#x27;B&#x27;</span> &#125; <span class="keyword">else</span> &#123; <span class="string">&#x27;-&#x27;</span> &#125;;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, *item_ref);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里仅是将原来注释部分还原，其中，</p>
<ul>
<li><code>slice</code>变量是一个 <strong>mutable</strong> 字节slice reference</li>
<li><code>arr</code>和<code>vec</code>变量是 <strong>mutable</strong></li>
<li>三处的<code>iter</code>函数调用，替换为了<code>iter_mut</code></li>
<li><code>iter_mut</code>返回一个<code>IterMut</code>泛型值类型</li>
<li>循环中由变量<code>item_ref</code>引用的元素发生了变更</li>
</ul>
<p>下面引用一段程序来证明原生数据的变更已经生效，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;<span class="keyword">mut</span> [<span class="number">11u8</span>, <span class="number">22</span>, <span class="number">33</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">item_ref</span> <span class="keyword">in</span> slice.<span class="title function_ invoke__">iter_mut</span>() &#123;</span><br><span class="line">	*item_ref += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, slice);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">item_ref</span> <span class="keyword">in</span> arr.<span class="title function_ invoke__">item_mut</span>() &#123;</span><br><span class="line">	*item_ref += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">item_ref</span> <span class="keyword">in</span> vec.<span class="title function_ invoke__">iter_mut</span>() &#123;</span><br><span class="line">	*item_ref = <span class="keyword">if</span> *item_ref == <span class="string">&#x27;b&#x27;</span> &#123; <span class="string">&#x27;B&#x27;</span> &#125; <span class="keyword">else</span> &#123; <span class="string">&#x27;-&#x27;</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125; &quot;</span>, vec);</span><br></pre></td></tr></table></figure>
<p>将会打印：“<code>[12, 23, 34] [45, 56, 67] ['-', 'B', '-']</code>”。</p>
<p>截止目前为止，接触了四个迭代类型的函数：<code>chars</code>、<code>bytes</code>、<code>iter</code>、<code>iter_mut</code>。这种不获取迭代器，而是返回迭代器的函数，称为“迭代器生成器( <strong>iterator generators</strong> )”。</p>
<h2 id="An-Iterator-Adapter-filter"><a class="header-anchor" href="#An-Iterator-Adapter-filter">¶</a>An Iterator Adapter: filter</h2>
<p>让我们看看迭代器的一些其它用法。</p>
<p>例如，给一个数字数组，如何将所有的负数打印？</p>
<p>一个可能的方法是：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">66</span>, -<span class="number">8</span>, <span class="number">43</span>, <span class="number">19</span>, <span class="number">0</span>, -<span class="number">31</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">n</span> <span class="keyword">in</span> arr.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">	<span class="keyword">if</span> *n &lt; <span class="number">0</span> &#123; <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, n); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果输出：“-8 -31”。</p>
<p>但另一种可能的方式是，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">66</span>, -<span class="number">8</span>, <span class="number">43</span>, <span class="number">19</span>, <span class="number">0</span>, -<span class="number">31</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">n</span> <span class="keyword">in</span> arr.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">filter</span>(|x| **x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>filter</code>函数定义在Rust的标准库中。它作用于一个迭代器，并接收一个闭包作为参数。正如其名，它用于“过滤”被迭代的序列，并丢弃不满足闭包定义条件的元素，剩下满足条件的元素。</p>
<p>闭包在每次迭代的元素时调用，例如，这里每次迭代的元素为<code>x</code>，</p>
<p><code>filter</code>要求闭包参数的返回值类型必须是Boolean。</p>
<p>实际上，<code>filter</code>函数返回一个迭代器(<code>next</code>函数被调用时)，它由闭包返回<code>ture</code>的情况下产生，</p>
<p>我们注意到，我们仅关心是否为负数，即闭包内为<code>x &lt; 0</code>即可，但为什么这里会有两个星号( * )？</p>
<p>首先，一个星号是明确的。因为我们已经说过，<code>iter</code>函数会产生序列元素的引用，而不是元素自身。</p>
<p>另外，<code>filter</code>函数中，它接收迭代器中的一个元素，并将该元素的引用传递给闭包，所以需要另一个星号( * )。因此<code>x</code>变成了引用的引用，要添加两个星号才能获取其表示的值。</p>
<p>我们说过<code>filter</code>函数返回另外一个迭代器。所以我们可以在<code>for</code>循环中使用，并做迭代实现。</p>
<p>这样一来，<code>filter</code>通过一个迭代器，返回另一个迭代器，它担当了一个“转换器transforms”的角色。这种“transformers”通常称为“迭代适配器(iterator adapters)”。术语“adapter”由电连接器得名：如果一个插头不能适合插座，使用一个适配嫁接。</p>
<h2 id="The-map-Iterator-Adapter"><a class="header-anchor" href="#The-map-Iterator-Adapter">¶</a>The map Iterator Adapter</h2>
<p><code>map</code>函数相当于一个映射，即<code>x:T -&gt; y:T</code>，它被定义在标准库中，<code>map</code>函数不会删除元素，而是将里面的元素进行了转换，区别于<code>filter</code>函数，<code>filter</code>元素传递给闭包参数的值是一个引用，<code>map</code>传递的是一个值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">66</span>, -<span class="number">8</span>, <span class="number">43</span>, <span class="number">19</span>, <span class="number">0</span>, -<span class="number">31</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">n</span> <span class="keyword">in</span> arr.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(&#123;x&#125; *x * <span class="number">2</span>) &#123;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="The-enumerate-Iterator-Adapter"><a class="header-anchor" href="#The-enumerate-Iterator-Adapter">¶</a>The enumerate Iterator Adapter</h2>
<p>要对一个序列进行迭代，最传统做法是，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..arr.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;, &quot;</span>, i, arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用迭代器，可以避免出现计数，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arrlet</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">ch</span> <span class="keyword">in</span> arr.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;, &quot;</span>, ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但如果你想在新学习基础上对其进行计数，你可以，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (i, ch) <span class="keyword">in</span> arr.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;, &quot;</span>, i, *ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第二行，循环变量实际上是一个tuple，第一次迭代时，<code>i</code>的值是0，<code>ch</code>是第一个字符数组的地址，每次迭代时，<code>i</code>和<code>ch</code>都会递增。</p>
<p><code>enumerate</code>函数接收一个迭代器，并返回另外一个迭代器。该返回的迭代器，在每次迭代时都返回一个类型为<code>(usize, &amp;char)</code>的tuple，第一个字段是一个计数器，第二个字段是原来迭代器元素的一份拷贝。</p>
<h2 id="An-Iterator-Consumer-any"><a class="header-anchor" href="#An-Iterator-Consumer-any">¶</a>An Iterator Consumer: <code>any</code></h2>
<p>给定一个字符串，如何判断是否包含某个字符？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ch</span> = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contains</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">	<span class="keyword">if</span> c == ch &#123;</span><br><span class="line">		contains = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;\&quot;&#123;&#125;\&quot; &#123;&#125; &#x27;&#123;&#125;&#x27;.&quot;</span>, s,</span><br><span class="line">	<span class="keyword">if</span> contains &#123;</span><br><span class="line">		<span class="string">&quot;contains&quot;</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="string">&quot;does not contain&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	ch</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>结果将打印：“Hello world!” does not contain ‘R’.</p>
<p>这里进行了字符大小写的比较。如果换为<code>R</code>，则会输出第二种情况，你可以替换为闭包实现，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ch</span> = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;\&quot;&#123;&#125;\&quot; &#123;&#125; &#x27;&#123;&#125;&#x27;.&quot;</span>,</span><br><span class="line">	s,</span><br><span class="line">	<span class="keyword">if</span> s.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">any</span>(|c| c == ch) &#123;</span><br><span class="line">		<span class="string">&quot;contains&quot;</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="string">&quot;does not contain&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	ch);</span><br></pre></td></tr></table></figure>
<p>闭包的好处是替换掉原来使用自定义变量的做法；这个变量替换为了表达式<code>s.chars().any(|c| c == ch)</code>的实现。</p>
<p>函数<code>any()</code>定义在Rust标准库中，它作用在迭代器上。它的目的是确定迭代器中的任意元素是否满足布尔函数(又名“预设”predicate)。</p>
<p><code>any()</code>函数必须是作用在一个迭代器上的，以及必须接收一个闭包参数。闭包内的操作，对迭代内的每个元素进行处理，当某个处理到某个元素返回<code>true</code>时，结果立即返回<code>true</code>，否则所以元素的处理结果为<code>false</code>时，函数返回<code>false</code>。</p>
<p>因此，函数名<code>any()</code>，顾名思义就是“任意的”满足条件。</p>
<p>前面的一个判断是否包含负数的例子，可以用<code>any()</code>函数来处理，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> t_bang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> t_bang::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">45</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr_iter</span> = arr.<span class="title function_ invoke__">iter</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr_any</span> = arr_iter.<span class="title function_ invoke__">any</span>(|n| *n &lt; <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, t!(arr_iter));</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, arr_any);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了代码清晰，你可以给闭包的类型加上注解，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, [<span class="number">45</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>].<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">any</span>(|n: &amp;<span class="type">i32</span>| <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123; *n &lt; <span class="number">0</span> &#125;));</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, [<span class="number">45</span>, <span class="number">8</span>, -<span class="number">2</span>, <span class="number">6</span>].<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">any</span>(|n: &amp;<span class="type">i32</span>| <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123; *n &lt; <span class="number">0</span> &#125;));</span><br></pre></td></tr></table></figure>
<p>前面说过，迭代器的迭代变量是一个reference，所以这里不能省略<code>&amp;</code>符号，否则有类型错误。</p>
<p>前面介绍了几种迭代概念，</p>
<ul>
<li>函数作用在非迭代器，生成一个迭代器的，称为“迭代生成器(iterator generator)”</li>
<li>函数作用在一个迭代器，返回另一个迭代器的，称为“迭代适配器(iterator adapter)”</li>
<li>函数作用在一个迭代器，但不返回迭代器的，称为“迭代消费者(iterator consumer)”</li>
</ul>
<p>迭代器 “ <strong>消费者</strong> ”，就是消费掉了数据，而不是“ <strong>适配</strong> ”数据。除了这里的<code>any()</code>消费者，下面再介绍几种常见的。</p>
<h2 id="The-all-Iterator-Consumer"><a class="header-anchor" href="#The-all-Iterator-Consumer">¶</a>The <code>all</code> Iterator Consumer</h2>
<p><code>any()</code>就是“任意的”，至少有一个满足条件；对应就有<code>all()</code>，“所有的”，要求全部满足条件；</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, [<span class="number">45</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>].<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">all</span>(|n: &amp;<span class="type">i32</span>| <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123; *n &lt; <span class="number">0</span> &#125;));</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, [<span class="number">45</span>, <span class="number">8</span>, -<span class="number">2</span>, <span class="number">6</span>].<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">all</span>(|n: &amp;<span class="type">i32</span>| <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123; *n &lt; <span class="number">0</span> &#125;));</span><br></pre></td></tr></table></figure>
<h2 id="The-count-Iterator-Consumer"><a class="header-anchor" href="#The-count-Iterator-Consumer">¶</a>The <code>count</code> Iterator Consumer</h2>
<p>迭代计数器<code>count()</code>和<code>enumerate()</code>概念类似，只不过<code>count()</code>是个消费者，不会生成另一个迭代器，内部元素不会发生拷贝。</p>
<p>例如，你想统计一个slice，array，vector的长度，你可能会使用<code>len</code>函数。但要想知道一个字符串里面有多少个字符，你就必须扫描这个字符串，因为组成字符串的字符不会保存，除非你将它存储下来。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;€èe&quot;</span>;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">count</span>(), s.<span class="title function_ invoke__">len</span>());</span><br></pre></td></tr></table></figure>
<p><code>count()</code>不接收任何参数，以及它的返回值类型总是<code>usize</code>。</p>
<h2 id="The-sum-Iterator-Consumer"><a class="header-anchor" href="#The-sum-Iterator-Consumer">¶</a>The <code>sum</code> Iterator Consumer</h2>
<p><code>sum()</code>函数用于迭代添加，它也是个迭代消费者，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, [<span class="number">45</span>, <span class="number">8</span>, -<span class="number">2</span>, <span class="number">6</span>].<span class="title function_ invoke__">iter</span>().sum::&lt;<span class="type">i32</span>&gt;());</span><br></pre></td></tr></table></figure>
<p>这里可以指定它的类型参数<code>&lt;i32&gt;</code>，这个类型参数是可选的，可选的前提条件是：迭代器的元素类型需要是可加的，这样才能被类型推断处理；例如<code>[3.4].iter().sum::&lt;f64&gt;()</code>是合法的，但<code>[true].iter().sum::&lt;bool&gt;()</code>是不合法的，因为布尔值无法满足加法。</p>
<h2 id="The-min-and-max-Iterator-Consumers"><a class="header-anchor" href="#The-min-and-max-Iterator-Consumers">¶</a>The <code>min</code> and <code>max</code> Iterator Consumers</h2>
<p><code>min()</code>和<code>max()</code>函数用于查找最小值、最大值，它的返回类型是<code>Option</code>，其中<code>Some</code>值的作用在非空序列，<code>None</code>时则表示序列是空的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">45</span>, <span class="number">8</span>, -<span class="number">2</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">match</span> arr.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">min</span>() &#123;</span><br><span class="line">	<span class="title function_ invoke__">Some</span>(n) =&gt; <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, n),</span><br><span class="line">	_ =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">match</span> arr.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">max</span>() &#123;</span><br><span class="line">	<span class="title function_ invoke__">Some</span>(n) =&gt; <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, n),</span><br><span class="line">	_ =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">match</span> [<span class="number">0</span>; <span class="number">0</span>].<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">min</span>() &#123;</span><br><span class="line">	<span class="title function_ invoke__">Some</span>(n) =&gt; <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, n),</span><br><span class="line">	_ =&gt; <span class="built_in">print!</span>(<span class="string">&quot;---&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将会打印： -2 45 —.</p>
<p><code>min()</code>和<code>max()</code>也可作用在非数字的迭代对象上，但要满足可比较性(即该类型要有<code>std::cmp</code>)，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;brave&quot;</span>, <span class="string">&quot;new&quot;</span>, <span class="string">&quot;world&quot;</span>];</span><br><span class="line"><span class="keyword">match</span> arr.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">min</span>() &#123;</span><br><span class="line">	<span class="title function_ invoke__">Some</span>(n) =&gt; <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, n),</span><br><span class="line">	_ =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">match</span> arr.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">max</span>() &#123;</span><br><span class="line">	<span class="title function_ invoke__">Some</span>(n) =&gt; <span class="built_in">print!</span>(<span class="string">&quot;&#123;] &quot;</span>, n),</span><br><span class="line">	_ =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="The-collect-Consumer"><a class="header-anchor" href="#The-collect-Consumer">¶</a>The <code>collect</code> Consumer</h2>
<p>像<code>any()</code>、<code>all()</code>、<code>count()</code>、<code>sum()</code>、<code>min()</code>和<code>max()</code>这些迭代消费者返回都是简单一个值，但如果我们想将所有处理的元素收集到一个Vector呢，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">36</span>, <span class="number">1</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = arr.<span class="title function_ invoke__">iter</span>().collect::&lt;<span class="type">Vec</span>&lt;&amp;<span class="type">i32</span>&gt;&gt;();</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v);</span><br></pre></td></tr></table></figure>
<p>结果将打印：“<code>[36, 1, 15, 9, 4]</code>”.</p>
<p>这里的类型参数是必须的，不过可以改为这样写，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">36</span>, <span class="number">1</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = arr.<span class="title function_ invoke__">iter</span>().collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v);</span><br></pre></td></tr></table></figure>
<p>又或者这样，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">36</span>, <span class="number">1</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;_&gt; = arr.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v);</span><br></pre></td></tr></table></figure>
<p>同样，字符和字节也可以收集到一个Vector，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s.<span class="title function_ invoke__">chars</span>().collect::&lt;<span class="type">String</span>&gt;());</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s.<span class="title function_ invoke__">chars</span>().collect::&lt;<span class="type">Vec</span>&lt;<span class="type">char</span>&gt;&gt;());</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s.<span class="title function_ invoke__">bytes</span>().collect::&lt;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;&gt;());</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s.<span class="title function_ invoke__">as_bytes</span>().<span class="title function_ invoke__">iter</span>().collect::&lt;<span class="type">Vec</span>&lt;&amp;<span class="type">u8</span>&gt;&gt;());</span><br></pre></td></tr></table></figure>
<p>将会打印，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;Hello&quot;</span><br><span class="line">[&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span><br><span class="line">[72, 101, 108, 108, 111]</span><br><span class="line">[72, 101, 108, 108, 111]</span><br></pre></td></tr></table></figure>
<p>注意<code>collect()</code>函数不能用于静态字符串、静态数组、或静态切片，因为它要求运行期内存分配。</p>
<h2 id="Iterator-Chains"><a class="header-anchor" href="#Iterator-Chains">¶</a>Iterator Chains</h2>
<p>假设你想要将一个数组里面的负数，平方后收集到另一个vector中，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">66</span>, -<span class="number">8</span>, <span class="number">43</span>, <span class="number">19</span>, <span class="number">0</span>, -<span class="number">31</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..arr.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">	<span class="keyword">if</span> arr[i] &gt; <span class="number">0</span> &#123; v.<span class="title function_ invoke__">push</span>(arr[i] * <span class="number">2</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v);</span><br></pre></td></tr></table></figure>
<p>打印输出：<code>[132, 86, 38]</code>.</p>
<p>一个等效实现是，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">66</span>, -<span class="number">8</span>, <span class="number">43</span>, <span class="number">19</span>, <span class="number">0</span>, -<span class="number">31</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">n</span> <span class="keyword">in</span> arr.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">	<span class="keyword">if</span> *n &gt; <span class="number">0</span> &#123; v.<span class="title function_ invoke__">push</span>(*n * <span class="number">2</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v);</span><br></pre></td></tr></table></figure>
<p>又或者，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">66</span>, -<span class="number">8</span>, <span class="number">43</span>, <span class="number">19</span>, <span class="number">0</span>, -<span class="number">31</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">n</span> <span class="keyword">in</span> arr</span><br><span class="line">	.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">	.<span class="title function_ invoke__">filter</span>(|x| **x &gt; <span class="number">0</span>)</span><br><span class="line">	.<span class="title function_ invoke__">map</span>(|x| *x * <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">	v.<span class="title function_ invoke__">push</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v);</span><br></pre></td></tr></table></figure>
<p>再或，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">66</span>, -<span class="number">8</span>, <span class="number">43</span>, <span class="number">19</span>, <span class="number">0</span>, -<span class="number">31</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">n</span> <span class="keyword">in</span> arr</span><br><span class="line">	.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">	.<span class="title function_ invoke__">filter</span>(|x| **x &gt; <span class="number">0</span>)</span><br><span class="line">	.<span class="title function_ invoke__">map</span>(|x| *x * <span class="number">2</span>)</span><br><span class="line">	.collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v);</span><br></pre></td></tr></table></figure>
<p>最后一个版本展示的编程模式是函数式语言的典型：迭代链(iterator chain)。</p>
<p>迭代链由几个概念属于组成，<strong>迭代生成器(iterator generator)</strong> + <strong>迭代适配器(iterator adapter)</strong> + <strong>迭代消费者(iterator consumer)</strong> 。</p>
<h2 id="Iterators-Are-“Lazy”"><a class="header-anchor" href="#Iterators-Are-“Lazy”">¶</a>Iterators Are “Lazy”</h2>
<p>我们给最后一个例子加一些调试信息打印出来，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = [<span class="number">66</span>, -<span class="number">8</span>, <span class="number">43</span>, <span class="number">19</span>, <span class="number">0</span>, -<span class="number">31</span>]</span><br><span class="line">	.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">	.<span class="title function_ invoke__">filter</span>(|x| &#123; <span class="built_in">print!</span>(<span class="string">&quot;F&#123;&#125; &quot;</span>, x); **x &gt; <span class="number">0</span> &#125;)</span><br><span class="line">	.<span class="title function_ invoke__">map</span>(|x| &#123; <span class="built_in">print!</span>(<span class="string">&quot;M&#123;&#125; &quot;</span>, x); *x * <span class="number">2</span> &#125;)</span><br><span class="line">	.collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v);</span><br></pre></td></tr></table></figure>
<p>将打印：<code>F66 M66 F-8 F43 M43 F19 M19 F0 F-31 [132, 86, 38]</code>。</p>
<p>运行时的操作如下，</p>
<p>首先调用了<code>iter()</code>准备一个迭代器，但它没有访问该数组。我们给该迭代器命名为“I”。</p>
<p><code>filter()</code>的调用准备了一个迭代器，但它没有处理数据。我们给迭代器命名为“F”。</p>
<p><code>map()</code>的调用准备了一个迭代器，但它没有处理数据。我们给该迭代器命名为“M”。</p>
<p><code>collect()</code>的调用，向“M”请求一个元素；“M”向“F”请求一个元素；“F”向“I”请求一个元素；“I”拿到来自数组的数66，传给“F”，打印这个数，检查是否是正数，然后传递给“M”，打印，平方，再传递给<code>collect()</code>，最后推送到Vector。</p>
<p>接着，<code>collect()</code>接收到<code>Some</code>，继续向“M”请求另一个元素，重复这个操作，知道元素-8到达“F”时，由于是负数被过滤。所有“M”没有打印出结果。停留在“F”，因为“F”接收到<code>Some</code>，继续问“I”索取另一个元素。</p>
<p>该算法处理，会直到数组完成。当“I”不能在数组找到其它元素时，将一个<code>None</code>发给“F”告知它没有更多元素了。“F”收到<code>None</code>后，再将其传递给“M”，“M”再发给<code>collect()</code>，整个语句结束。</p>
<p>如果省略掉迭代器消费者，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">66</span>, -<span class="number">8</span>, <span class="number">43</span>, <span class="number">19</span>, <span class="number">0</span>, -<span class="number">31</span>]</span><br><span class="line">	.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">	.<span class="title function_ invoke__">filter</span>(|x| &#123; <span class="built_in">print!</span>(<span class="string">&quot;F&#123;&#125; &quot;</span>, x); **x &gt; <span class="number">0</span> &#125;)</span><br><span class="line">	.<span class="title function_ invoke__">map</span>(|x| &#123; <span class="built_in">print!</span>(<span class="string">&quot;M&#123;&#125; &quot;</span>, x); *x * <span class="number">2</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>它不会输出任何消息，因为它什么也没有做，编译器只会报告，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning unused `std::iter::Map` witch must be used: iterator adapters are lazy and do nothing unless consumed.</span><br></pre></td></tr></table></figure>
<p>“lazy”在计算机科学中是“惰性求值”的概念，以为这尽可能迟的处理。迭代适配器是惰性的，它仅在其它函数向其请求元素时才真正调用：即需要消费者。</p>
<p>如果没有数据接收器，就没有数据访问(If there is no data sink, there is no data access)。</p>
</div></article><nav class="article-nav"><div class="article-nav-prev"><a href="/2023/01/17/rust/beginning/chapter17_IO%20and%20Error%20Handling/">rust基础入门[17] - IO and Error Handling</a></div><div class="article-nav-next"><a href="/2023/01/15/rust/beginning/chapter15_Ranges%20and%20Slices/">rust基础入门[15] - Ranges and Slices</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2023/01/16/rust/beginning/chapter16_Using Iterators/';
var disqus_title = 'rust基础入门[16] - Using Iterators';
var disqus_url = 'https://galudisu.info/2023/01/16/rust/beginning/chapter16_Using Iterators/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>