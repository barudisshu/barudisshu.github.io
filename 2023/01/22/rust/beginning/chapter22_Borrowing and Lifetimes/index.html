<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>rust基础入门[22] - Borrowing and Lifetimes</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">rust基础入门[22] - Borrowing and Lifetimes</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2023-01-22</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/rust/">rust</a></p><p class="meta-item meta-category"><span class="meta-item-title"></span><i class="icon-bookmark"> </i><a class="category-link" href="/categories/learning/">learning</a></p></div><div class="article-content"><p>本章覆盖有：</p>
<ul>
<li>“租借，borrowing”和“生命周期，lifetime”的概念</li>
<li>困扰系统软件的租借典型错误是哪些</li>
<li>如何通过租借checker，Rust的严格语法来避免这种典型错误</li>
<li>如何通过插入语句块来约束租借的作用域(scope)</li>
<li>为什么函数返回的引用需要生命周期指示符(specifiers)</li>
<li>如何给函数使用生命周期指示符(lifetime specifiers)，它们表示什么</li>
<li>租借checker的任务是什么</li>
</ul>
<span id="more"></span>
<h2 id="Ownership-and-Borrowing"><a class="header-anchor" href="#Ownership-and-Borrowing">¶</a>Ownership and Borrowing</h2>
<p>上一章介绍到，当将变量<code>a</code>赋值给<code>b</code>时，会有两种情况：如果它们类型是可拷贝的(copyable)，它就实现了<code>Copy</code>特质(当然也肯定实现了<code>Clone</code>)；如果它们的类型不可拷贝(non-copyable)，则没有实现<code>Copy</code>(<code>Clone</code>可能实现，也可能没有)。</p>
<p>第一种情况，用到拷贝语义(copy semantics)。意味着，在赋值过程中，当<code>a</code>保留它对象的所有权(ownership)，一个新的对象被创建，初始化值等同于<code>a</code>的值，以及<code>b</code>获得这些新的对象的所有权。当<code>a</code>和<code>b</code>离开它的作用域时，它们拥有的对象被销毁(又叫dropped)。</p>
<p>相反，第二种情况，用到移动语义(move semantics)。意味着，在赋值过程中，<code>a</code>将它的所有权移交给了<code>b</code>，不会有新对象的创建，<code>a</code>不再可访问。当<code>b</code>离开它的作用域时，它拥有的对象被销毁。当<code>a</code>离开它的作用域，不发生任何事情。</p>
<p>所有这些保证了合适的内存管理，只要没有引用被使用到。</p>
<p>但看看这个代码，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">n</span> = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ref_to_n</span> = &amp;n;</span><br></pre></td></tr></table></figure>
<p>第一条语句后，变量<code>n</code>拥有一个数。</p>
<p>第二条语句后，变量<code>ref_to_n</code>拥有一个引用，该引用指向同一个由<code>n</code>引用的数。它是一个所有权吗？</p>
<p>它不能作为一个所有权，因为这个数早已经由<code>n</code>所拥有，如果同时被这个引用所“拥有”，它将会被销毁两次。因此，类似这样的引用不能“拥有”对象。</p>
<p>表达式<code>n</code>和<code>*ref_to_n</code>指向同一个对象，但仅<code>n</code>拥有这个对象。变量<code>ref_to_n</code>可以访问这个对象，但不是“拥有”这个对象。这种概念称为<strong>租借，borrowing</strong>。我们说<code>ref_to_n</code>借了<code>n</code>拥有的数。这种租借，开始于引用指向该对象，结束于该对象的销毁。</p>
<p>关于可变性(mutability)，有两种类型的borrowing：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n</span> = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ref1_to_n</span> = &amp;<span class="keyword">mut</span> n;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ref2_to_n</span> = &amp;n;</span><br></pre></td></tr></table></figure>
<p>这段程序中，<code>ref1_to_n</code>将<code>n</code>拥有的值，租借为 <strong>mutably</strong> 的值，以及<code>ref2_to_n</code>租借为 <strong>immutably</strong> 的值。第一种是可变租借(mutable borrowing)，第二种是不可变租借(immutable borrowing)。可变租借仅能从可变变量中获取。</p>
<h2 id="Object-Lifetimes"><a class="header-anchor" href="#Object-Lifetimes">¶</a>Object Lifetimes</h2>
<p>注意到，“作用域，scope”的概念作用于编译期的变量，而不是运行期的对象。对应运行期对象的概念叫“生命周期，lifetime”。在Rust中，一个对象的生命周期，指的是一系列执行指令，从执行指令的创建，到执行指令的销毁。在该时间段，该对象叫做“存活，to live，to be alive”。</p>
<p>当然，作用域和生命周期存在一定关系，但它们不是同一个概念。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>;</span><br><span class="line">a = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br></pre></td></tr></table></figure>
<p>该程序中，变量<code>a</code>的作用域开始于第一行，而<code>a</code>拥有的对象的生命周期开始于第二行。通常认为，变量<code>a</code>的作用域开始于它的声明，对象的生命周期开始于该对象接收一个值。</p>
<p>即使是变量作用域(scope)的结束，跟对象生命周期(lifetime)的结束也不是同时发生的，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="string">&quot;Hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> = a;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;, &quot;</span>, b);</span><br><span class="line">a = <span class="string">&quot;world&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, a);</span><br><span class="line">b = a;</span><br></pre></td></tr></table></figure>
<p>结果将输出：“Hello, world!”。</p>
<p>在第一条语句，变量<code>a</code>被声明以及初始化。因此<code>a</code>的作用域开始，接着<code>a</code>拥有的对象被创建，<code>a</code>的生命周期开始。</p>
<p>在第二条语句，变量<code>b</code>被声明，由<code>a</code>移动对象进行初始化。因此，<code>b</code>的作用域开始，<code>a</code>的作用域被悬挂(suspended)，因为它被移动了，所以它不可再被访问。<code>b</code>拥有的对象不用创建，因为它就是先前创建的对象。</p>
<p>在第三条语句，<code>b</code>被访问。</p>
<p>在第四条语句，变量<code>a</code>通过<code>new</code>构造器，指派新的值。这里，<code>a</code>恢复(resume)它的作用域(scope)，因为它的作用域还没有结束。一个新的对象被创建，该对象的生命周期开始。前面由于变量<code>a</code>被“移动”了，所以它不“拥有”任何对象。所以这里的语句类似于一个初始化。</p>
<p>在第五条语句，<code>a</code>(拥有对象)可被访问了。</p>
<p>在第六条语句，<code>a</code>再次被移动到<code>b</code>，它的作用域再次被悬挂(suspended)。相反，<code>b</code>一直是活动的(active)，它拥有的对象由移动的<code>a</code>替换，因此，原先的对象在这里被销毁，以及生命周期结束。如果该对象实现了<code>Drop</code>，在这里，它的<code>drop</code>方法会被调用。</p>
<p>最后，<code>b</code>和<code>a</code>陆续退出它们的作用域。变量<code>b</code>拥有一个对象，该对象被销毁，以及结束它的生命周期。相反，变量<code>a</code>被“移动”了，不再拥有任何对象，也就不会有销毁对象的发生。</p>
<h2 id="Errors-Regarding-Borrowing"><a class="header-anchor" href="#Errors-Regarding-Borrowing">¶</a>Errors Regarding Borrowing</h2>
<p>C和C++程序编写总是被各种错误困扰，而Rust则通过设计来避免这一类问题。Rust的一种常见错误是“use after move”，前面介绍过。另一种错误如下，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">ref_to_n</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = <span class="number">12</span>;</span><br><span class="line">    ref_to_n = &amp;n;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, *ref_to_n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, *ref_to_n);</span><br></pre></td></tr></table></figure>
<p>首先，变量<code>ref_to_n</code>被声明，但没有被初始化。然后，在语句块内，可变变量<code>n</code>被声明并初始化，它分配一个数在栈上，值为12。</p>
<p>然后，原先的变量，用一个指向<code>n</code>的引用进行初始化，它租借(borrow)了这个对象。</p>
<p>接着，变量<code>ref_to_n</code>指向的对象，即值为12的对象，打印输出。</p>
<p>接着，语句块结束，内部变量<code>n</code>结束了它的作用域，它的对象被销毁。</p>
<p>接着，变量<code>ref_to_n</code>指向的对象再次被打印。但该对象原先被<code>n</code>“拥有”，它现在不存在了！</p>
<p>幸运的是，Rust编译器拒绝该代码，产生错误信息“<code>n</code> does not live long enough”。该消息表示，变量<code>n</code>死了(dying)，但仍然有指向它“拥有”的对象的引用，它应该活更长一些；至少应该跟租借它对象的租借方一样长。</p>
<p>顺便，C或C++对应的代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>* ref_to_n;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">12</span>;</span><br><span class="line">        ref_to_n &amp;n;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *ref_to_n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *ref_to_n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段程序可被C和C++编译器接受。结果会打印“12”，之后的行为会变得不可预测。</p>
<p>这类程序错误，我们称之为“use after drop”。</p>
<p>有另一种可避免的Rust错误，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ref_to_first</span> = &amp;v[<span class="number">0</span>];</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">13</span>);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, ref_to_first);</span><br></pre></td></tr></table></figure>
<p>对应的C语言实现是，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>* v = <span class="built_in">malloc</span>(<span class="number">1</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>));</span><br><span class="line">    v[<span class="number">0</span>] = <span class="number">12</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ref_to_first = &amp;v[<span class="number">0</span>];</span><br><span class="line">    v = <span class="built_in">realloc</span>(v, <span class="number">2</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>));</span><br><span class="line">    v[<span class="number">1</span>] = <span class="number">13</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *ref_to_first);</span><br><span class="line">    <span class="built_in">free</span>(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及C++的实现是，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v &#123; <span class="number">12</span> &#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; ref_to_first = v[<span class="number">0</span>];</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">13</span>);</span><br><span class="line">    std::cout &lt;&lt; ref_to_first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不用多说，最后两个程序会被各自的编译器接受，即使它们的行为是未定义的。相反，Rust编译器会拒绝并抛出错误信息“cannot borrow <code>v</code> as mutable because it is also borrowed as immutable”。让我们看看该程序有什么错误。</p>
<p>首先，可变(mutable)变量<code>v</code>，用一个仅带数12的vector声明和初始化。</p>
<p>然后，变量<code>ref_to_first</code>用原先指向<code>v</code>的引用声明和初始化。引用指向的值包含数12。</p>
<p>然后，另一个数13被添加到vector。但这种插入会导致缓冲区的重新分配。即使在这个例子，<code>ref_to_first</code>仍会继续指向旧的对象，不是有效的内存地址。</p>
<p>最后，这个旧的内存地址，可能是错误的，读取的内存地址的值打印后，是不可预测的结果。</p>
<p>由于从一个vector插入或添加元素时，所有指向vector的引用都“失效”，导致这种错误的出现。通常，这种错误属于广义的错误类别，也就是一个数据结构，通过几种路径、或别名访问，当数据结构被其中一个别名修改时，不能被另一个别名使用。</p>
<p>我们将这类编程错误命名为“use after change by an alias”。</p>
<h2 id="How-to-Prevent-“Use-After-Drop”-Errors"><a class="header-anchor" href="#How-to-Prevent-“Use-After-Drop”-Errors">¶</a>How to Prevent “Use After Drop” Errors</h2>
<p>Rust防止使用“脱落，dropped”对象的技术是简单的。</p>
<p>把该对象看做是被一个变量指向，遵循栈分配的规则，会按照变量声明的反向顺序被脱落，而不是初始化的反向顺序。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>(<span class="type">char</span>);</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">X</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">		<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_a</span> = <span class="title function_ invoke__">X</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_b</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_c</span> = <span class="title function_ invoke__">X</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">_b = <span class="title function_ invoke__">X</span>(<span class="string">&#x27;b&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>该程序会打印“cba”。这三个对象按照顺序“acb”被构造，但三个对象的分配顺序是“abc”，因此回收以及脱落的按相反的顺序。</p>
<p>为了避免使用脱落对象，所有变量，租借其它变量拥有的对象，必须在该变量的 <strong>后面</strong> 声明。</p>
<p>例如，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">n</span> = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">_r</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">m</span> = <span class="number">13</span>;</span><br><span class="line">_r = &amp;m;</span><br><span class="line">_r = &amp;n;</span><br></pre></td></tr></table></figure>
<p>这段代码会产生错误信息：“<code>m</code> does not live long enough”。这是因为<code>_r</code>同时从<code>m</code>和<code>n</code>进行borrow，虽然不在同一时刻指向两者，但它在<code>m</code>之前声明了。要更正这段代码，改为如下，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">n</span> = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">m</span> = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">_r</span>;</span><br><span class="line">_r = &amp;m;</span><br><span class="line">_r = &amp;n;</span><br></pre></td></tr></table></figure>
<p>这段代码是合法的，当<code>m</code>和<code>n</code>拥有的对象被dropped时，不会再有指向它们的引用。</p>
<h2 id="How-to-Prevent-“Use-After-Change-by-an-Alias”-Errors"><a class="header-anchor" href="#How-to-Prevent-“Use-After-Change-by-an-Alias”-Errors">¶</a>How to Prevent “Use After Change by an Alias” Errors</h2>
<p>由于其它变量引起对象的改变，导致当前变量使用该对象出现错误。要避免这种错误，使用的规则有几分复杂。</p>
<p>首先，要求考虑任何语句会读这个对象，不会有写操作，就像是该对象的一个 <strong>临时不可变租借(temporary immutable borrowing)</strong>；任何语句变更这个对象，就像是该对象的一个 <strong>临时可变租借(temporary mutable borrowing)</strong>。这种租借的出现和结束在该语句的内部进行。</p>
<p>然后，租借开始于，获取指向该对象的引用，并分配给一个变量；结束于，该变量的作用域(scope)结束。</p>
<p>下面是一个例子，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> = <span class="number">13</span>;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, a);</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">c</span> = &amp;a;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">d</span> = &amp;<span class="keyword">mut</span> b;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &quot;</span>, c, d);</span><br><span class="line">&#125;</span><br><span class="line">b += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br></pre></td></tr></table></figure>
<p>结果会打印：“12 12 13 14”。</p>
<p>在第3行和最后一行，一个可变租借开始并结束。在第5行，一个不可变租借开始，第6行，一个可变租借开始；它们在语句块末尾结束。在第9行，一个可变租借开始并结束。</p>
<p>这种规则要求，同一时刻，可变租借(即，&amp;mut )的出现不能和其它租借并存。</p>
<p>换句话说，同一时刻：</p>
<ul>
<li>没有租借</li>
<li>或，一个单一的可变(mutable)租借</li>
<li>或，一个单一的不可变(immutable)租借</li>
<li>或，几个不可变(immutable)租借</li>
</ul>
<p>不能有：</p>
<ul>
<li>几个可变(mutable)租借</li>
<li>不能有一个单一的可变(mutable)租借和一个或多个不可变(immutable)租借</li>
</ul>
<h2 id="Listing-the-Possible-Cases-of-Multiple-Borrowings"><a class="header-anchor" href="#Listing-the-Possible-Cases-of-Multiple-Borrowings">¶</a>Listing the Possible Cases of Multiple Borrowings</h2>
<p>下面罗列六种允许的情况。</p>
<p>第一种：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_b</span> = &amp;a;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_c</span> = &amp;a;</span><br></pre></td></tr></table></figure>
<p>有两个不可变租借，直到结束为止被持有。</p>
<p>第二种：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_b</span> = &amp;a;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br></pre></td></tr></table></figure>
<p>第三种：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">12</span>;</span><br><span class="line">a = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_b</span> = &amp;a;</span><br></pre></td></tr></table></figure>
<p>一个不可变租借，紧随后一个临时可变租借。</p>
<p>第四种：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">12</span>;</span><br><span class="line">a = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_b</span> = &amp;<span class="keyword">mut</span> a;</span><br></pre></td></tr></table></figure>
<p>一个可变租借，紧随后一个临时可变租借。</p>
<p>第五种：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_b</span> = &amp;a;</span><br></pre></td></tr></table></figure>
<p>一个不可变租借，紧随后一个临时不可变租借。</p>
<p>第六种：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_b</span> = &amp;<span class="keyword">mut</span> a;</span><br></pre></td></tr></table></figure>
<p>一个可变租借，紧随后一个临时不可租借。</p>
<p>下面是六种不合法情况。</p>
<p>第一种：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_b</span> = &amp;<span class="keyword">mut</span> a;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_c</span> = &amp;a;</span><br></pre></td></tr></table></figure>
<p>编译出错“cannot borrow <code>a</code> as immutable because it is also borrowed as mutable”。</p>
<p>第二种：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_b</span> = &amp;a;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_c</span> = &amp;<span class="keyword">mut</span> a;</span><br></pre></td></tr></table></figure>
<p>编译出错“cannot borrow <code>a</code> as mutable because it is also borrowed as immutable”。</p>
<p>第三种：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_b</span> = &amp;<span class="keyword">mut</span> a;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_c</span> = &amp;<span class="keyword">mut</span> a;</span><br></pre></td></tr></table></figure>
<p>编译出错“cannot borrow <code>a</code> as mutable more than once at a time”。</p>
<p>第四种：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_b</span> = &amp;a;</span><br><span class="line">a = <span class="number">13</span>;</span><br></pre></td></tr></table></figure>
<p>编译出错“cannot assign to <code>a</code> because it is borrowed”。</p>
<p>第五种：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_b</span> = &amp;<span class="keyword">mut</span> a;</span><br><span class="line">a = <span class="number">13</span>;</span><br></pre></td></tr></table></figure>
<p>编译出错“cannot assign to <code>a</code> because it is borrowed”。</p>
<p>第六种：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_b</span> = &amp;<span class="keyword">mut</span> a;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br></pre></td></tr></table></figure>
<p>编译出错“cannot borrow <code>a</code> as immutable because it is also borrowed as mutable”。</p>
<p>梳理一下。对于当前尚未被borrowed的对象来说，允许的操作是：</p>
<ol>
<li>仅可被不可变租借(immutablely borrowed)数次，然后可以由所有者(owner)和任何租借方(borrower)读取。</li>
<li>仅可被可变租借(mutably borrowed)一次，然后有且仅能由这个租借方(borrower)读取和修改。</li>
</ol>
<h2 id="Using-a-Bock-to-Restrict-Borrowing-Scope"><a class="header-anchor" href="#Using-a-Bock-to-Restrict-Borrowing-Scope">¶</a>Using a Bock to Restrict Borrowing Scope</h2>
<p>当一个对象的租借结束后，对象对其它租借又变得可用了。任何类型的租借都可限制在语句块内。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">12</span>;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">b</span> = &amp;<span class="keyword">mut</span> a;</span><br><span class="line">	*b += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = &amp;<span class="keyword">mut</span> a;</span><br><span class="line">*c += <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>这是允许的，因为租借发生在第三行，语句块结束后，租借也结束了，因此第7行的<code>a</code>可以用于其它租借。</p>
<p>类似地，对于函数也一样，在函数结束后，对象再次变得可用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>*b: &amp;<span class="keyword">mut</span> <span class="type">i32</span>) &#123;</span><br><span class="line">	*b += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">f</span>(&amp;<span class="keyword">mut</span> a);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = &amp;<span class="keyword">mut</span> a;</span><br><span class="line">*c += <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>这种规则，适用于Rust确保可以自动地决定内存的回收，避免不合法的引用；这种规则允许Rust实现无数据竞争(data-race-free)的并发编程。</p>
<h2 id="The-Need-of-Lifetime-Specifiers-for-Returned-References"><a class="header-anchor" href="#The-Need-of-Lifetime-Specifiers-for-Returned-References">¶</a>The Need of Lifetime Specifiers for Returned References</h2>
<p>先看这段代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">11u8</span>, <span class="number">22</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span>;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">v2</span> = <span class="built_in">vec!</span>[<span class="number">33u8</span>];</span><br><span class="line">	result = &#123;</span><br><span class="line">		<span class="keyword">let</span> <span class="variable">_x1</span>: &amp;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = &amp;v1;</span><br><span class="line">		<span class="keyword">let</span> <span class="variable">_x2</span>: &amp;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = &amp;v2;</span><br><span class="line">		_x1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, *result);</span><br></pre></td></tr></table></figure>
<p>结果将会输出：“<code>[11, 22]</code>”。</p>
<p>变量<code>v1</code>和<code>v2</code>各自拥有vector。接着被两个引用borrowed了，分别被<code>_x1</code>和<code>_x2</code>拥有。因此，在第7行后，<code>_x1</code>租借了变量<code>v1</code>拥有的vector，<code>_x2</code>租借了变量<code>v2</code>拥有的vector。这是被允许的，因为<code>_x1</code>在<code>v1</code>之后声明，<code>_x2</code>在<code>v2</code>之后声明，这些引用比它们租借对象存活时间短。</p>
<p>在第八行，有个简单的表达式<code>_x1</code>。因为它是语句块的最后表达式，该表达式的值成为语句的值，因此该值被用来初始化变量<code>result</code>。该值是一个指向<code>v1</code>的引用，<code>result</code>变量租借了vector。这是被允许的，因为<code>result</code>的声明在<code>v1</code>之后，因此可以租借<code>v1</code>拥有的对象。</p>
<p>现在，小小的改动：在第八行替换&quot;1&quot;和&quot;2&quot;。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">11u8</span>, <span class="number">22</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span> = <span class="built_in">vec!</span>[<span class="number">33u8</span>];</span><br><span class="line">    result = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_x1</span>: &amp;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = &amp;v1;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_x2</span>: &amp;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = &amp;v2;</span><br><span class="line">        _x2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, *result);</span><br></pre></td></tr></table></figure>
<p>这会产生编译错误：“<code>v2</code> does not live long enough”。因为<code>result</code>的值来自于<code>_x2</code>表达式，由于<code>_x2</code>租借了<code>v2</code>的对象，所以<code>result</code>租借了vector。因为<code>result</code>在<code>v2</code>之前声明，因此不能租借它的对象。</p>
<p>Rust编译器致力于这种推理的部分称作“租借检查，<strong>borrow checker</strong>”。</p>
<p>现在，让我们尝试转换前面两个代码，将内部语句转换为一个函数。第一个变为，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">118</span>, <span class="number">22</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span> = <span class="built_in">vec!</span>[<span class="number">33u8</span>];</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">func</span>(_x1: &amp;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;, _x2: &amp;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;) <span class="punctuation">-&gt;</span> &amp;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; &#123;</span><br><span class="line">        _x1</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="title function_ invoke__">func</span>(&amp;v1, &amp;v2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, *result);</span><br></pre></td></tr></table></figure>
<p>第二个变为，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">11u8</span>, <span class="number">22</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span> = <span class="built_in">vec!</span>[<span class="number">33u8</span>];</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">func</span>(_x1: &amp;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;, _x2: &amp;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;) <span class="punctuation">-&gt;</span> &amp;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; &#123;</span><br><span class="line">        _x2</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="title function_ invoke__">func</span>(&amp;v1, &amp;v2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, *result);</span><br></pre></td></tr></table></figure>
<p>两者唯一不同的是<code>func</code>函数体。</p>
<p>根据之前的规则，第一个程序看起来是合法的，第二个不合法。两个<code>func</code>函数本身是合法的。但borrow checker会查找它们不兼容的具体用法。</p>
<p>泛型函数的参数边界使用traits，函数调用是否有效，依据该函数体的内容，这不是好事。主要是因为不能从错误信息理解出错的原因，除非你清楚函数体的内部代码。另一个原因是，函数被调用时，如果该函数体内任意调用了其它函数，确保<code>main</code>函数是合法的，borrow checker需要分析程序的所有函数。这种整个程序的分析带来了过度的复杂。</p>
<p>因此，类似于泛型函数，返回一个引用的函数，必须在函数签名阈将borrow-checking隔离！函数的borrow-check，仅考虑签名，函数体，函数调用的签名，而不需要考虑函数体调用其它函数。</p>
<p>因此，前面的两个程序都会出现编译错误：“missing lifetime specifier”。“声明周期指示器，<strong>lifetime specifier</strong>”是一个函数签名的一个装饰，它允许borrow checker对函数体和函数调用分离检查。</p>
<p>不管怎样，函数或语句体的租借行为应该是“到此为止”，不应该再将它进一步传递给其它函数或表达式，以避免带来不必要的副作用，未知的错误信息。</p>
<h2 id="Usage-and-Meaning-of-Lifetime-Specifiers"><a class="header-anchor" href="#Usage-and-Meaning-of-Lifetime-Specifiers">¶</a>Usage and Meaning of Lifetime Specifiers</h2>
<p>讨论到函数的调用和生命周期，下面是一个简单例子。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">func</span>(v1: <span class="type">Vec</span>&lt;<span class="type">u32</span>&gt;, v2: &amp;<span class="type">Vec</span>&lt;<span class="type">bool</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;Hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在任何Rust函数内，仅可以参考的有：</p>
<ul>
<li>函数参数拥有的对象(<code>v1</code>拥有的vector)；</li>
<li>本地变量拥有的对象(<code>s</code>拥有的动态字符串)；</li>
<li>临时对象(动态字符串表达式<code>&quot;Hello&quot;.to_string()</code>)；</li>
<li>静态对象(字符串字面量<code>&quot;Hello&quot;</code>)；</li>
<li>函数参数租借的对象，由预先存在的某些变量拥有，发生在当前函数调用处(<code>v2</code>租借过来的对象)。</li>
</ul>
<p>当一个函数返回一个引用，这个引用的对象不能推断是由函数参数拥有，还是由本地变量拥有，还是由临时对象拥有，因为当函数return时，本地变量，函数参数，临时变量都会被销毁。因此，这个引用将被悬挂。</p>
<p>相反，这个引用却可以推断得知是静态对象，或是函数参数租借的对象。</p>
<p>下面是这两种情况的中第一种情况的示例(尽管代码在Rust不被允许)，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">func</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="string">&quot;Hello&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">func</span>(v: &amp;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;) <span class="punctuation">-&gt;</span> &amp;<span class="type">u8</span> &#123;</span><br><span class="line">    &amp;v[<span class="number">3</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>borrow checker仅对返回值的引用感兴趣，该引用有两种：指向静态对象，或接收的参数的租借对象。borrow checker需要知道哪些引用是指向静态对象，哪些是租借的参数对象；如果有几个参数租借对象，需要知道它们中哪些租借了非静态返回的引用。</p>
<p>不带lifetime specifer的函数签名是不合法的，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Tr</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>(flag: <span class="type">bool</span>, b: &amp;<span class="type">i32</span>, c: (<span class="type">char</span>, &amp;<span class="type">i32</span>)) <span class="punctuation">-&gt;</span> (&amp;<span class="type">i32</span>, <span class="type">f64</span>, &amp;<span class="type">i32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数签名参数中有两个引用，返回值类型也包含有两个引用。后两个引用可能指向静态对象，或者参数<code>b</code>的租借对象，或者参数<code>c</code>的第二个字段的租借对象。</p>
<p>下面表达式指定了一种可能的情况，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Tr</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>&lt;<span class="symbol">&#x27;a</span>&gt;(flag: <span class="type">bool</span>, b: &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>, c: (<span class="type">char</span>, &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>)) <span class="punctuation">-&gt;</span> (&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>, <span class="type">f64</span>, &amp;<span class="symbol">&#x27;static</span> <span class="type">i32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和泛型函数用法一样，在函数名后面，添加一个参数列表。如其说是一个类型参数，实际上它是一个生命周期指示器(lifetime specifier)。</p>
<p>从句<code>&lt;'a&gt;</code>是一个声明。它表示：<code>&lt;&lt;In this function signature, a lifetime specifier is used; its name is &quot;a&quot;&gt;&gt;</code>。名字&quot;a&quot;是任意的。它简单表示所有出现的情况，“匹配”这种出现。它类似泛型函数的类型参数，不同的地方在于，生命周期指示器前缀使用单引号，另外，按照约定，泛型参数首字母使用大写，生命周期指示器使用一个小写字母，如a，b，c，…。</p>
<p>然后，函数签名包含其它三个<code>'a</code>生命周期指示器的出现，<code>b</code>参数的类型、<code>c</code>参数的第二字段的类型、返回值的第一个字段的类型。相反，返回值的第三个字段类型用了<code>static</code>生命周期标识。</p>
<p>该<code>a</code>生命周期指示器的用法表示：“返回值的第一个字段租借已存在的<code>b</code>参数和<code>c</code>参数第二个字段的对象，因此它存活比该对象要短”。</p>
<p>相反，<code>static</code>生命周期指示器的用法表示：“返回值的第三个字段指向一个静态对象，因此它可以存活在任何时间，甚至和整个进程一样长”。</p>
<p>当然，这仅是一种可能生命周期注解，下面是另一种，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Tr</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">f</span>&lt;<span class="symbol">&#x27;a</span>&gt;(flag: <span class="type">bool</span>, b: &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>, c: (<span class="type">char</span>, &amp;<span class="type">i32</span>)) <span class="punctuation">-&gt;</span> (&amp;<span class="symbol">&#x27;static</span> <span class="type">i32</span>, <span class="type">f64</span>, &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>c</code>参数不带注解，引用的对象不租借给返回值的引用，</p>
<p>还有另一种可能生命周期注解，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Tr</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">f</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>, T1, T2&gt;(flag: <span class="type">bool</span>, b: &amp;<span class="symbol">&#x27;a</span> T1, c: (<span class="type">char</span>, &amp;<span class="symbol">&#x27;b</span> <span class="type">i32</span>)) <span class="punctuation">-&gt;</span> (&amp;<span class="symbol">&#x27;b</span> <span class="type">i32</span>, <span class="type">f64</span>, &amp;<span class="symbol">&#x27;a</span> T2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型函数有两个生命周期指示器和两个泛型参数。生命周期参数<code>a</code>指定了返回值的第三个字段租借了参数<code>b</code>的对象，以及生命周期参数<code>b</code>指定了返回值的第一个字段租借了参数<code>c</code>的第二个字段的对象。另外，函数有两个类型参数<code>T1</code>和<code>T2</code>，不带trait边界。</p>
<h2 id="Checking-the-Validity-of-Lifetime-Specifiers"><a class="header-anchor" href="#Checking-the-Validity-of-Lifetime-Specifiers">¶</a>Checking the Validity of Lifetime Specifiers</h2>
<p>编译任何函数时，borrow checker有两个工作：</p>
<ul>
<li>通过函数自身和函数体，检查函数签名是否有效。</li>
<li>检查函数体是否合法，统计该函数被调用次数。</li>
</ul>
<p>本小节，先看第一种情况。</p>
<p>如果函数返回值没有引用类型，borrow checker不做任何处理。</p>
<p>否则，每个返回值引用，必须检查是否有正确的生命周期指示器(lifetime specifier)。</p>
<p>这样一个指示器(specifier)可以是“<code>'static</code>”。这种情况，引用必须指向一个静态对象。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> FOUR: <span class="type">u8</span> = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>() <span class="punctuation">-&gt;</span> (<span class="type">bool</span>, &amp;<span class="symbol">&#x27;static</span> <span class="type">u8</span>, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>, &amp;<span class="symbol">&#x27;static</span> <span class="type">f64</span>) &#123;</span><br><span class="line">    (<span class="literal">true</span>, &amp;FOUR, <span class="string">&quot;Hello&quot;</span>, &amp;<span class="number">3.14</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, <span class="title function_ invoke__">f</span>().<span class="number">0</span>, *<span class="title function_ invoke__">f</span>().<span class="number">1</span>, <span class="title function_ invoke__">f</span>().<span class="number">2</span>, *<span class="title function_ invoke__">f</span>().<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>结果将会打印：“<code>true 4 Hello 3.14</code>”。该程序是合法的，因为三个返回值的引用都是静态对象。</p>
<p>相反，下面</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>(n: &amp;<span class="type">u8</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">u8</span> &#123;</span><br><span class="line">	n</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, *<span class="title function_ invoke__">f</span>(&amp;<span class="number">12</span>));</span><br></pre></td></tr></table></figure>
<p>将会生成编译错误：“lifetime of reference outlives lifetime of borrowed content…”。这是不合法的，返回值不是一个指向静态对象的引用；它实际上是接收参数的值，该返回值租借了函数参数引用对象的同一个对象。</p>
<p>生命周期指示器可以定义成列表的形式，如下</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>, y: &amp;<span class="symbol">&#x27;b</span> <span class="type">i32</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="symbol">&#x27;b</span> <span class="type">i32</span>, <span class="type">bool</span>, &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>) &#123;</span><br><span class="line">	(y, <span class="literal">true</span>, x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">i</span> = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">j</span> = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">f</span>(&amp;i, &amp;j);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, *r.<span class="number">0</span>, r.<span class="number">1</span>, *r.<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>结果将打印：“13 true 12”。这是有效的，因为tuple中返回的第一个字段引用的时<code>y</code>表达式的值，以<code>y</code>参数和返回值的第一个字段有同样的生命周期指示器(lifetime specifier)；它们的生命周期指示器都是<code>'b</code>。返回值的第三个字段和参数<code>x</code>一样有同一个生命周期指示器<code>'a</code>。</p>
<p>相反，下面</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>, y: &amp;<span class="symbol">&#x27;b</span> <span class="type">i32</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="symbol">&#x27;b</span> <span class="type">i32</span>, <span class="type">bool</span>, &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>) &#123;</span><br><span class="line">	(x, <span class="literal">true</span>, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">i</span> = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">j</span> = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">f</span>(&amp;i, &amp;j);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, *r.<span class="number">0</span>, r.<span class="number">1</span>, *r.<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>会产生两个编译错误，两个错误都是：“lifetime mismatch”。实际上，返回值的第一个字段和第三个字段都有生命周期指示器，但不是对应它们函数签名。</p>
<p>注意到，多个返回字段可能仅用了一个生命周期指示器：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>, <span class="type">bool</span>, &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>) &#123;</span><br><span class="line">	(x, <span class="literal">true</span>, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">i</span> = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">j</span> = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">f</span>(&amp;i, &amp;j);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, *r.<span class="number">0</span>, r.<span class="number">1</span>, *r.<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>这里，<code>'b</code>被替换为<code>'a</code>。但味道完全不一样。</p>
<p>原来的版本是，参数列表指示了会有两个独立的生命周期；这个版本，它们共享生命周期。</p>
<p>这个改动对于租借检查器(borrow checker)来说不简单。让我们考虑一个更复杂的函数体：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>&lt;<span class="symbol">&#x27;a</span>&gt;(n: <span class="type">i32</span>, x: &amp;<span class="symbol">&#x27;a</span> <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;, y: &amp;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">u8</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123; <span class="keyword">return</span> &amp;x[<span class="number">0</span>]; &#125;</span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">0</span> &#123; &amp;x[<span class="number">1</span>] &#125; <span class="keyword">else</span> &#123; &amp;x[<span class="number">2</span>] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数是有效的。函数体有三个可能的表达式返回值，所有表达式都租借了参数<code>x</code>的对象。返回值有和参数等同的生命周期，所以满足borrow checker。</p>
<p>相反，下面</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>&lt;<span class="symbol">&#x27;a</span>&gt;(n: <span class="type">i32</span>, x: &amp;<span class="symbol">&#x27;a</span> <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;, y: &amp;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">u8</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123; <span class="keyword">return</span> &amp;x[<span class="number">0</span>]; &#125;</span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">0</span> &#123; &amp;x[<span class="number">1</span>] &#125; <span class="keyword">else</span> &#123; &amp;y[<span class="number">2</span>] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个可能的返回值，会是表达式<code>&amp;y[2]</code>，该对象租借自<code>y</code>，这个参数没有生命周期指示器，所以该代码是不合法的。</p>
<p>即使下面代码也是不合法的，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;, y: &amp;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">u8</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="literal">true</span> &#123; &amp;x[<span class="number">0</span>] &#125; <span class="keyword">else</span> &#123; &amp;y[<span class="number">0</span>] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当处理数据流分析时，编译器会探测到<code>y</code>从不被返回值租借；但borrow checker坚持因为<code>&amp;y[0]</code>是一个可能返回值，所以该段程序被认为是无效的。</p>
<h2 id="Using-the-Lifetime-Specifiers-of-Invoked-Functions"><a class="header-anchor" href="#Using-the-Lifetime-Specifiers-of-Invoked-Functions">¶</a>Using the Lifetime Specifiers of Invoked Functions</h2>
<p>上一章节的开始部分说过，borrow checker有两项工作，编译函数时进行检查函数体是否有效，统计函数体内任意被调用函数的签名。</p>
<p>沿用上一节的代码示例。根据租借的规则，“missing lifetime specifier”表示缺少lifetime specifier，我们将原来的加上生命周期指示器，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">11u8</span>, <span class="number">22</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span>;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">v2</span> = <span class="built_in">vec!</span>[<span class="number">33u8</span>];</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">func</span>&lt;<span class="symbol">&#x27;a</span>&gt;(_x1: &amp;<span class="symbol">&#x27;a</span> <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;, _x2: &amp;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; &#123;</span><br><span class="line">		_x1</span><br><span class="line">	&#125;</span><br><span class="line">	result = <span class="title function_ invoke__">func</span>(&amp;v1, &amp;v2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, *result);</span><br></pre></td></tr></table></figure>
<p>第二个例子改为，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">11u8</span>, <span class="number">22</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span>;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">v2</span> = <span class="built_in">vec!</span>[<span class="number">33u8</span>];</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">func</span>&lt;<span class="symbol">&#x27;a</span>&gt;(_x1: &amp;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;, _x2: &amp;<span class="symbol">&#x27;a</span> <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; &#123;</span><br><span class="line">		_x2</span><br><span class="line">	&#125;</span><br><span class="line">	result = <span class="title function_ invoke__">func</span>(&amp;v1, &amp;v2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, *result);</span><br></pre></td></tr></table></figure>
<p>第一个程序是有效的，结果会打印：“<code>[11, 22]</code>”，第二个会有编译错误：“<code>v2</code> does not live long enough”。</p>
<p>为什么<code>func</code>这些写法会产生编译错误，前面小节已经解析过了。</p>
<p>让我们看看<code>main</code>函数在第一个程序如何工作的。当<code>func</code>被调用，存活<code>v1</code>、<code>result</code>和<code>v2</code>，按顺序声明，以及<code>v1</code>和<code>v2</code>早已被初始化。<code>func</code>的签名说结果值和第一个参数有相同的lifetime specifier，这意味着<code>result</code>的值不会存活得比<code>v1</code>长。以及，<code>result</code>在<code>v1</code>之后声明，因此它会先于<code>v1</code>销毁。</p>
<p>再看看为什么第二段程序的<code>main</code>函数是不合法的。这里，<code>func</code>的签名说返回值和第二个参数有相同的lifetime specifier，意味着<code>result</code>存活不会比<code>v2</code>长。但<code>result</code>在<code>v2</code>之前声明，而它会在其后被销毁。</p>
<p>这是因为只使用了一个lifetime specifiter，下面改为两个指示器，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>, y: &amp;<span class="symbol">&#x27;b</span> <span class="type">i32</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="symbol">&#x27;b</span> <span class="type">i32</span>, <span class="type">bool</span>, &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>) &#123;</span><br><span class="line">    (x, <span class="literal">true</span>, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">i1</span> = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">i2</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">j1</span> = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">j2</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">f</span>(&amp;i1, &amp;j1);</span><br><span class="line">i2 = r.<span class="number">0</span>;</span><br><span class="line">j2 = r.<span class="number">2</span>;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, *i2, r.<span class="number">1</span>, *j2);</span><br></pre></td></tr></table></figure>
<p>结果将打印“12 true 13”。</p>
<p>相反，如果仅用一个lifetime specifier时，是不合法的，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>, <span class="type">bool</span>, &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>) &#123;</span><br><span class="line">	(x, <span class="literal">true</span>, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">i1</span> = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">i2</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">j1</span> = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">j2</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">f</span>(&amp;i1, &amp;j1);</span><br><span class="line">i2 = r.<span class="number">0</span>;</span><br><span class="line">j2 = r.<span class="number">2</span>;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, *i2, r.<span class="number">1</span>, *j2);</span><br></pre></td></tr></table></figure>
<p>这会产生编译错误：“<code>j1</code> does not live long enough”。</p>
<p>在这两个版本中，函数<code>f</code>都会接收<code>i1</code>和<code>j1</code>的引用，首先返回变量<code>r</code>存储的值，然后分别地初始化<code>i2</code>和<code>j2</code>变量。</p>
<p>在第一个版本中，第一个参数和返回值的第一个字段拥有相同的lifetime specifier，这导致了<code>i2</code>必须存活少于<code>i1</code>。类似地，<code>j2</code>必须存活少于<code>j1</code>。实际上，变量的声明顺序需要满足这些要求。</p>
<p>第二个版本，由于只有一个lifetime specifier，所以<code>i2</code>和<code>j2</code>必须存活少于<code>i1</code>和<code>j1</code>。实际上，<code>i2</code>被声明在<code>j1</code>前，不能满足这些要求。</p>
</div></article><nav class="article-nav"><div class="article-nav-prev"><a href="/2023/01/23/rust/beginning/chapter23_More%20About%20Lifetimes/">rust基础入门[23] - More About Lifetimes</a></div><div class="article-nav-next"><a href="/2023/01/21/rust/beginning/chapter21_Drops,%20Moves,%20and%20Copies/">rust基础入门[21] - Drops, Moves, and Copies</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2023/01/22/rust/beginning/chapter22_Borrowing and Lifetimes/';
var disqus_title = 'rust基础入门[22] - Borrowing and Lifetimes';
var disqus_url = 'https://galudisu.info/2023/01/22/rust/beginning/chapter22_Borrowing and Lifetimes/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>