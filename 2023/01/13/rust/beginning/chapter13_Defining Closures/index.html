<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>rust基础入门[13] - Defining Closures</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/maths/">Maths</a></li><li class="menu-item"><a class="menu-link" href="/projects/">Projects</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/maths/">Maths</a></li><li class="menu-item"><a class="menu-link" href="/projects/">Projects</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">rust基础入门[13] - Defining Closures</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2023-01-13</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/rust/">rust</a></p><p class="meta-item meta-category"><span class="meta-item-title"></span><i class="icon-bookmark"> </i><a class="category-link" href="/categories/learning/">learning</a></p></div><div class="article-content"><p>本章覆盖有：</p>
<ul>
<li>为什么需要匿名函数，如何编写匿名函数，如何访问它定义的变量</li>
<li>这些“闭包”，如何声明和调用</li>
</ul>
<span id="more"></span>
<h2 id="The-Need-for-“Disposable”-Functions"><a class="header-anchor" href="#The-Need-for-“Disposable”-Functions">¶</a>The Need for “Disposable” Functions</h2>
<p>Rust对数组的升序实现，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">45</span>, <span class="number">12</span>, <span class="number">7</span>];</span><br><span class="line">arr.<span class="title function_ invoke__">sort</span>();</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br></pre></td></tr></table></figure>
<p>结果将输出：“<code>[0, 1, 4, 7, 8, 10, 12, 45]</code>”。</p>
<p>但标准库里面没有提供降序的函数；你需要调用<code>sort_by</code>函数，将它的一个引用传递给一个比较函数。这种函数接受两个记录，并返回一个indication：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">45</span>, <span class="number">12</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">desc</span>(a: &amp;<span class="type">i32</span>, b: &amp;<span class="type">i32</span>) <span class="punctuation">-&gt;</span> Ordering &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123; Ordering::Greater &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> a &gt; b &#123; Ordering::Less &#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; Ordering::Equal &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr.<span class="title function_ invoke__">sort_by</span>(desc);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br></pre></td></tr></table></figure>
<p><code>desc</code>函数返回了一个标准库中定义的类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Ordering</span> &#123; Less, Equal, Greater &#125;</span><br></pre></td></tr></table></figure>
<p>这种方式生效，但有几点诟病。</p>
<p>首先，<code>desc</code>函数定义仅用于一处。标准库函数<code>sort_by</code>接收一个函数入参。这个入参需要是一个匿名函数，这个函数也仅用于一处。</p>
<p>另外，虽然类型规范对于变量声明是可选的，但对于参数和函数的返回值是必须的。这些规范，可以像函数名一样，方便地在其它语句或程序调用。但当你需要写一个函数仅在它声明的地方调用，这种规范几乎是匿名的。因此，声明和调用一个行内匿名的、由参数和返回值推断的类型的函数，将会是一个便利的特性。</p>
<p>另一个诟病是需要给函数体花括号闭合。通常函数会包含几条语句，因此不是所有匿名的带上花括号闭合。相反，匿名函数通常只有一条单一表达式，可以不用写闭合。</p>
<h2 id="Capturing-the-Environment"><a class="header-anchor" href="#Capturing-the-Environment">¶</a>Capturing the Environment</h2>
<p>本章我们所陈述的所有内容，对于其它大多数语言也是适用的，包括C语言。但Rust函数有一个额外的不寻常限制：它不能访问任何外部声明的变量。你可以访问<code>static</code>的，你可以访问<code>constants</code>的，但不能访问栈分配的变量(也就是用<code>let</code>声明的变量)。例如，下面例子是不合法的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">two</span> = <span class="number">2</span>.;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_double</span>(x: <span class="type">f64</span>) &#123;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x * two);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">print_double</span>(<span class="number">17.2</span>);</span><br></pre></td></tr></table></figure>
<p>编译出错：“can’t capture dynamic environment in an fn item.”</p>
<p>“dynamic environment”意味着一系列变量在函数调用时才生效。所以，它是“dynamic”的，这些变量核能在某些语句生效，在其它语句失效。“capture the environment”意味着能够访问这些变量。</p>
<p>相反，下面是有效的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TWO: <span class="type">f64</span> = <span class="number">2</span>.;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_double</span>(x: <span class="type">f64</span>) &#123;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x * TWO);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">print_double</span>(<span class="number">17.2</span>);</span><br></pre></td></tr></table></figure>
<p>或者这样写</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> TWO: <span class="type">f64</span> = <span class="number">2</span>.;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_double</span>(x: <span class="type">f64</span>) &#123;</span><br><span class="line">	<span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x * TWO);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">print_double</span>(<span class="number">17.2</span>);</span><br></pre></td></tr></table></figure>
<p>这种限制有一个很好的理由：外部变量可以有效地进入函数的程序接口，但是从函数签名中看不出来，因此它对理解代码产生误导。</p>
<p>但当一个函数仅能在它定义的地方调用，访问外部变量并不能降低理解难度，因为这些外部变量在声明语句已经生效。</p>
<p>因此，我们特性的需求是：一个行内匿名函数，带类型推断；一个单一表达式作为函数体；可以捕获任何有效变量。</p>
<h2 id="Closures"><a class="header-anchor" href="#Closures">¶</a>Closures</h2>
<p>闭包，说白了就是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使离开了创造它的环境也不例外。</p>
<p>闭包的调用出现在它定义的地方。实际上，你也可以定义一个闭包，尽管类型规范可行，实际上典型使用闭包的场景并不多。下面是使用闭包实现排序的一种方式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">45</span>, <span class="number">12</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">desc</span> = |a: &amp;<span class="type">i32</span>, b: &amp;<span class="type">i32</span>| <span class="punctuation">-&gt;</span> Ordering &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123; Ordering::Greater &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> a &gt; b &#123; Ordering::Less &#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; Ordering::Equal &#125;</span><br><span class="line">&#125;;</span><br><span class="line">arr.<span class="title function_ invoke__">sort_by</span>(desc);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br></pre></td></tr></table></figure>
<p>跟前面不同的是：</p>
<ul>
<li>使用了<code>let</code>关键字代替<code>fn</code>。</li>
<li>闭包名后面带有<code>=</code>号。</li>
<li>函数的参数由<code>(</code>和<code>)</code>，在闭包中变为<code>|</code>(管道)标志。</li>
<li>闭包声明带有分号<code>;</code>。</li>
</ul>
<p>至此，我们说过，闭包声明和调用都在同一个地方，类型和大括号(braces)是可选的。因此，上面可以简化一下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">0</span>, <span class="number">45</span>, <span class="number">12</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line">arr.<span class="title function_ invoke__">sort_by</span>(|a, b|</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123; Ordering::Greater &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> a &gt; b &#123; Ordering::Less &#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; Ordering:: Equal &#125;);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br></pre></td></tr></table></figure>
<p>有很多简洁的写法。标准库早以包含有<code>cmp</code>函数(&quot;compare&quot;的简写)；该函数根据两个参数比较返回一个<code>Ordering</code>值。下面写法是等价的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_ invoke__">sort</span>();</span><br><span class="line">arr.<span class="title function_ invoke__">sort_by</span>(|a, b| a.<span class="title function_ invoke__">cmp</span>(b));</span><br></pre></td></tr></table></figure>
<p>因此，要想得到一个反转的顺序，你可以用下面的方式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_ invoke__">sort_by</span>(|a, b| (&amp;-*a).<span class="title function_ invoke__">cmp</span>(&amp;-*b));</span><br><span class="line">arr.<span class="title function_ invoke__">sort_by</span>(|a, b| b.<span class="title function_ invoke__">cmp</span>(a));</span><br></pre></td></tr></table></figure>
<p>完整代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">45</span>, <span class="number">12</span>, <span class="number">7</span>];</span><br><span class="line">arr.<span class="title function_ invoke__">sort_by</span>(|a, b| b.<span class="title function_ invoke__">cmp</span>(a));</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br></pre></td></tr></table></figure>
<p>同时也删除了<code>use</code>指令，因为这里不再需要。</p>
<h2 id="Other-Examples"><a class="header-anchor" href="#Other-Examples">¶</a>Other Examples</h2>
<p>下面是以6种方式调用闭包的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">factor</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">multiply</span> = |a| a * factor;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">multiply</span>(<span class="number">13</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">multiply_ref</span>: &amp;(<span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>) = &amp; multiply;</span><br><span class="line"><span class="built_in">print!</span>(</span><br><span class="line">	<span class="string">&quot; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>,</span><br><span class="line">	(*multiply_ref)(<span class="number">13</span>),</span><br><span class="line">	<span class="title function_ invoke__">multiply_ref</span>(<span class="number">13</span>),</span><br><span class="line">	(|a| a * factor)(<span class="number">13</span>),</span><br><span class="line">	(|a: <span class="type">i32</span>| a * factor)(<span class="number">13</span>),</span><br><span class="line">	|a| <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; a * factor &#125;(<span class="number">13</span>));</span><br></pre></td></tr></table></figure>
<p>将会打印输出：“<code>26 26 26 26 26 26</code>”。</p>
<p>该程序提供6种不同风格的闭包调用。每个调用都接收一个<code>i32</code>的命名参数<code>a</code>；由变量<code>factor</code>作乘积；这里的入参总是13，所以结果总是26。</p>
<p>在第二行，声明了一个闭包，它根据参数<code>a</code>和返回值进行类型推断。闭包内访问内部变量<code>factor</code>，即捕获了自由变量。以及初始化了变量<code>multiply</code>，它的类型由推断得出。</p>
<p>在第三行，闭包指派到<code>multiply</code>变量的调用和函数类似。</p>
<p>在第四行，声明的闭包的地址被用于初始化<code>multiply_ref</code>变量。该变量的类型可以被推断，但已经被明确指定。这里的<code>Fn</code>表示它是一个函数类型。每个函数都有一个类型，它有它的参数和返回值确定。表达式<code>Fn(i32) -&gt; i32</code>表示“该函数的类型是：接收一个<code>i32</code>参数，返回一个<code>i32</code>”。该类型表达式又符号<code>&amp;</code>处理，因为它是一个“reference to a function”，不是“a function”。</p>
<p>在第七行，函数的引用被反向引用，获得一个函数，以及调用这个函数。</p>
<p>在第八行，函数不进行反引用被调用，因为该函数调用会隐式地反引用处理。</p>
<p>最后三条语句，声明了匿名闭包并进行调用。第一条语句可以推断出参数类型和返回类型；第二条制定了参数类型并推断返回类型；第三条指定了返回类型，推断出参数类型。</p>
<p>注意参数13被传递到闭包总是用小括号括住。为了避免表达式<code>(13)</code>与前面部分的闭包出现迷惑，某些情况下闭包表达式也需要用小括号括起来。与此，在最后一条语句，闭包的语句体，要与返回类型规范区别开来，需要用花括号(braces)。</p>
<p>当闭包包含几个语句时，花括号是必须的，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print!</span>(</span><br><span class="line">	<span class="string">&quot;&#123;&#125;&quot;</span>,</span><br><span class="line">	(|v: &amp;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;| &#123;</span><br><span class="line">		<span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sum</span> = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..v.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">			sum += v[i];</span><br><span class="line">		&#125;</span><br><span class="line">		sum</span><br><span class="line">	&#125;)(&amp;<span class="built_in">vec!</span>[<span class="number">11</span>, <span class="number">22</span>, <span class="number">34</span>]));</span><br></pre></td></tr></table></figure>
<p>这里将打印输出“67”，即向量元素求和。</p>
<p>这里需要制定参数的类型，不然编译器无法推断，以及抛出一个错误信息“<code>the type of this value must be known in this context</code>”，定义在表达式<code>v.len()</code>上。</p>
</div></article><nav class="article-nav"><div class="article-nav-prev"><a href="/2023/01/14/rust/beginning/chapter14_Using%20Changeable%20Strings/">rust基础入门[14] - Using Changeable Strings</a></div><div class="article-nav-next"><a href="/2023/01/12/rust/beginning/chapter12_Data%20Implementation/">rust基础入门[12] - Data Implementation</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2023/01/13/rust/beginning/chapter13_Defining Closures/';
var disqus_title = 'rust基础入门[13] - Defining Closures';
var disqus_url = 'https://galudisu.info/2023/01/13/rust/beginning/chapter13_Defining Closures/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>