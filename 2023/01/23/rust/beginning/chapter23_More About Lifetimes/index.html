<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>rust基础入门[23] - More About Lifetimes</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/maths/">Maths</a></li><li class="menu-item"><a class="menu-link" href="/projects/">Projects</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/maths/">Maths</a></li><li class="menu-item"><a class="menu-link" href="/projects/">Projects</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">rust基础入门[23] - More About Lifetimes</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2023-01-23</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/rust/">rust</a></p><p class="meta-item meta-category"><span class="meta-item-title"></span><i class="icon-bookmark"> </i><a class="category-link" href="/categories/learning/">learning</a></p></div><div class="article-content"><p>本章覆盖有：</p>
<ul>
<li>简单、自由(free)函数和方法需要避免写入生命周期指示器(lifetime specifiers)，因为它们是被推断的</li>
<li>为什么包含引用的结构体(structs)、元组-结构体(tuple-structs)、枚举(enums)需要生命周期指示器(lifetime specifiers)</li>
<li>如何为结构体(structs)、元组-结构体(tuple-structs)、枚举(enums)编写生命周期指示器(lifetime specifiers)</li>
<li>为什么包含指向泛型参数的结构体需要生命周期边界(协变、逆协变)</li>
</ul>
<span id="more"></span>
<h2 id="Lifetime-Elision"><a class="header-anchor" href="#Lifetime-Elision">¶</a>Lifetime Elision</h2>
<p>上一章节，我们看到每个函数签名，都必须确定引用返回值，即要么是<code>'static</code>的lifetime specifier，要么是关联的函数参数的lifetime specifier。</p>
<p>有时避免编写这种烦人的注解。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Tr</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>(x: &amp;<span class="type">u8</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">u8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这代码是被允许的。返回的值是个引用，它没用指定生命周期，但它也不是<code>'static</code>的，因此这个隐式生命周期指示器(implicit lifetime specifier)必须是函数参数中的其中一个。因为函数参数仅有一个，因此它的lifetime specifier无可厚非就是该参数关联的lifetime specifier。换言之，这个声明函数等效于下面的写法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Tr</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">u8</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">u8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>甚至下面的声明也是有效的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Tr</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>(b: <span class="type">bool</span>, x: (<span class="type">u32</span>, &amp;<span class="type">u8</span>)) <span class="punctuation">-&gt;</span> &amp;<span class="type">u8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为仅有一个引用，因此可以推断出返回值指向的对象。</p>
<p>下面的代码也是有效的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Tr</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>(x: &amp;<span class="type">u8</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="type">u8</span>, &amp;<span class="type">f64</span>, <span class="type">bool</span>, &amp;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况，返回值有好几个引用，但参数的引用仍然仅有一种。</p>
<p>参数引用类型仅有一种时，你甚至可以省略其返回值类型，而用在其它类型中指定。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Tr</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">u8</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="type">u8</span>, &amp;<span class="symbol">&#x27;a</span> <span class="type">f64</span>, <span class="type">bool</span>, &amp;<span class="symbol">&#x27;static</span> <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的返回值包含三个引用：第一个没有指定，第二字段有<code>'a</code>，第三个用了<code>'static</code>生命周期指示器。然而，参数中仍然仅有一个引用，因此返回的第一个字段的引用有一个隐式<code>'a</code>生命周期指示器。</p>
<p>这种省略机制称为“<strong>lifetime elision</strong>”。为了简化语法，生命周期指示器遇到这种仅有一个非静态(non-static)值时，可以 <strong>删去(elided)</strong> 。</p>
<h2 id="Lifetime-Elision-with-Object-Oriented-Programming"><a class="header-anchor" href="#Lifetime-Elision-with-Object-Oriented-Programming">¶</a>Lifetime Elision with Object-Oriented Programming</h2>
<p>考虑下面：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Tr</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>(&amp;<span class="keyword">self</span>, y: &amp;<span class="type">u8</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="type">u8</span>, &amp;<span class="type">f64</span>, <span class="type">bool</span>, &amp;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为参数有两个引用，所以前面的规则不起作用。然而，当一个方法返回某些引用时，多数情况下这些引用会租借当前的对象，即由<code>&amp;self</code>指向的值。因此，为了简化表达式，前面的代码被看做是下面的等价：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Tr</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">f</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">self</span>, y: &amp;<span class="type">u8</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="symbol">&#x27;a</span> <span class="type">u8</span>, &amp;<span class="symbol">&#x27;a</span> <span class="type">f64</span>, <span class="type">bool</span>, &amp;<span class="symbol">&#x27;a</span> <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前，你可以为特定引用重载行为。这种情况，你希望返回值的第二个字段生命周期关联参数<code>y</code>，你需要写，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Tr</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">f</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="keyword">self</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">u8</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="type">u8</span>, &amp;<span class="symbol">&#x27;a</span> <span class="type">f64</span>, <span class="type">bool</span>, &amp;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，tuple中第二个字段指向的对象，存活时间必须要少于<code>y</code>指向的对象，以及第一个字段和第四个字段指向的对象，存活时间必须要少于<code>self</code>指向的对象。</p>
<p>当然，这个规则同样作用于<code>&amp;mut self</code>参数。</p>
<h2 id="The-Need-of-Lifetime-Specifiers-for-Structs"><a class="header-anchor" href="#The-Need-of-Lifetime-Specifiers-for-Structs">¶</a>The Need of Lifetime Specifiers for Structs</h2>
<p>上一个章节中，我们看到这种代码是有效的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i32</span> = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_y</span>: &amp;<span class="type">i32</span> = &amp;x;</span><br></pre></td></tr></table></figure>
<p>这是因为，尽管<code>_y</code>持有对<code>x</code>的引用，它存活少于<code>x</code>。</p>
<p>相反，下面是不合法的，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">_y</span>: &amp;<span class="type">i32</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i32</span> = <span class="number">12</span>;</span><br><span class="line">_y = &amp;x;</span><br></pre></td></tr></table></figure>
<p>因为<code>_y</code>先于<code>x</code>声明，所以它会在<code>x</code>后销毁，它存活长于<code>x</code>。</p>
<p>我们也看到了，对于函数签名，需要有合适的注解(即lifetime specifier)，来满足有效的租借检查(borrow checker)。</p>
<p>除了上一章介绍这些情况，对于结构体(struct)来说，包含某些引用的issue下也相似。</p>
<p>下面代码看起来是合法的(实际上不是)：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">	_b: <span class="type">bool</span>,</span><br><span class="line">	_ri: &amp;<span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i32</span> = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_y</span>: S = S &#123; _b: <span class="literal">true</span>, _ri: &amp;x &#125;;</span><br></pre></td></tr></table></figure>
<p>下面这种很明显是不合法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">	_b: <span class="type">bool</span>,</span><br><span class="line">	_ri: &amp;<span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_y</span>: S;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i32</span> = <span class="number">12</span>;</span><br><span class="line">_y = s &#123; _b: <span class="literal">true</span>, _ri: &amp;x &#125;;</span><br></pre></td></tr></table></figure>
<p>尽管<code>S</code>的字段<code>_ri</code>持有一个<code>x</code>的引用，但它存活长于<code>x</code>。</p>
<p>这种情况可以非常简单分析出来，但在一个real-world程序中可能是：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In some library code:</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">	_b: <span class="type">bool</span>,</span><br><span class="line">	_ri: &amp;<span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">create_s</span>(ri: &amp;<span class="type">i32</span>) <span class="punctuation">-&gt;</span> &#123;</span><br><span class="line">	s &#123; _b: <span class="literal">true</span>, _ri: ri &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// In application code:</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">_y</span>: S;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i32</span> = <span class="number">12</span>;</span><br><span class="line">	_y = <span class="title function_ invoke__">create_s</span>(&amp;x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序代码是无效的，因为，当调用<code>create_s</code>时，指向<code>x</code>的引用会被存储在<code>_y</code>对象内部，但<code>_y</code>存活长于<code>x</code>(<code>_y</code>先于<code>x</code>声明)。</p>
<p>但程序员若不查看函数体的代码，又怎么知道<code>create_s</code>函数将参数的引用对象作为返回存储了？让我们看看下面的有效程序，它和上面这个类似，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In some library code:</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">	_b: <span class="type">bool</span>,</span><br><span class="line">	_ri: &amp;<span class="symbol">&#x27;static</span> <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">create_s</span>(ri: &amp;<span class="type">i32</span>) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">	<span class="keyword">static</span> ZERO: <span class="type">i32</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> ONE: <span class="type">i32</span> = <span class="number">1</span>;</span><br><span class="line">	S &#123;</span><br><span class="line">		_b: <span class="literal">true</span>,</span><br><span class="line">		_ri: <span class="keyword">if</span> *ri &gt; <span class="number">0</span> &#123; &amp;ONE &#125; <span class="keyword">else</span> &#123; &amp;ZERO &#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In application code:</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">_y</span>: S;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i32</span> = <span class="number">12</span>;</span><br><span class="line">	_y = <span class="title function_ invoke__">create_s</span>(&amp;x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中，函数<code>create_s</code>仅是用<code>ri</code>参数来初始化结构体的<code>_ri</code>字段。因此参数的值没有被存储在结构体内。<code>_ri</code>会包含一个静态值，即<code>ZERO</code>或<code>ONE</code>，静态变量不会被销毁。</p>
<p>这里的<code>create_s</code>函数签名虽然和上一个代码一样；但前一个代码是不合法的，因为参数被存储在结构体的字段中，而这里，参数通过<code>*ri</code>使用后，scope就已经结束了，并被回收掉。</p>
<p>因此，如果没有lifetime specifier，编程者被强迫去阅读函数<code>create_s</code>的方法体的内容，这样才能得知该函数是否会存储参数的引用对象。这种设计是糟糕的。</p>
<p>为了让编程者避免需要分析<code>create_s</code>函数来得知对象的声明周期是否合法，有必要有更进一步的生命周期注解(lifetime annotations)。</p>
<p>因此，类似于函数，仅是对于结构体函数，必须显式指定它们字段的每个引用的生命周期。</p>
<p>这解析了上面代码中，形式上看起来是有效的代码片段，实际上会产生“missing lifetime specifier”的编译错误。</p>
<h2 id="Possible-Lifetime-Specifiers-for-Structs"><a class="header-anchor" href="#Possible-Lifetime-Specifiers-for-Structs">¶</a>Possible Lifetime Specifiers for Structs</h2>
<p>实际上，对于一个结构体的引用字段的生命周期，Rust编译器仅允许两种可能：</p>
<ul>
<li>该字段仅指向静态对象(static objects)。</li>
<li>或者指向的对象，虽然不是静态的，但预先存在整个结构体对象中，并且存活长于该结构体。</li>
</ul>
<p>第一种情况已经介绍过，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123; _b: <span class="type">bool</span>, _ri: &amp;<span class="symbol">&#x27;static</span> <span class="type">i32</span> &#125;</span><br></pre></td></tr></table></figure>
<p>该结构体包含有一个引用，不过它是<code>'static</code>引用，所以该引用不能被指派给任何租借的引用值。因此不会有生命周期的讨论问题，只要<code>_ri</code>字段被分配的是静态引用。</p>
<p>相反，对于第二种情况，下面有效代码阐述，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In some library code:</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">s</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123; _b: <span class="type">bool</span>, _ri: &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span> &#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">create_s</span>&lt;<span class="symbol">&#x27;b</span>&gt;(ri: &amp;<span class="symbol">&#x27;b</span> <span class="type">i32</span>) <span class="punctuation">-&gt;</span> S&lt;<span class="symbol">&#x27;b</span>&gt; &#123;</span><br><span class="line">	s&#123; _b: <span class="literal">true</span>, _ri: ri &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// In application code:</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i32</span> = <span class="number">12</span>;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">_y</span>: S;</span><br><span class="line">	_y = <span class="title function_ invoke__">create_s</span>(&amp;x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里变量<code>x</code>的值被<code>create_s</code>函数租借以及持久化。实际上，它被存储在结构对象的返回字段<code>_ri</code>中；该对象在<code>main</code>函数中被用于初始化变量<code>_y</code>。因此，变量<code>_y</code>必须存活少于<code>x</code>。若将<code>let _y: S;</code>移到<code>x</code>前面，先于<code>x</code>声明，会产生错误“<code>x</code> does not live long enough”。</p>
<p>要判断<code>_x</code>是否被存储在结构体内部，不需要检查<code>create_s</code>函数体内部实现，也不需要检查结构体<code>S</code>的字段；检查<code>create_s</code>和<code>S</code>的函数签名足够了。</p>
<p>通过检查<code>create_s</code>函数签名，发现引用参数的生命周期指示器，和返回值<code>S</code>类型的引用指示器是同一个<code>'b</code>。这意味着返回的结构体必须存活长于租借的<code>i32</code>类型的对象。</p>
<p>通过检查结构体<code>S</code>的签名，发现它由一个lifetime specifier参数化，也意味着相关的某个字段不会是<code>'static</code>的引用。</p>
<p>因此，我们发现<code>create_s</code>函数是通过同一个lifetime specifier，获取参数的引用和参数化的(parameterized返回对象。这表示返回的引用的对象，可能租借自引用参数。</p>
<p>编译器必须分别检测结构声明的一致性。<code>struct S&lt;'a&gt;</code>表示<code>S</code>租借了某些对象，而结构体内的<code>_ri: &amp;'a i32</code>表示<code>_ri</code>字段是一个引用租借了一个对象。</p>
<p>因此，包含有引用字段的结构体，仅允许两种合法语法：“<code>field: &amp;'static type</code>” 或 “<code>field: &amp;'lifetime type</code>”，其中<code>lifetime</code>也是结构体自身的一个参数。如果结构体不包含引用字段或仅会出现静态引用字段，结构体可以不需要声明周期参数。</p>
<p>由于仅包含一个参数，所以可以通过lifetime elision由其隐式推断，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">create_s</span>(ri: &amp; <span class="type">i32</span>) <span class="punctuation">-&gt;</span> S &#123;</span><br><span class="line">	S&#123; _b: <span class="literal">true</span>, _ri: ri &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，可能会有几种的语法错误情况，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_S1</span> &#123; _f: &amp;<span class="type">i32</span> &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_S2</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123; _f: &amp;<span class="type">i32</span> &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_S3</span> &#123; _f: &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span> &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_S4</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123; _f: &amp;<span class="symbol">&#x27;static</span> <span class="type">i32</span> &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_S5</span> &#123; _f: &amp;<span class="symbol">&#x27;static</span> <span class="type">i32</span> &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_S6</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123; _f: &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span> &#125;</span><br></pre></td></tr></table></figure>
<p>第一条和第四条语句是不合法的。<code>_S1</code>和<code>_S2</code>的声明是不合法的，因为<code>_f</code>字段是一个引用字段，没有lifetime specifier。</p>
<p><code>_S3</code>的声明是不合法的，因为生命周期指示器<code>'a</code>没有作为<code>S</code>的一个参数。</p>
<p><code>_S4</code>的声明是不合法的，因为参数<code>'a</code>没用被用于结构体内。</p>
<p>相反，最后两个结构体的声明是有效的。<code>_S5</code>包含一个静态对象引用。而<code>_S6</code>包含包含的引用总是存活长于结构体自身。</p>
<h2 id="Other-Uses-of-Lifetime-Specifiers"><a class="header-anchor" href="#Other-Uses-of-Lifetime-Specifiers">¶</a>Other Uses of Lifetime Specifiers</h2>
<p>我们知道，当定义一个包含引用的结构体类型时，生命周期指示器是必要的。对于元组-结构体类型也一样。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TS</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="type">u8</span>);</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">E</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt; &#123;</span><br><span class="line">    _A(&amp;<span class="symbol">&#x27;a</span> <span class="type">u8</span>),</span><br><span class="line">    _B,</span><br><span class="line">    _C(<span class="type">bool</span>, &amp;<span class="symbol">&#x27;b</span> <span class="type">f64</span>, <span class="type">char</span>),</span><br><span class="line">    _D(&amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">byte</span> = <span class="number">34</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_ts</span> = <span class="title function_ invoke__">TS</span>(&amp;byte);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_e</span> = E::_A(&amp;byte);</span><br></pre></td></tr></table></figure>
<p>这段代码是有效的，以及移除任何一个lifetime specifier，都会产生“missing lifetime specifier”错误。</p>
<p>顺带一下，注意<code>E::_D</code>字段的定义。它是一个static string slice 引用。它们是 <strong>字符串字面量(string literals)</strong>。</p>
<p>为了简化，我们从不在可变引用中混入指示器。实际上，它是被允许的，虽然很另类，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>&lt;<span class="symbol">&#x27;a</span>&gt;(b: &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">u8</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">u8</span> &#123;</span><br><span class="line">    *b += <span class="number">1</span>;</span><br><span class="line">    b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">byte</span> = <span class="number">12u8</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">byte_ref</span> = <span class="title function_ invoke__">f</span>(&amp;<span class="keyword">mut</span> byte);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, *byte_ref);</span><br></pre></td></tr></table></figure>
<p>结果将会打印：“13”。一个指向byte的可变引用被作为参数传递给<code>f</code>，以及递增之后作为返回值。通常对于一个可变参数来说，传递给函数后没必要返回它租借的引用的，因为<code>byte_ref</code>和<code>byte</code>都是指向同一个内存对象。</p>
<p>前面看过了，类型参数和生命周期指示器可以参数化使用，它们也可以用于同一个函数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>&lt;<span class="symbol">&#x27;a</span>, T&gt;(b: &amp;<span class="symbol">&#x27;a</span> T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> T &#123; b &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">pi</span> = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">pi_ref</span> = <span class="title function_ invoke__">f</span>(&amp;pi);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, *pi_ref);</span><br></pre></td></tr></table></figure>
<p>结果将会打印：“3.14”。</p>
<p>下面是不合法的，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123; b: &amp;<span class="symbol">&#x27;a</span> T&#125;</span><br></pre></td></tr></table></figure>
<p>编译器出现“the parameter type <code>T</code> may not live long enough”。这是因为泛型类型<code>T</code>被具现化时，它的类型可能会包含一个引用，这种引用可能会导致声明周期错误。处于保护机制，编译器禁止这种语法。实际上有两种情况：</p>
<ul>
<li><code>T</code>所表示的类型不包含引用，或仅包含静态对象的引用。</li>
<li><code>T</code>所表示的类型包含non-static对象的引用，它的生命周期需要指定。</li>
</ul>
<p>第一种情况类似于，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>&lt;<span class="symbol">&#x27;a</span>, T: <span class="symbol">&#x27;static</span>&gt; &#123; b: &amp;<span class="symbol">&#x27;a</span> T &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = S &#123; b: &amp;<span class="literal">true</span> &#125;;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, *s.b);</span><br></pre></td></tr></table></figure>
<p>第二种情况类似于，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>&lt;<span class="symbol">&#x27;a</span>, T: <span class="symbol">&#x27;a</span>&gt; &#123; b: &amp;<span class="symbol">&#x27;a</span> T &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = S &#123; b: &amp;<span class="literal">true</span> &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = S &#123; b: &amp;s1 &#125;;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, *s1.b, *s2.b.b);</span><br></pre></td></tr></table></figure>
<p>在第一行，<code>T</code>类型参数被界限在<code>'a</code>，意味着不管这个类型是什么，会包含一个引用，并租借这个lifetime specifier注解的对象，即整个结构对象自己。</p>
<p>在第二行，<code>S</code>结构体被<code>bool</code>初始化。实际上，原生类型不包含任何引用，所以这里用<code>'static</code>限界即可。</p>
<p>对于第三行，<code>S</code>结构体由<code>S&lt;bool&gt;</code>初始化。该类型包含一个non-static引用，用<code>'a</code>限界。</p>
</div></article><nav class="article-nav"><div class="article-nav-prev"><a href="/2023/10/26/termius/cracked/">Termius Cracked</a></div><div class="article-nav-next"><a href="/2023/01/22/rust/beginning/chapter22_Borrowing%20and%20Lifetimes/">rust基础入门[22] - Borrowing and Lifetimes</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2023/01/23/rust/beginning/chapter23_More About Lifetimes/';
var disqus_title = 'rust基础入门[23] - More About Lifetimes';
var disqus_url = 'https://galudisu.info/2023/01/23/rust/beginning/chapter23_More About Lifetimes/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>