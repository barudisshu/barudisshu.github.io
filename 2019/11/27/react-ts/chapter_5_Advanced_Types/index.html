<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>第五章 高级类型</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/maths/">Maths</a></li><li class="menu-item"><a class="menu-link" href="/projects/">Projects</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/maths/">Maths</a></li><li class="menu-item"><a class="menu-link" href="/projects/">Projects</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">第五章 高级类型</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2019-11-27</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tags"> </i><a class="tag-link" href="/tags/react/">react<span class="tag">, </span></a><a class="tag-link" href="/tags/typescript/">typescript</a></p><p class="meta-item meta-category"><span class="meta-item-title"></span><i class="icon-bookmark"> </i><a class="category-link" href="/categories/react/">react</a></p></div><div class="article-content"><ul>
<li>Union Types</li>
<li>Type guards</li>
<li>Generics</li>
<li>Overload signatures</li>
<li>Lookup and mapped types</li>
</ul>
<h2 id="Union-types"><a class="header-anchor" href="#Union-types">¶</a>Union types</h2>
<p>顾名思义，联合类型就是将类型组合的一种形式。</p>
<h3 id="String-literal-types"><a class="header-anchor" href="#String-literal-types">¶</a>String literal types</h3>
<p>字符串字面量类型，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Control</span> = <span class="string">&quot;Textbox&quot;</span></span><br></pre></td></tr></table></figure>
<p>这个类型的值仅能是<code>&quot;Textbox&quot;</code>，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notes</span>: <span class="title class_">Control</span>;</span><br><span class="line">notes = <span class="string">&quot;Textbox&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>用其它值表示则会报错，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notes = <span class="string">&quot;DropDown&quot;</span>;		<span class="comment">// &quot;DropDown&quot; is not assignable to type &quot;Textbox&quot;</span></span><br></pre></td></tr></table></figure>
<p>和其它TypeScript类型一样，<code>null</code>和<code>undefined</code>是有效的值，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">notes = <span class="literal">null</span>;</span><br><span class="line">notes = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>
<p>字符串字面量类型自身没有多大用处，它的用处在于结合到联合类型中。</p>
<h3 id="String-literal-union-types"><a class="header-anchor" href="#String-literal-union-types">¶</a>String literal union types</h3>
<p>字符串字面量联合类型就是将多个字符串字面类型组合在一起。例如，将原先的<code>Control</code>类型增强为联合类型，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Control</span> = <span class="string">&quot;Textbox&quot;</span> | <span class="string">&quot;DropDown&quot;</span></span><br></pre></td></tr></table></figure>
<p>设置值为二选一，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notes</span>: <span class="title class_">Control</span>;</span><br><span class="line">notes = <span class="string">&quot;Textbox&quot;</span>;</span><br><span class="line">notes = <span class="string">&quot;DropDown&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>扩展更多的字面量，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Control</span> = <span class="string">&quot;Textbox&quot;</span> | <span class="string">&quot;DropDown&quot;</span> | <span class="string">&quot;DatePicker&quot;</span> | <span class="string">&quot;NumberSlider&quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Discriminated-union-pattern"><a class="header-anchor" href="#Discriminated-union-pattern">¶</a>Discriminated union pattern</h3>
<p>区分联合模式(discriminated union pattern)允许我们从不同联合类型中处理逻辑，以一个例子说明，</p>
<ol>
<li>首先创建三个不同的接口分别表示textbox、date picker、number slider，</li>
</ol>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ITextbox</span> &#123;</span><br><span class="line">	<span class="attr">control</span>: <span class="string">&quot;TextBox&quot;</span>;</span><br><span class="line">	<span class="attr">value</span>: <span class="built_in">string</span>;</span><br><span class="line">	<span class="attr">multiline</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IDatePicker</span> &#123;</span><br><span class="line">	<span class="attr">control</span>: <span class="string">&quot;DatePicker&quot;</span>;</span><br><span class="line">	<span class="attr">value</span>: <span class="title class_">Date</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">INumberSlider</span> &#123;</span><br><span class="line">	<span class="attr">control</span>: <span class="string">&quot;NumberSlider&quot;</span>;</span><br><span class="line">	<span class="attr">value</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它们都有一个属性<code>control</code>，会成为模式的判别准则，</p>
<ol start="2">
<li>我们将这些接口组合成为一个联合类型叫做<code>Field</code>，</li>
</ol>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Field</span> = <span class="title class_">ITextbox</span> | <span class="title class_">IDatePicker</span> | <span class="title class_">INumberSlider</span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>接着创建一个函数来初始化<code>Field</code>类型的值，</li>
</ol>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">intializeValue</span>(<span class="params"><span class="attr">field</span>: <span class="title class_">Field</span></span>) &#123;</span><br><span class="line">	<span class="keyword">switch</span> (field.<span class="property">control</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;Textbox&quot;</span>:</span><br><span class="line">			field.<span class="property">value</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;DatePicker&quot;</span>:</span><br><span class="line">			field.<span class="property">value</span> = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;NumberSlier&quot;</span>:</span><br><span class="line">			filed.<span class="property">value</span> = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="attr">default</span>:</span><br><span class="line">			<span class="keyword">const</span> <span class="attr">shouldNotReach</span>: <span class="built_in">never</span> = field;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化值的设置取决于这个区分属性<code>control</code>。因此我们需要使用<code>switch</code>语句进行分岔处理。</p>
<p>其中<code>default</code>分支在<code>switch</code>语句中应该从不达到，对于不可达语句，使用<code>never</code>类型表述。</p>
<ol start="4">
<li>随着时间的推移，新增了一个checkbox字段需求，接着实现这个接口，</li>
</ol>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ICheckbox</span> &#123;</span><br><span class="line">	<span class="attr">control</span>: <span class="string">&quot;Checkbox&quot;</span>;</span><br><span class="line">	<span class="attr">value</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>将这个field添加到联合<code>Field</code>类型中，</li>
</ol>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Field</span> = <span class="title class_">ITextbox</span> | <span class="title class_">IDatePicker</span> | <span class="title class_">INumberSlider</span> | <span class="title class_">ICheckbox</span>;</span><br></pre></td></tr></table></figure>
<p>我们将会立即看到<code>initializeValue</code>函数在<code>never</code>声明中抛出编译错误，</p>
<ol start="6">
<li>增加一个分支即可，</li>
</ol>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">intializeValue</span>(<span class="params"><span class="attr">field</span>: <span class="title class_">Field</span></span>) &#123;</span><br><span class="line"><span class="keyword">switch</span> (field.<span class="property">control</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;Textbox&quot;</span>:</span><br><span class="line">field.<span class="property">value</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;DatePicker&quot;</span>:</span><br><span class="line">field.<span class="property">value</span> = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;NumberSlider&quot;</span>:</span><br><span class="line">field.<span class="property">value</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;Checkbox&quot;</span>:</span><br><span class="line">field.<span class="property">value</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="attr">default</span>:</span><br><span class="line"><span class="keyword">const</span> <span class="attr">shouldNotReach</span>: <span class="built_in">never</span> = field;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，联合类型允许我们组合任何类型成为另外一种类型。</p>
<h2 id="Type-guards"><a class="header-anchor" href="#Type-guards">¶</a>Type guards</h2>
<p>类型守卫，允许我们在一个代码条件分支上缩小一个对象的具体类型。对于联合类型来说可以在代码分支对不同具体类型进行处理。</p>
<p>例如上面的<code>intializeValue</code>函数，通过<code>switch</code>语句控制分支<code>control</code>来对不同设值类型进行处理。</p>
<p>下面介绍另外一种不同的方式。</p>
<h3 id="Using-the-typeof-keyword"><a class="header-anchor" href="#Using-the-typeof-keyword">¶</a>Using the typeof keyword</h3>
<p><code>typeof</code>关键字是JavaScript的关键字，它会返回改类型的一个字符串。因此可以使用它缩小类型。</p>
<p>例如，有一个包含字符串和一个字符串数组的类型，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">StringOrStringArray</span> = <span class="built_in">string</span> | <span class="built_in">string</span>[];</span><br></pre></td></tr></table></figure>
<p>我们需要实现一个<code>first</code>的函数，它接收类型为<code>StringOrStringArray</code>的参数并返回一个字符串，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">first</span>(<span class="params"><span class="attr">stringOrArray</span>: <span class="title class_">StringOrStringArray</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求函数，如果是一个字符串，则返回第一个字符，如果是一个字符串数组则返回数组第一个元素，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">first</span>(<span class="params"><span class="attr">stringOrArray</span>: <span class="title class_">StringOrStringArray</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> stringOrArray === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> stringOrArray.<span class="title function_">substr</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> stringOrArray[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检测是否生效，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">first</span>(<span class="string">&quot;The&quot;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">first</span>([<span class="string">&quot;The&quot;</span>, <span class="string">&quot;cat&quot;</span>]));</span><br></pre></td></tr></table></figure>
<p>因为<code>typeof</code>关键字仅能被用于JavaScript类型。为了说明这一点，对原来的函数做了增强。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">firstEnhanced</span>(<span class="params"><span class="attr">stringOrArray</span>: <span class="title class_">StringOrStringArray</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> stringOrArray === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> stringOrArray.<span class="title function_">substr</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> stringOrArray === <span class="string">&quot;string[]&quot;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> stringOrArray[<span class="number">0</span>];</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="attr">shouldNotReach</span>: <span class="built_in">never</span> = stringOrArray;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时TypeScript编译器在第二个分支报错，<code>typeof</code>关键字仅作用于JavaScript类型，即<code>string</code>、<code>number</code>、<code>boolean</code>、<code>symbol</code>、<code>undefined</code>、<code>object</code>以及<code>function</code>；错误信息告诉我们<code>string[]</code>类型和JavaScript的类型<code>object</code>重合了，因此第二个分支实际上返回的是<code>object</code>。</p>
<p>修改为，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">firstEnhanced</span>(<span class="params"><span class="attr">stringOrArray</span>: <span class="title class_">StringOrStringArray</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> stringOrArray === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> stringOrArray.<span class="title function_">substr</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> stringOrArray === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> stringOrArray[<span class="number">0</span>];</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="attr">shouldNotReach</span>: <span class="built_in">never</span> = stringOrArray;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，<code>typeof</code>对于JavaScript类型是良好的，但对于TypeScript的具体类型却无从入手。</p>
<h3 id="Using-the-instanceof-keyword"><a class="header-anchor" href="#Using-the-instanceof-keyword">¶</a>Using the instanceof keyword</h3>
<p><code>instanceof</code>关键字还是JavaScript的，典型地被用于决定一个对象是否是某个类的实例。</p>
<p>例如，有两个类<code>Person</code>和<code>Company</code>，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">	<span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">	<span class="attr">surname</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">company</span> &#123;</span><br><span class="line">	<span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及定义一个联合类型，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PersonOrCompany</span> = <span class="title class_">Person</span> | <span class="title class_">Company</span>;</span><br></pre></td></tr></table></figure>
<p>现在编写一个函数，接收一个<code>Person</code>或<code>Company</code>，并输出名字到控制台，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logName</span>(<span class="params"><span class="attr">personOrCompany</span>: <span class="title class_">PersonOrCompany</span></span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (personOrCompany <span class="keyword">instanceof</span> <span class="title class_">Person</span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;personOrCompany.firstName&#125;</span> <span class="subst">$&#123;personOrCompany.surname&#125;</span>`</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(personOrCompany.<span class="property">name</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>instanceof</code>虽然缩小了类的类型，但它仍然是JavaScript类型，有许多TypeScript类型不能处理。</p>
<h3 id="Using-the-in-keyword"><a class="header-anchor" href="#Using-the-in-keyword">¶</a>Using the in keyword</h3>
<p><code>in</code>关键字是另外一个JavaScript关键字，被用于检测一个属性是否是一个对象。</p>
<p>例如，取代原来类的定义，使用接口对<code>Person</code>和<code>Company</code>进行声明，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">	<span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">	<span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">	<span class="attr">surname</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ICompany</span> &#123;</span><br><span class="line">	<span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及创建一个联合类型，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PersonOrCompany</span> = <span class="title class_">IPerson</span> | <span class="title class_">ICompany</span>;</span><br></pre></td></tr></table></figure>
<p>重写原来的方法，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logName</span>(<span class="params"><span class="attr">personOrCompany</span>: <span class="title class_">PersonOrCompany</span></span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="string">&quot;firstName&quot;</span> <span class="keyword">in</span> personOrCompany) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;personOrCompany.firstName&#125;</span> <span class="subst">$&#123;personOrCompany.surname&#125;</span>`</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(personOrCompany.<span class="property">name</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>in</code>关键字比较灵活，可以被用于任何对象类型。</p>
<h3 id="Using-a-user-defined-type-guard"><a class="header-anchor" href="#Using-a-user-defined-type-guard">¶</a>Using a user-defined type guard</h3>
<p>自定义类型守卫，这部分属于TypeScript3特性，改写原来的代码，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">	<span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">	<span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">	<span class="attr">surname</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ICompany</span> &#123;</span><br><span class="line">	<span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PersonOrCompany</span> = <span class="title class_">IPerson</span> | <span class="title class_">ICompany</span>;</span><br></pre></td></tr></table></figure>
<p>然后实现类型守卫函数，返回boolean，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPerson</span>(<span class="params"><span class="attr">personOrCompany</span>: <span class="title class_">PersonOrCompany</span></span>): personOrCompany is <span class="title class_">IPerson</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;firstName&quot;</span> <span class="keyword">in</span> personOrCompany;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Generics"><a class="header-anchor" href="#Generics">¶</a>Generics</h2>
<p>泛型可以作用于一个函数或类中。</p>
<h3 id="Generic-functions"><a class="header-anchor" href="#Generic-functions">¶</a>Generic functions</h3>
<p>下面通过一个例子描述泛型函数。我们将创建一个包装函数围绕<code>fetch</code>函数获取web servcie的数据，</p>
<ol>
<li>首先创建函数的方法签名，</li>
</ol>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getData&lt;T&gt;(<span class="attr">url</span>: <span class="built_in">string</span>): <span class="title class_">Promise</span>&lt;T&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要转变为arrow function的形式，我们可以…</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getData = &lt;T&gt;(<span class="attr">url</span>: <span class="built_in">string</span>): <span class="title class_">Promise</span>&lt;T&gt; =&gt; &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>现在让我们实现我们的函数，</li>
</ol>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getData&lt;T&gt;(<span class="attr">url</span>: <span class="built_in">string</span>): <span class="title class_">Promise</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">fetch</span>(url).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(response.<span class="property">statusText</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>最后，消费这个函数，</li>
</ol>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">	<span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getData&lt;<span class="title class_">IPerson</span>&gt;(<span class="string">&quot;/people/1&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">person</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(person));</span><br></pre></td></tr></table></figure>
<h3 id="Generic-classes"><a class="header-anchor" href="#Generic-classes">¶</a>Generic classes</h3>
<p>泛型类，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">List</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="attr">data</span>: T[] = [];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">getList</span>(): T[] &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">add</span>(<span class="params"><span class="attr">item</span>: T</span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">push</span>(item);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">remove</span>(<span class="params"><span class="attr">item</span>: T</span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">data</span> = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">filter</span>(<span class="attr">dataItem</span>: T) =&gt; &#123;</span><br><span class="line">			<span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="title function_">equals</span>(item, dataItem);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">equals</span>(<span class="params"><span class="attr">obj1</span>: T, <span class="attr">obj2</span>: T</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj1).<span class="title function_">every</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> obj1[key] === obj2[key];</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建对应的消费接口，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">	<span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">billy</span>: <span class="title class_">IPerson</span> = &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;Billy&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>然后创建一个泛型类实例，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> <span class="title class_">List</span>&lt;<span class="title class_">IPerson</span>&gt;();</span><br></pre></td></tr></table></figure>
<p>调用泛型方法，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">people.<span class="title function_">add</span>(billy);</span><br><span class="line">people.<span class="title function_">remove</span>(billy);</span><br></pre></td></tr></table></figure>
<p>获取条目信息，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = people.<span class="title function_">getList</span>();</span><br></pre></td></tr></table></figure>
<p>其中<code>React.Component</code>包含有两个泛型参数，分别是props和state。</p>
<h2 id="Overload-signatures"><a class="header-anchor" href="#Overload-signatures">¶</a>Overload signatures</h2>
<p>方法签名重载。</p>
<p>首先有两个函数，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">condenseString</span>(<span class="params"><span class="attr">string</span>: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">string</span>.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>).<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">condenseArray</span>(<span class="params"><span class="attr">array</span>: <span class="built_in">string</span>[]</span>): <span class="built_in">string</span>[] &#123;</span><br><span class="line">	<span class="keyword">return</span> array.<span class="title function_">map</span>(item -&gt; item.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>).<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在将这两个函数组合为一个函数。我们可以使用联合类型，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">condense</span>(<span class="params"><span class="attr">stringOrArray</span>: <span class="built_in">string</span> | <span class="built_in">string</span>[]</span>): <span class="built_in">string</span>| <span class="built_in">string</span>[] &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">typeof</span> stringOrArray === <span class="string">&quot;string&quot;</span> ? stringOrArray.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>).<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>) : stringOrArray.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>).<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用该函数，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> condensedText = <span class="title function_">condense</span>(<span class="string">&quot;the cat sat on the mat&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如果我们将鼠标放在<code>condensedText</code>上，我们会发现它是个联合类型，</p>
<p>现在添加两个重载的方法签名，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">condense</span>(<span class="params"><span class="attr">string</span>: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">condense</span>(<span class="params"><span class="attr">array</span>: <span class="built_in">string</span>[]</span>): <span class="built_in">string</span>[];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">condense</span>(<span class="params"><span class="attr">stringOrArray</span>: <span class="built_in">string</span> | <span class="built_in">string</span>[]</span>): <span class="built_in">string</span> | <span class="built_in">string</span>[] &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>再次消费重载的函数，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moreCondensedText = <span class="title function_">condense</span>(<span class="string">&quot;The cat sat on the mat&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>将鼠标悬浮在<code>moreCondensedText</code>上，可以得到一个更好的确定类型是<code>string</code>。可以看到重载方法签名可以得到更好的类型推断。</p>
<h2 id="Lookup-and-mapped-types"><a class="header-anchor" href="#Lookup-and-mapped-types">¶</a>Lookup and mapped types</h2>
<p>TypeScript中提供了一个关键字<code>keyof</code>用于为一个对象中的所有属性创建联合类型。这种被创建的类型被称为查询类型(lookup type)。它允许我们基于已有的类型的属性，动态地创建类型。</p>
<p>以一个例子为例，我们有下面这些接口，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">	<span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后使用关键字<code>keyof</code>创建该接口的查询类型(lookup type)，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PersonProps</span> = keyof <span class="title class_">IPerson</span>;</span><br></pre></td></tr></table></figure>
<p>如果将光标悬浮在<code>PersonProps</code>类型上，我们可以看到它是个联合类型，包含<code>&quot;id&quot;</code>和<code>&quot;name&quot;</code>属性，</p>
<p>在原来的<code>IPerson</code>上添加一个新的属性，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">	<span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">	<span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在<code>PersonProps</code>类型包含了一个新的扩展属性<code>&quot;age&quot;</code>，</p>
<p>因此<code>PersonProps</code>类型是个lookup type，顾名思义它总是会查询它需要的字面量。</p>
<p>接下来我们看看这种查询类型的某些有用的地方，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Field</span> &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">	<span class="attr">label</span>: <span class="built_in">string</span>;</span><br><span class="line">	<span class="attr">defaultValue</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这仅是开始，我们可以让<code>name</code>属性更强，并使原来的类是个泛型类，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Field</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; &#123;</span><br><span class="line">	<span class="attr">name</span>: K,</span><br><span class="line">	<span class="attr">label</span>: <span class="built_in">string</span>;</span><br><span class="line">	<span class="attr">defaultValue</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在该类创建了两个泛型参数。第一个泛型参数是对象类型，第二个是对象类型的属性类型。</p>
<p>然后我们创建这个类的实例，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">idField</span>: <span class="title class_">Field</span>&lt;<span class="title class_">IPerson</span>, <span class="string">&quot;id&quot;</span>&gt; = <span class="keyword">new</span> <span class="title class_">Field</span>();</span><br></pre></td></tr></table></figure>
<p>尝试引用不存在于<code>IPerson</code>的属性会发生报错，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">addressField</span>: <span class="title class_">Field</span>&lt;<span class="title class_">IPerson</span>, <span class="string">&quot;address&quot;</span>&gt; = <span class="keyword">new</span> <span class="title class_">Field</span>();</span><br></pre></td></tr></table></figure>
<p>另外，<code>defaultValue</code>不是类型安全的，譬如可以设置值为字符串，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idField.<span class="property">defaultValue</span> = <span class="string">&quot;2&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>可以改为，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Field</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; &#123;</span><br><span class="line">	<span class="attr">name</span>: K;</span><br><span class="line">	<span class="attr">label</span>: <span class="built_in">string</span>;</span><br><span class="line">	<span class="attr">defaultValue</span>: T[K];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询<code>T[K]</code>的类型，对于<code>idField</code>。它会处理到<code>IPerson</code>的属性<code>id</code>，即<code>number</code>。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idFiled.<span class="property">defaultValue</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>接下来创建一个映射类型。映射类型就是映射已存在类型的属性。</p>
<p>首先创建一个类型，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">	<span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后创建一个只读版本的新类型，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReadonlyPerson</span> = &#123; <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof <span class="title class_">IPerson</span>]: <span class="title class_">IPerson</span>[P] &#125;;</span><br></pre></td></tr></table></figure>
<p>其中重要的是创建这个映射<code>[P in keyof IPerson]</code>。这里将<code>IPerson</code>的所有属性迭代指派给<code>P</code>。因此，这个类型实际上是，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReadonlyPerson</span> = &#123;</span><br><span class="line">	<span class="keyword">readonly</span> <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">	<span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在visual studio code中，它的实际定义会被解析为，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Readonly</span>&lt;T&gt; = &#123;</span><br><span class="line">	<span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以尝试创建我们自己呃泛型映射类型，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Stringify</span>&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]: <span class="built_in">string</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>然后消费我们的映射类型，</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">tim</span>: <span class="title class_">Stringify</span>&lt;<span class="title class_">IPerson</span>&gt; = &#123;</span><br><span class="line">	<span class="attr">id</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&quot;Time&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>映射类型适用于需要从已有的类型创建一个新的类型的场景。在TypeScript中，除了<code>Radonly&lt;T&gt;</code>类型外，还有<code>Partial&lt;T&gt;</code>，它会创建一个所有属性都是optional的映射类型。</p>
</div></article><nav class="article-nav"><div class="article-nav-prev"><a href="/2019/11/27/react-ts/chapter_6_Component_Patterns/">第六章 Component Patterns</a></div><div class="article-nav-next"><a href="/2019/11/27/react-ts/chapter_4_Routing_with_React_Router/">第四章 React Router</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2019/11/27/react-ts/chapter_5_Advanced_Types/';
var disqus_title = '第五章 高级类型';
var disqus_url = 'https://galudisu.info/2019/11/27/react-ts/chapter_5_Advanced_Types/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>