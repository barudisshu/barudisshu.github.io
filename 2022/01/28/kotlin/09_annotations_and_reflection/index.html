<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>注解和反射</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">注解和反射</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2022-01-28</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/kotlin/">kotlin</a></p></div><div class="article-content"><h2 id="主要内容"><a class="header-anchor" href="#主要内容">¶</a>主要内容</h2>
<ol>
<li>注解的使用和定义</li>
<li>基于运行时的反射对类进行自省(introspect)</li>
<li>Kotlin项目的真实例子</li>
</ol>
<p>kotlin的注解的使用和Java极其相同，然而自定义注解类的声明语法却天壤之别。同样地，反射的API结构和Java也类似，但细节却不同。</p>
<span id="more"></span>
<h2 id="Declaring-and-applying-annotations"><a class="header-anchor" href="#Declaring-and-applying-annotations">¶</a>Declaring and applying annotations</h2>
<p>注解允许你以声明的方式关联额外的元数据(metadata)，元数据可以在源文件被编译时，或再运行时被访问。</p>
<h3 id="Applying-annotations"><a class="header-anchor" href="#Applying-annotations">¶</a>Applying annotations</h3>
<p>Kotlin的注解使用方式和Java一样，使用<code>@</code>前缀标识。例如JUnit单元测试，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">  <span class="meta">@Test</span> <span class="function"><span class="keyword">fun</span> <span class="title">testTrue</span><span class="params">()</span></span> &#123;  <span class="comment">// The @Test annotation instructs the JUnit framework to invoke this method as a test.</span></span><br><span class="line">    Assert.assertTrue(<span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个更有趣的例子，让我们看看<code>@Deprecated</code>注解，它在Kotlin中的意义和Java一样，但添加了<code>replaceWith</code>参数进行增强，提供了替换模式让你平滑地过渡到新的API。用法如下，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated(<span class="string">&quot;Use removeAt(index) instead.&quot;</span>, ReplaceWith(<span class="string">&quot;removeAt(index)&quot;</span>))</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">remove</span><span class="params">(index: <span class="type">Int</span>)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>参数由括号中传递，和常规函数一样调用。带这种声明，当你使用到<code>remove</code>函数时，IntelliJ IDEA不仅会告诉你使用替换为<code>removeAt</code>，还支持quick fix选项自动替换。</p>
<p>注解的参数仅能包含如下类型：原生类型(primitive type)、字符串(string)、枚举(enum)、类引用(class reference)、其它注解类、以及数组。注解参数的指定和Java有明显不同：</p>
<ul>
<li>将类指定为入参，类名后带<code>::java</code>。例如，<code>@MyAnnotation(MyClass::class)</code>。</li>
<li>其它注解作为入参，不带<code>@</code>。例如前面的<code>ReplaceWith</code>注解。</li>
<li>数组作为入参，使用<code>arrayOf</code>。例如，<code>@RequestMapping(path = arrayOf(&quot;/foo&quot;, &quot;/bar&quot;))</code>。如果注解是声明在Java中的，参数为<code>value</code>的入参是自动转换的，参数名<code>arrayOf</code>可以声明。</li>
</ul>
<p>注解的参数是依赖于运行时实现的，所以不能引用字面量的属性(property)作为入参。如果要这样做，需要使用<code>const</code>标记，让编译器知道该属性是编译期常量(compile-time const)。例如，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> TEST_TIMEOUT = <span class="number">100L</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test(timeout = TEST_TIMEOUT)</span> <span class="function"><span class="keyword">fun</span> <span class="title">testMethod</span><span class="params">()</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>并且记住，带有<code>const</code>的属性注解必须声明在<code>object</code>对象文件的top-level并且必须初始化其值为原生类型或<code>String</code>类型。如果尝试使用常规的属性作为注解的入参，会出现&quot;Only ‘const val’ can be used in constant expressions&quot;的错误。</p>
<h3 id="Annotation-targets"><a class="header-anchor" href="#Annotation-targets">¶</a>Annotation targets</h3>
<p>多数情况下，Kotlin中的单一的声明对应于Java的多个声明，每个都可以带有注解。例如，Kotlin的属性(Property)对应java的字段(Field)、getter和可能有的带参数的setter。属性声明在第一构造函数会有多于一个的构造参数。因此，有必要指定哪些元素需要被注解。</p>
<p>指定元素被注解使用 <em>use-site target</em> 声明。使用<code>@</code>标记+<code>:</code>+注解名的形式，</p>
<p><img src="/img/kotlin-in-action/chapter10/Figure_10_01.png" alt="Figure 10.1"></p>
<p><code>get</code>触发<code>@Rule</code>的注解于属性的getter方法实现上。</p>
<p>下面看一个使用注解的例子。在JUnit，你可以指定每个测试方法前执行rule。例如，标准的<code>TemporaryFolder</code>rule被用于创建执行测试前的文件或文件夹、以及测试后删除临时文件。</p>
<p>在Java中，指定执行JUnit规则的方法是在声明的字段或方法前注解<code>@Rule</code>。但在Kotlin中，因为不用注解字面量属性<code>folder</code>，如果带上<code>@Rule</code>，会出现JUnit异常：“The <code>@Rule</code> ‘folder’ must be public.”。因为<code>@Rule</code>作用于字段，默认是private的。要作用于getter，你需要显式编写：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasTemFolder</span> &#123;</span><br><span class="line">  <span class="meta">@get:Rule</span>  <span class="comment">// The getter is annotated, not the property</span></span><br><span class="line">  <span class="keyword">val</span> folder = TemporaryFolder()</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">testUsingTempFolder</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> createdFile = folder.newFile(<span class="string">&quot;myfile.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">val</span> createdFolder = folder.newFolder(<span class="string">&quot;subfolder&quot;</span>)</span><br><span class="line">	...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认，使用Java的注解作用一个属性，它作用的是对应的字段。Kotlin允许你声明注解以直接作用于属性。</p>
<p>下面列出了use-site target的支持</p>
<ul>
<li><code>property</code>—— Java注解不能作用于use-site目标。</li>
<li><code>field</code>——属性生成的字段。</li>
<li><code>get</code>——属性的getter。</li>
<li><code>set</code>——属性的getter。</li>
<li><code>receiver</code>——函数或属性的扩展接收参数。</li>
<li><code>param</code>——构造器参数。</li>
<li><code>setparam</code>——属性的setter的参数。</li>
<li><code>delegate</code>——委派属性对应字段存储的委派实例。</li>
<li><code>file</code>——声明在文件中的类所包含的top-level的函数和属性。</li>
</ul>
<p>任何作用于<code>file</code>target的注解，需要放置在文件的top-level，在<code>package</code>之前。最常见的注解就是<code>@JvmName</code>，它用于修改对应类编译后生成的字节类名。例如前面章节的例子，<code>@file:JvmName(&quot;StringFunctions&quot;)</code>。</p>
<p>注意不同于Java，kotlin允许注解作用于任意表达式，不仅仅作用于类或声明函数或类型。最常见的例子是<code>@Supress</code>注解，用于编译器抑制编译器的告警。下面是一个抑制转换检查的例子：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(list: <span class="type">List</span>&lt;*&gt;)</span></span> &#123;</span><br><span class="line">  <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">  <span class="keyword">val</span> strings = list <span class="keyword">as</span> List&lt;String&gt;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意IntelliJ IDEA编辑器可以使用Alt-Enter快捷键快速选择Suppress选项。</p>
<blockquote>
<p><strong>Controlling the Java API with annotations</strong></p>
<p>kotlin提供了大量的注解来控制如何将kotlin的声明编译为Java的字节码以暴露给Java调用方。某些注解替换了Java对应的关键字：例如，<code>@Volatile</code>和<code>@Strictfp</code> 注解直接替换为Java的<code>volatile</code>和<code>strictfp</code>关键字。另外一些则被用于更改kotlin在Java调用方的可见性：</p>
<ul>
<li><code>@JvmName</code> 修改来自kotlin声明所生成的Java方法的方法名和字段名。</li>
<li><code>@JvmStatic</code> 作用于一个对象或伴生对象的方法声明，将其保留为Java的静态方法。</li>
<li><code>@JvmOverloads</code> 指示Kotlin编译器为一个带有默认参数值的函数生成重载方法。</li>
<li><code>@JvmField</code> 作用于一个属性，将其保留为public 的Java字段，而不带getter或setter。</li>
</ul>
</blockquote>
<h3 id="Using-annotations-to-customize-JSON-serialization"><a class="header-anchor" href="#Using-annotations-to-customize-JSON-serialization">¶</a>Using annotations to customize JSON serialization</h3>
<p>注解的一个经典例子是自定义对象序列化。<em>Serialization</em> 是指将一个对象转换为一个二进制或文本以用于存储或在网络传输的一种处理。相反的方式，<em>deserialization</em> ， 反序列化则是将这些表述性转换为一个对象。最常见的形式是序列化JSON。有非常宽广的库用于序列化Java对象为JSON。包括 <a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson">Jackson</a> 和 <a target="_blank" rel="noopener" href="https://github.com/google/gson">GSON</a> 。和其它标准库一样，它们完全兼容Kotlin。</p>
<p>这里我们将讨论纯Kotlin版的序列化库，叫做jKid。它足够小以更容易阅读源码。</p>
<blockquote>
<p><strong>The JKid library source code and exercises</strong></p>
<p><a target="_blank" rel="noopener" href="http://github.com/yole/jkid">JKid</a> 源码有大量值得借鉴的经验。</p>
</blockquote>
<p>让我们以一个最简单的例子开始：序列化和反序列化对象实例<code>Person</code>。将实例传入<code>serialize</code>函数，并返回JSON字符串：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> person = Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">29</span>)</span><br><span class="line">&gt;&gt;&gt; println(serialize(person))</span><br><span class="line">[<span class="string">&quot;age&quot;</span>: <span class="number">29</span>, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>一个对象的JSON表述(representation)包含有键值对：属性名作为key、属性值作为value，例如&quot;age&quot;: 29。</p>
<p>要将JSON表述转换为一个对象，你可以调用<code>deserialize</code>函数：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> json = <span class="string">&quot;&quot;&quot;&#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 29&#125;&quot;&quot;&quot;</span></span><br><span class="line">&gt;&gt;&gt; println(deserialize&lt;Person&gt;(json))</span><br><span class="line">Person(name=Alice, age=<span class="number">29</span>)</span><br></pre></td></tr></table></figure>
<p>当你从JSON数据创建一个实例，你必须显式指定类作为类型参数，因为JSON不知道存储的是什么对象类型。在这里，传递了<code>Person</code>类。</p>
<p>下图描绘了JSON表述和对象实例的等效性。注意序列化的对象可能不仅仅包含原生类型或字符串，也可能包含其它集合类型或对象类。</p>
<p><img src="/img/kotlin-in-action/chapter10/Figure_10_02.png" alt="Figure 10.2"></p>
<p>你可以使用注解来自定义序列化和反序列化。当序列化一个实例为JSON时，默认该库是序列化所有的属性并使用属性名作为keys。注解允许修改它的默认行为。这里将讨论两个注解，<code>@JsonExclude</code>和<code>@JsonName</code>，本章后面会介绍它的实现细节：</p>
<ul>
<li><code>@JsonExclude</code> 注解用于标记属性应该从序列化和反序列化排除。</li>
<li><code>@JsonName</code> 用于指定表述属性的key/value中的key的字符串，不是属性的名字。</li>
</ul>
<p>考虑如下例子：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span> (</span><br><span class="line">  <span class="meta">@JsonName(<span class="string">&quot;alias&quot;</span>)</span> <span class="keyword">val</span> firstName: String,</span><br><span class="line">  <span class="meta">@JsonExclude</span> <span class="keyword">val</span> age: <span class="built_in">Int</span>? = <span class="literal">null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>注解属性<code>firstName</code>的key的值用于表述JSON。注解另一个属性<code>age</code>将其从序列化和反序列化排除。注意你必须指定属性<code>age</code>的一个默认值。否则在反序列化是无法创建<code>Person</code>的一个新的实例。下图是其序列化和发序列化的过程：</p>
<p><img src="/img/kotlin-in-action/chapter10/Figure_10_03.png" alt="Figure 10.3"></p>
<p>你已经看到了JKid的大部分特性：<code>serialize()</code>、<code>deserialize()</code>、<code>@JsonName</code>和<code>@JsonExclude</code>。现在让我们探索其实现，从注解声明开始。</p>
<h3 id="Declaring-annotations"><a class="header-anchor" href="#Declaring-annotations">¶</a>Declaring annotations</h3>
<p>以JKid的注解为例。<code>@JsonExclude</code>注解有最简单的形式，因为它没有任何参数：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">JsonExclude</span></span><br></pre></td></tr></table></figure>
<p>该语法和常规类的声明一样，添加<code>annotation</code>修改器在<code>class</code>关键字之前。因为注解类仅仅被用于定义元数据关联的声明和表达式的结构，它们不能包含任何代码。因此，编译器禁止指定一个注解类的语句体。</p>
<p>对于注解类包含参数的，参数声明在类的第一构造函数：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">JsonName</span>(<span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure>
<p>这里使用了常规的第一构造函数声明语法。关键字<code>val</code>对于一个注解类的所有参数是强制性的(mandatory)。</p>
<p>作为比较，下面是在Java中同样的声明写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> JsonName &#123;</span><br><span class="line">  String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意Java的注解有一个方法叫<code>value</code>，同时kotlin注解有一个属性<code>name</code>。<code>value</code>方法在Java中是特殊的：当你引用注解时，需要为<code>value</code>作用的属性显式地提供名字。另外，在kotlin一个注解作用是对常规构造函数的调用。你可以使用命名参数(named-syntax)的语法显式指定，或者省略它们：<code>@JsonName(name = &quot;first_name&quot;)</code> 等同于 <code>@JsonName(&quot;first_name&quot;)</code>，因为<code>name</code>是<code>JsonName</code>构造函数的第一个参数。如果你需要将Java中声明的注解作用到kotlin的元素，然而，你会被要求对所有参数，使用命名参数(named-syntax)语法；唯一例外的是<code>value</code>，因为kotlin也可以特殊地识别。</p>
<h3 id="Meta-annotations-controlling-how-an-annotation-is-processed"><a class="header-anchor" href="#Meta-annotations-controlling-how-an-annotation-is-processed">¶</a>Meta-annotations: controlling how an annotation is processed</h3>
<p>和Java一样，kotlin的注解也可以被注解。这种注解作用于另外一个注解类的注解，称为 <em>meta-annotations</em> 。编译器定义了几个，它们控制了编译器如何处理注解。其它一些框架也使用了元注解——例如，许多注入型的依赖库使用了元注解来标记该注解是被用于同一类型的不同对象实例。</p>
<p>元注解被定义在标准库，常见的有<code>@Target</code>。JKid中定义的<code>@JsonExclude</code>和<code>JsonName</code>使用了它来指定生效的目标。下面是它如何使用的：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(AnnotationTarget.PROPERTY)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">JsonExclude</span></span><br></pre></td></tr></table></figure>
<p>元注解<code>@Target</code>指定了注解所作用的目标类型。如果你不用它，该注解会作用到所有的声明上。对于JKid来说没任何意义，因为该库仅处理属性注解。</p>
<p>枚举<code>AnnotationTarget</code>列出了一个注解的所有可能的范围。其中包含类、文件、函数、属性、属性访问器、类型、表达式等等。同一目标可以定义多个：<code>@Target(AnnotationTarget.CLASS, AnnotationTarget.METHOD)</code>。</p>
<p>要声明自定义元注解，使用<code>ANNOTATION_CLASS</code>作为它的目标：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@target(AnnotationTarget.ANNOTATION_CLASS)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">BindingAnnotation</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@BindingAnnotation</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">MyBinding</span></span><br></pre></td></tr></table></figure>
<p>注意，你不能使用来自Java的<code>PROPERTY</code>属性；为了令其生效，你可以添加第二个目标<code>AnnotationTarget.FIELD</code>。这种情况下，注解既作用于Kotlin的属性，也作用于Java的字段。</p>
<blockquote>
<p>** The @Retention annotation**</p>
<p>Retention: 持有，存储。<br>
在Java有另外一个重要的元注解：<code>@Retention</code>。使用它可以决定注解是否应该被存储在.class文件中，还是在运行期由反射实现。Java的注解默认由.class文件持有，不允许它们在运行期访问。大部分注解不需要在运行期提供，在Kotlin中的默认行为不同：注解提供<code>RUNTIME</code>持有。因此JKid不会有显式的指定。</p>
</blockquote>
<h3 id="Classes-as-annotation-parameters"><a class="header-anchor" href="#Classes-as-annotation-parameters">¶</a>Classes as annotation parameters</h3>
<p>某些场合需要用到类作为注解参数的情形：从声明的元数据中获得对一个类的引用。在JKid库就有这样的一个注解<code>@DeserializeInterface</code>，在接口层面上控制属性的反序列化。因为接口的实例不能直接创建，在反序列化时需要指定哪个类作为反序列化。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">  <span class="keyword">val</span> name: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">CompanyImpl</span>(<span class="keyword">override</span> <span class="keyword">val</span> name: String): Company</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(</span><br><span class="line">  <span class="keyword">val</span> name: String,</span><br><span class="line">  <span class="meta">@DeserializeInterface(CompanyImpl::class)</span> <span class="keyword">val</span> company: Company</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>JKid从一个<code>Person</code>实例读取内嵌的<code>company</code>对象时，会创建<code>CompanyImpl</code>的反序列化实例并存储在<code>company</code>属性上。为此，需要使用<code>@DeserializeInterface</code>注解来指定反序列化的参数类型<code>CompanyImpl::class</code>。通常，对类型的引用，使用类型后跟<code>::class</code>关键字的形式表述。</p>
<p>下面是它的声明。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="keyword">interface</span> <span class="title class_">DeserializeInterface</span>(<span class="keyword">val</span> targetClass: KClass&lt;<span class="keyword">out</span> Any&gt;)</span><br></pre></td></tr></table></figure>
<p>kotlin中的<code>KClass</code>对应于Java的<code>java.lang.Class</code>类型。它用于持有kotlin类的引用。</p>
<p><code>KClass</code>的类型参数指定了哪些kotlin类可以被引用。例如，<code>CompanyImpl::class</code>有类型<code>KClass&lt;CompanyImpl&gt;</code>，它是注解类型参数的子类型(参考协变性内容)。</p>
<p>![Figure 10.3](/img/kotlin-in-action/chapter10/Figure_10_03.png]</p>
<p>如果<code>KClass&lt;Any&gt;</code>不带<code>out</code>修改器，则不能传递<code>CompanyImpl::class</code>作为一个参数：仅允许传递<code>Any::class</code>。<code>out</code>关键字指定了仅被允许传入继承了<code>Any</code>的类，而不是<code>Any</code>自身。</p>
<h3 id="Generic-classes-as-annotation-parameters"><a class="header-anchor" href="#Generic-classes-as-annotation-parameters">¶</a>Generic classes as annotation parameters</h3>
<p>默认，JKid将非原生类型属性作为内嵌对象进行序列化。不过你可以更改这种行为，提供自定义的序列化逻辑。</p>
<p>注解<code>@CustomSerializer</code>接收一个自定义序列化类作为参数。该序列化类应该实现<code>ValueSerializer</code>接口：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ValueSerializer</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">toJsonValue</span><span class="params">(value: <span class="type">T</span>)</span></span>: Any?</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">fromJsonValue</span><span class="params">(jsonValue: <span class="type">Any</span>?)</span></span>: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设你要对日期进行序列化，并为此创建了<code>DateSerializer</code>，实现了<code>ValueSerializer&lt;Date&gt;</code>接口。下面是如何作用到<code>Person</code>类：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(</span><br><span class="line">  <span class="keyword">val</span> name String, </span><br><span class="line">  <span class="meta">@CustomSerializer(DateSerializer::class)</span> <span class="keyword">val</span> birthDate: Date</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>下面是<code>@CustomSerializer</code>注解的声明，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">CustomSerializer</span>(<span class="keyword">val</span> serializerClass: KClass&lt;<span class="keyword">out</span> ValueSerializer&lt;*&gt;&gt;)</span><br></pre></td></tr></table></figure>
<p>你需要确保注解仅引用了实现了<code>ValueSerializer</code>接口的类。例如，编写<code>@CustomSerializer(Date::class)</code>应该被禁止使用。因为<code>Date</code>并没有实现<code>ValueSerializer</code>接口。</p>
<p><img src="/img/kotlin-in-action/chapter10/Figure_10_05.png" alt="Figure 10.5"></p>
<h2 id="Reflection-introspecting-Kotlin-objects-at-runtime"><a class="header-anchor" href="#Reflection-introspecting-Kotlin-objects-at-runtime">¶</a>Reflection: introspecting Kotlin objects at runtime</h2>
<p>反射是一种在运行时访问对象属性和方法的一种动态方式。</p>
<p>Kotlin对反射提供有两种API处理。一种是Java的标准库中的<code>java.lang.reflect</code>。第二种是Kotlin标准库中的<code>kotlin.reflect</code>。第二种是Java中没有的概念，诸如属性和可空类型。但它不提供对Java反射的综合性替换。另外，kotlin的反射API是基于JVM的，不强制用于kotlin的类，可用于任何基于JVM的语言。</p>
<p><strong>注意</strong>：为了减少平台的运行库的大小，特别是Android，Kotlin的反射API单独分离为一个jar文件，kotlin-reflect.jar。默认不会添加到项目中，你需要自行添加<code>org.jetbrains.ktolin:kotlin-reflect</code>。</p>
<h3 id="The-Kotlin-reflection-API-KClass-KCallable-KFunction-and-KProperty"><a class="header-anchor" href="#The-Kotlin-reflection-API-KClass-KCallable-KFunction-and-KProperty">¶</a>The Kotlin reflection API: KClass, KCallable, KFunction, and KProperty</h3>
<p>Kotlin反射API的主要入口是<code>KClass</code>，代表一个类。<code>KClass</code>对应于<code>java.lang.Class</code>，你可以用它枚举或访问所有在该类的声明、子类等。你可以通过<code>MyClass::class</code>获得一个<code>KClass</code>的实例。要在运行时获得类，首先你可以使用<code>javaClass</code>属性获得它的Java类，等价于<code>java.lang.Object.getClass()</code>。然后再由<code>.kotlin</code>扩展将Java的反射转换为Kotlin的反射：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> person = Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">29</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> kClass = person.javaClass.kotlin  <span class="comment">// Return an instance of KClass&lt;Person&gt;</span></span><br><span class="line">&gt;&gt;&gt; println(kClass.simpleName)</span><br><span class="line">Person</span><br><span class="line">&gt;&gt;&gt; kClass.memberProperties.forEach &#123; println(it.name) &#125;</span><br><span class="line">age</span><br><span class="line">name</span><br></pre></td></tr></table></figure>
<p><code>KClass</code>类包含大量的方法用于访问类的上下文内容：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">KClass</span>&lt;<span class="type">T : Any</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">val</span> simpleName: String?</span><br><span class="line">  <span class="keyword">val</span> qualifiedName: String?</span><br><span class="line">  <span class="keyword">val</span> members: Collection&lt;KCallbale&lt;*&gt;&gt;</span><br><span class="line">  <span class="keyword">val</span> constructors: Collection&lt;KFunction&lt;T&gt;&gt;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>KClass</code>的许多有用的特性，包括前面用的<code>memberProperties</code>，被声明为扩展(extensions)。</p>
<p><code>KCallable</code>是所有函数和属性的超级接口(superinterface)。它声明了<code>call</code>方法，允许你属性的对应函数或getter。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">KCallable</span>&lt;<span class="type">out R</span>&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">(<span class="keyword">vararg</span> args: <span class="type">Any</span>?)</span></span>: R</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的例子证明了如何通过反射用<code>call</code>来调用一个函数：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(x: <span class="type">Int</span>)</span></span> = println(x)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> kFunction = ::foo</span><br><span class="line">&gt;&gt;&gt; kFunction.call(<span class="number">42</span>)</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure>
<p>这个表达式是<code>KFunction</code>类的一个反射的实例。要调用引用的函数，使用<code>KCallable.call</code>方法。在这里，你需要提供唯一的入参，42。如果尝试调用错误数量的参数，譬如<code>kFunction.call</code>，会抛出一个运行时错误：“IllegalArgumentException: Callable expects 1 arguments, but 0 were provided.”。</p>
<p>然而，这个例子可以使用一个更特定的方法来调用函数。<code>:foo</code>表达式的类型是<code>KFunction1&lt;Int, Unit&gt;</code>，包含了有关于参数和返回类型的信息。这里的<code>1</code>表示函数接收一个参数。要从该接口调用函数，使用<code>invoke</code>方法。它接收固定的参数数量，它的参数类型对应于<code>KFunction1</code>接口的类型参数。你也可以直接调用<code>kFunction</code>：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.reflect.KFunction2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span> = x + y</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> kFunction: KFunction2&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>, <span class="built_in">Int</span>&gt; = ::sum</span><br><span class="line">&gt;&gt;&gt; println(kFunction.invoke(<span class="number">1</span>, <span class="number">2</span>) + kFucntion(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="number">10</span></span><br><span class="line">&gt;&gt;&gt; kFunction(<span class="number">1</span>)</span><br><span class="line">ERROR: No value passed <span class="keyword">for</span> parameter <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>现在我们用不正确的参数个数调用了<code>kFunction</code>的<code>invoke</code>方法：不会编译。因此，如果<code>KFunction</code>有一个指定的类型，带有参数和返回类型，更好用<code>invoke</code>方法来使用它。<code>call</code>方法是一个通用的对所有函数的调用方式，但不保证类型安全。</p>
<blockquote>
<p><strong>How and where are KFunctionN defined</strong></p>
<p>诸如<code>KFunction1</code>类型表示函数有不同的参数个数。每个继承<code>KFunction</code>的类型添加一个额外的<code>invoke</code>成员参数。例如，<code>KFunction2</code>声明了<code>operator fun invoke(p1: P1, p2: P2): R</code>。其中<code>R1</code>和<code>R2</code>表示了函数的参数类型，以及<code>R</code>表示返回类型。</p>
<p>这些函数类型是编译生成类型(compiler-generated types)所合成的，以及你不能在<code>kotlin.reflect</code>包里面找到它的声明。意味着你可以为一个任意参数个数的函数使用接口。这种合成类型实现了减少kotlin-runtime.jar的大小以及避免的函数类型参数的<br>
人为限制。</p>
</blockquote>
<p>你也可以在<code>KProperty</code>实例调用<code>call</code>方法，它将调用属性的getter。但属性的接口提供了更合适的值获取方式：<code>get</code>方法。</p>
<p>要访问<code>get</code>方法，你需要使用合适的接口，取决于它如何声明。top-level属性对应于<code>KProperty0</code>接口，有个无参的<code>get</code>方法：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> kProperty = ::counter </span><br><span class="line">&gt;&gt;&gt; kProperty.setter.call(<span class="number">21</span>)  <span class="comment">// Calls a setter through reflection, pasing 21 as an argument</span></span><br><span class="line">&gt;&gt;&gt; println(kProperty.<span class="keyword">get</span>())  <span class="comment">// Obtains a property value by calling &quot;get&quot;</span></span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure>
<p>一个 <em>member property</em> 由<code>KProperty1</code>的一个实例表示，只有一个<code>get</code>方法。要访问它的值，你必须提供对象的实例。下面例子存储了一个属性的变量在<code>memberProperty</code>；然后你调用<code>memberProperty.call(person)</code>来获得属性对应<code>person</code>实例的值。因此如果一个<code>memberProperty</code>引用的是<code>Person</code>类里面的<code>age</code>属性，<code>memberProperty.call(person)</code>则是动态地获取<code>person.age</code>的值：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> person = Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">29</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> memberProperty = Person::age  <span class="comment">// reference to property age</span></span><br><span class="line">&gt;&gt;&gt; pirntln(memberProperty.<span class="keyword">get</span>(person))</span><br><span class="line"><span class="number">29</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>KProperty1</code>是一个泛型类。<code>memberProperty</code>变量的类型是<code>KProperty&lt;Person, Int&gt;</code>，其中第一个参数表示接收类型，第二个参数表示属性类型。因此，你可以调用它的<code>get</code>方法，仅在接收类型正确的情况。调用<code>memberProperty.get(&quot;Alice&quot;)</code>则不能编译。</p>
<p>也要注意，仅能用反射访问那些定义在top-level或类里面的属性，对于函数内部的属性是无法访问。如果你定义一个本地变量<code>x</code>，尝试去获取它的<code>::x</code>引用，将会得到一个编译错误“References to variables aren’t supported yet”。</p>
<p>下图展示了这些接口的层级关系。因为所有声明可以被注解，接口表示运行时的声明，诸如<code>KClass</code>、<code>KFunction</code>以及<code>KParameter</code>，都是继承自<code>KAnnotatedElement</code>。<code>KClass</code>被用于表述类或对象。<code>KProperty</code>被用表述任何属性，对于它的子类，<code>KMutableProperty</code>，表示一个可变属性，即用<code>var</code>声明的。你可以用声明在<code>KProperty</code>和<code>KMutableProperty</code>的特定接口Getter和Setter和属性访问器一起作为函数使用——例如，你需要检索所有它的注解。两个访问器的接口都继承<code>KFunction</code>。为了简化，我们省略了某些特定的诸如<code>KProperty0</code>的接口。</p>
<p><img src="/img/kotlin-in-action/chapter10/Figure_10_06.png" alt="Figure 10.6"></p>
<h3 id="Implementing-object-serialization-using-reflection"><a class="header-anchor" href="#Implementing-object-serialization-using-reflection">¶</a>Implementing object serialization using reflection</h3>
<p>首先，让我们回顾声明在JKid的序列化函数。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">serialize</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: String</span><br></pre></td></tr></table></figure>
<p>该函数接收一个对象并以字符串返回它的JSON表述。它会由一个<code>StringBuilder</code>实例构建JSON。因为它的序列化属性和值将被append到这个<code>StringBuilder</code>对象中。为了使<code>append</code>调用更加简洁，该实现将被放在<code>StringBuilder</code>的扩展函数中。这样，你可以方便地调用<code>append</code>方法而不需要限定：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> StringBuilder.<span class="title">serializeObject</span><span class="params">(x: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">  append(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将一个函数参数转换为一个扩展函数的receiver在kotlin中是一个常规做法。注意<code>serializeObject</code>不继承<code>StringBuilder</code>的API。因为在上下文外部处理操作是无意义的，因此使用<code>private</code>确保它不被其它地方使用。</p>
<p>因此，<code>serialize</code>函数将所有工作委派给了<code>serializeObject</code>来处理：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">serialize</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: String = buildString  &#123; serializeObject(obj) &#125;</span><br></pre></td></tr></table></figure>
<p>前面介绍过，<code>buildString</code>创建一个<code>StringBuilder</code>并以一个lambda对其内容进行填充。这里的内容是<code>serializeObject(obj)</code>。</p>
<p>现在讨论一下序列化函数的行为。默认它会序列化对象的所有属性。原生类型和字符串将被序列化为合适的JSON 数字、布尔值和字符串。集合会被序列化为JSON数组。其它类型的属性将被序列化为内嵌对象。前面讨论到，这种行为可以通过注解来自定义。</p>
<p>下面看其<code>serializeObject</code>的实现，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> StringBuilder.<span class="title">serializeObject</span><span class="params">(obj: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> kClass = obj.javaClass.kotlin  <span class="comment">// Gets the KClass for the object</span></span><br><span class="line">  <span class="keyword">val</span> properties = kClass.memberProperties  <span class="comment">// Get all the properties of the class</span></span><br><span class="line">  </span><br><span class="line">  properties.joinToStringBuilder(</span><br><span class="line">	<span class="keyword">this</span>, prefix = <span class="string">&quot;&#123;&quot;</span>, postfix = <span class="string">&quot;&#125;&quot;</span>) &#123; prop -&gt; </span><br><span class="line">		serializeString(prop.name)  <span class="comment">// Gets the property name</span></span><br><span class="line">		append(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">		serializePropertyValue(prop.<span class="keyword">get</span>(obj))  <span class="comment">// Gets the property value</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的实现清晰：一个接一个地序列化类的每个属性。JSON结果看起来会是：<code>&#123; prop1: value1, prop2: value2 &#125;</code>。函数<code>joinToStringBuilder</code>确保了属性被冒号分隔。并避开了JSON格式的特殊字符。<code>serializePropertyValue</code>函数会检查值是否为原生值，字符串，集合或内嵌对象，对应地序列化其内容。</p>
<p>前面小节讨论过获取<code>KProperty</code>实例的值的方式：<code>get</code>方法。这里，工作在<code>Person::age</code>对成员的引用<code>KProperty1&lt;Person, Int&gt;</code>类型，可以让编译器知道额外的receiver的类型和属性类型。在这个例子，然而，额外的类型是未知的，因为你枚举的一个对象类的所有属性。因此<code>prop</code>变量包含有类型<code>KProperty1&lt;Any, *&gt;</code>，以及<code>prop.get(obj)</code>返回<code>Any</code>类型。你不会得到任何编译期的类型检查，但因为你每次传递获得的属性列表都是一样的，接收类型可以被正确处理。</p>
<h3 id="Customizing-serialization-with-annotations"><a class="header-anchor" href="#Customizing-serialization-with-annotations">¶</a>Customizing serialization with annotations</h3>
<p>前面介绍了一些注解的声明语法，譬如<code>@JsonExclude</code>、<code>@JsonName</code>和<code>@CustomSerializer</code>注解。现在让我们看看这些注解是如何被<code>serializeObject</code>函数处理的。</p>
<p>我们将从<code>@JsonExclude</code>开始。该注解允许你在序列化中排除某些属性。让我们探索下<code>serializeObject</code>如何支持。</p>
<p>回顾一下要获得一个类的所有成员属性，使用<code>KClass</code>实例的<code>memberProperties</code>扩展。但现在任务变得更加复杂：带有<code>@JsonExclude</code>注解的属性需要被过滤掉。让我们看看它如何实现。</p>
<p><code>KAnnotatedElement</code>接口定义了属性<code>annotations</code>，运行期保留(runtime retention)的获取源码所有注解的集合实例。因为<code>KProperty</code>继承自<code>KAnnotatedElement</code>，你可以通过<code>property.annoations</code>访问一个属性的所有注解。</p>
<p>但这里过滤的不是所有注解；需要过滤特定的一个，帮助函数<code>findAnnotation</code>做了这项工作：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> KAnnoatedElement.<span class="title">findAnnotation</span><span class="params">()</span></span>: T? = annoations.filterIsInstance&lt;T&gt;().firstOrNull()</span><br></pre></td></tr></table></figure>
<p><code>findAnnotation</code>返回一个指定入参类型的一个注解实例。<code>reified</code>将类型具现化。</p>
<p>现在可以用<code>findAnnotation</code>和标准库中的<code>filter</code>一起过滤掉<code>@JsonExclude</code>的属性了：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> properties = kClass.memberProperties.filter &#123; it.findAnnotation&lt;JsonExclude&gt;() == <span class="literal">null</span> &#125;</span><br></pre></td></tr></table></figure>
<p>下一个注解是<code>@JsonName</code>。作为提醒，我们重复一下它的声明和用法：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">annoation <span class="keyword">class</span> <span class="title class_">JsonName</span>(<span class="keyword">val</span> name: String)</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(</span><br><span class="line">  <span class="meta">@JsonName(<span class="string">&quot;alias&quot;</span>)</span> <span class="keyword">val</span> firstName: String,</span><br><span class="line">  <span class="keyword">val</span> age: <span class="built_in">Int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>注解里面的name将被用于JSON。使用<code>findAnnotation</code>来处理：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> jsonNameAnn = prop.findAnnoation&lt;JsonName&gt;()  <span class="comment">// Gets an instance of the @JsonName annotation if it exists</span></span><br><span class="line"><span class="keyword">val</span> propName = jsonNameAnn?.name ?: prop.name  <span class="comment">// Gets its &quot;name&quot; argument or uses &quot;prop.name&quot; as a fallback</span></span><br></pre></td></tr></table></figure>
<p>如果一个属性没有被<code>@JsonName</code>注解，那么<code>jsonNameAnn</code>为<code>null</code>，仍然使用<code>prop.name</code>作为JSON序列化的name部分，否则使用指定的name。</p>
<p>下面是其完整实现，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> StringBuilder.<span class="title">serializeObject</span><span class="params">(obj: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">  obj.javaClass.kotlin.memberProperties.filter &#123; it.findAnnotation&lt;JsonExclude&gt;() == <span class="literal">null</span> &#125;</span><br><span class="line">	.joinToStringBuilder(<span class="keyword">this</span>, prefix = <span class="string">&quot;&#123;&quot;</span>, postfix = <span class="string">&quot;&#125;&quot;</span>) &#123;</span><br><span class="line">		serializeProperty(it, obj)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在带有<code>@JsonExclude</code>注解的属性被过滤掉了。并提取了对应序列化属性的逻辑，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> StringBuilder.<span class="title">serializeProperty</span><span class="params">(prop: <span class="type">KProperty1</span>&lt;<span class="type">Any</span>, *&gt;, obj: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> jsonNameAnn = prop.findAnnotation&lt;JsonName&gt;()</span><br><span class="line">  <span class="keyword">val</span> propName = jsonNameAnn?.name ?: prop.name</span><br><span class="line">  serializeString(propName)</span><br><span class="line">  append(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">  </span><br><span class="line">  serializePropertyValue(prop.<span class="keyword">get</span>(obj))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，实现剩余的注解，<code>@CustomSerializer</code>。它的实现基于<code>getSerializer</code>函数。它会返回通过<code>@CustomSerializer</code>注解注册了的<code>ValueSerializer</code>实例。例如，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(</span><br><span class="line">  <span class="keyword">val</span> name: String,</span><br><span class="line">  <span class="meta">@CustomSerializer(DateSerializer::class)</span> <span class="keyword">val</span> birthDate: Date</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>下面是提醒<code>@CustomSerializer</code>注解是如何声明的，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">CustomSerializer</span>(<span class="keyword">val</span> serializerClass: KClass&lt;<span class="keyword">out</span> ValueSerializer&lt;*&gt;&gt;)</span><br></pre></td></tr></table></figure>
<p>以及<code>getSerializer</code>函数的实现，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> KProperty<span class="type">&lt;*&gt;</span> <span class="title">getSerializer</span><span class="params">()</span></span>: ValueSerializer&lt;Any?&gt;? &#123;</span><br><span class="line">  <span class="keyword">val</span> customSerializerAnn = findAnnotation&lt;CustomSerializer&gt;() ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">val</span> serializerClass = customSerializerAnn.serializerClass</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">val</span> valueSerializer = serializerClass.objectInstance ?: serializerClass.createInstance()</span><br><span class="line">  <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">  <span class="keyword">return</span> valueSerializer <span class="keyword">as</span> ValueSerializer&lt;Any?&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它是<code>KProperty</code>的一个扩展函数，因为属性是由方法处理的第一个对象。它调用了<code>findAnnotation</code>函数来获取<code>@CustomSerializer</code>注解的一个实例。参数部分<code>serializerClass</code>指定了需要获取对象实例的类型。</p>
<p>这里最有趣的部分是你可以处理类和对象(kotlin的单例)，通过<code>@CustomSerializer</code>注解获得值。他们都由<code>KClass</code>类表述。不同的是对象拥有非空的<code>objectInstance</code>属性值，用于访问由<code>object</code>创建的单例实例。例如，<code>DateSerializer</code>被声明为一个<code>object</code>，因此它的<code>objectInstance</code>属性被存储哎单例的<code>DateSerializer</code>实例。你可以使用该实例序列化所有对象，但<code>createInstance</code>不能被调用。</p>
<p>如果<code>KClass</code>代表的是常规类，则可以使用<code>createInstance</code>来创建一个新的类实例。该函数类似于<code>java.lang.Class.newInstance</code>。</p>
<p>下面是<code>serializeProperty</code>的最终版本实例：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> StringBuilder.<span class="title">serializeProperty</span><span class="params">(prop: <span class="type">KProperty1</span>&lt;<span class="type">Any</span>, *&gt;, obj: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> name = prop.findAnnotation&lt;JsonName&gt;()?.name ?: prop.name</span><br><span class="line">  serializeString(name)</span><br><span class="line">  append(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">val</span> value = prop.<span class="keyword">get</span>(obj)</span><br><span class="line">  <span class="keyword">val</span> jsonValue = </span><br><span class="line">	prop.getSerializer()?.toJsonValue(value)  <span class="comment">// Uses a custom seralizer for the property if it exists</span></span><br><span class="line">	?: value  <span class="comment">// Otherwise uses the property value as before</span></span><br><span class="line">  serializePropertyValue(jsonValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>serializeProperty</code>使用序列化<code>toJsonValue</code>将属性值转换为JSON兼容格式。如果属性没有自定义<code>toJsonValue</code>，将使用属性值替代。</p>
<h3 id="JSON-parsing-and-object-deserialization"><a class="header-anchor" href="#JSON-parsing-and-object-deserialization">¶</a>JSON parsing and object deserialization</h3>
<p>下面开始第二个环节：实现反序列化逻辑。首先，回顾API，和序列化用法一样，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T: Any&gt;</span> <span class="title">deserialize</span><span class="params">(json: <span class="type">String</span>)</span></span>: T</span><br></pre></td></tr></table></figure>
<p>下面是它的用例：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Author</span>(<span class="keyword">val</span> name: String)</span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Book</span>(<span class="keyword">val</span> title: String, <span class="keyword">val</span> author: Author)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> json = <span class="string">&quot;&quot;&quot;&#123;&quot;title&quot;: &quot;Catch-22&quot;, &quot;author&quot;: &#123;&quot;name&quot;: &quot;J. Heller&quot;&#125;&#125;&quot;&quot;&quot;</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> book = deserialize&lt;Book&gt;(json)</span><br><span class="line">&gt;&gt;&gt; println(book)</span><br><span class="line">Book(title=Catch-<span class="number">22</span>, author=Author(name=J. Heller))</span><br></pre></td></tr></table></figure>
<p>对象的类型作为一个reified类型参数传递给反序列化函数<code>deserialize</code>进行反序列化，并返回一个新的对象实例。</p>
<p>JSON的反序列化比序列化更加难实现。因为它涉及到JSON字符串输入额外使用反射访问对象内部。JKid的JSON反序列化完全以惯例约定的方式考量：词法分析，通常认为是一个 <em>lexer</em> ；语法解析 <em>parser</em> ；以及反序列组件自身。</p>
<p>词法分析过程将输入字符串分解为若干的token。包括两种token：<em>character token</em> ，代表了JSON语法的特殊意义(逗号、冒号、中括号和花括号)；<em>value token</em> ，代表了对应的字符串、数字、布尔、以及<code>null</code>常量。一个左花括号({)，一个字符串值(“Catch-22”)，和一个整型值(22)代表不同的token信息。</p>
<p>语法解析通常职责是用于将一些了的token转换为相应的数据结构。在JKid中为了推断出JSON的高阶结构，各自地将token信息转换为JSON所支持的语义元素：键值对、对象、数组。</p>
<p><code>JsonObject</code>接口会跟踪当前反序列化的对象或数组。当发现当前对象新的属性时(值、组合属性、或数组)，解析器调用对应的方法。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">JsonObject</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">setSimpleProperty</span><span class="params">(propertyName: <span class="type">String</span>, value: <span class="type">Any</span>?)</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">createObject</span><span class="params">(propertyName: <span class="type">String</span>)</span></span>: JsonObject</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">createArray</span><span class="params">(propertyName: <span class="type">String</span>)</span></span>: JsonObject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>propertyName</code>参数在该方法接收JSON的key。因此，当解析器遇到一个带有<code>author</code>属性的对象作为它的值时，将会调用<code>createObject(&quot;author&quot;)</code>方法。</p>
<p>下图显示了反序列化字符串每一步中的词法和语法分析。再一次说明，词法分析将输入字符串拆分为token列表；然后语法分析(parser)处理这些token列表中每一个元素调用<code>JsonObject</code>一个适当的方法。</p>
<p>反序列器为<code>JsonObject</code>实现提供对应类型的一个新实例的构建。它需要从JSON key(<code>title</code>，<code>author</code>，和<code>name</code>)和类属性之间查找，从而构建内嵌的对象值(实例<code>Author</code>)；之后才能创建需求的实例(<code>Book</code>)。</p>
<p><img src="/img/kotlin-in-action/chapter10/Figure_10_07.png" alt="Figure 10.7"></p>
<p>JKid使用了传统的Builder pattern模式，使用不同的builder来生成不同的对象实例。在JSON中需要构建不同的组合结构类型：对象、集合、映射。这些类包括有<code>ObjectSeed</code>、<code>ObjectListSeed</code>和<code>ValueListSeed</code>。</p>
<p>基础类<code>Seed</code>继承了<code>JsonObject</code>接口并提供了一个额外的<code>spawn</code>方法，用于获取builder处理完成的实例。另外还声明了<code>createCompositeProperty</code>方法，用于创建内嵌对象和内嵌列表。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Seed</span>: <span class="type">JsonObject</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">spawn</span><span class="params">()</span></span>: Any?</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">createCompositeProperty</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	propertyName: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	isList: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>: JsonObject</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createObject</span><span class="params">(propertyName: <span class="type">String</span>)</span></span> = createCompositeProperty(propertyName, <span class="literal">false</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createArray</span><span class="params">(propertyName: <span class="type">String</span>)</span></span> = createCompositeProperty(propertyName, <span class="literal">true</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以认为<code>spawn</code>是<code>build</code>的类似物——一个方法返回结果值。它为<code>ObjectSeed</code>返回结构化对象，产生<code>ObjectListSeed</code>或<code>ValueListSeed</code>的结果列表。姑且不讨论它的实现细节。</p>
<p>在此之前，先学习一下主要的<code>deserialize</code>函数，对值进行反序列化。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Any&gt;</span> <span class="title">deserialize</span><span class="params">(json: <span class="type">Reader</span>, targetClass: <span class="type">KClass</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">  <span class="keyword">val</span> seed = ObjectSeed(targetClass, ClassInfoCache())</span><br><span class="line">  Parser(json, seed).parse()</span><br><span class="line">  <span class="keyword">return</span> seed.spawn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要开始分析，先创建一个存储了对象属性的一个<code>ObjectSeed</code>对象，它将被序列化，然后调用解析器将<code>json</code>以stream reader的形式传入。一旦读取到了字节流的末尾，即调用<code>spawn</code>函数来构建输出结果。</p>
<p>现在先聚焦在<code>ObjectSeed</code>的实现上，它存储了一个对象被结构化的状态。<code>ObjectSeed</code>的第一构造函数包含了两个引用，一个是产生结果的类，另一个<code>classInfoCache</code>对象包含该类属性的缓存信息。这些缓存信息最终被被构建为该类的实例。<code>ClassInfoCache</code>和<code>ClassInfo</code>是帮助类。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectSeed</span>&lt;<span class="type">out T : Any</span>&gt;(</span><br><span class="line">  targetClass: KClass&lt;T&gt;,</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> classInfoCache: ClassInfoCache</span><br><span class="line">) : Seed &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Caches the information needed to create an instance of targetClass</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> classInfo: ClassInfo&lt;T&gt; = classInfoCache[targetClass]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> valueArguments = mutableMapOf&lt;KParameter, Any?&gt;()</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> seedArguments = mutableMapOf&lt;KParameter, Seed&gt;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Builds a map from constructor parameters to their values</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> arguments: Map&lt;KParameter, Any?&gt;</span><br><span class="line">    <span class="keyword">get</span>() = valueArguments + seedArguments.mapValues &#123; it.value.spawn() &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setSimpleProperty</span><span class="params">(propertyName: <span class="type">String</span>, value: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> param = classInfo.getConstructorParameter(propertyName)</span><br><span class="line">	<span class="comment">// Records a value for the constructor parameter, if it&#x27;s a simple value</span></span><br><span class="line">    valueArguments[param] = classInfo.deserializeConstructorArgument(param, value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createCompositeProperty</span><span class="params">(propertyName: <span class="type">String</span>, isList: <span class="type">Boolean</span>)</span></span>: Seed &#123;</span><br><span class="line">    <span class="keyword">val</span> param = classInfo.getConstructorParameter(propertyName)</span><br><span class="line">	<span class="comment">// Loads the value of the DeserializeInterface annotation for the property, if any</span></span><br><span class="line">    <span class="keyword">val</span> deserializeAs = classInfo.getDeserializeClass(propertyName)</span><br><span class="line">	<span class="comment">// Creates an ObjectSeed or CollectionSeed according to the parameter type...</span></span><br><span class="line">    <span class="keyword">val</span> seed = createSeedForType(</span><br><span class="line">      deserializeAs ?: param.type.javaType, isList</span><br><span class="line">    )</span><br><span class="line">	<span class="comment">// ...and records it in the seedArguments map</span></span><br><span class="line">    <span class="keyword">return</span> seed.apply &#123; seedArguments[param] = <span class="keyword">this</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Creates the resulting instance of targetClass, passing an arguments map</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">spawn</span><span class="params">()</span></span>: T = classInfo.createInstance(arguments)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ObjectSeed</code>在第一构造函数部分通过入参将属性对象存储在map中。包含两个可变的map：<code>valueArguments</code>用于存储简单的属性，<code>seedArguments</code>存储组合属性。简单属性通过调用<code>setSimpleProperty</code>方法存储在<code>valueArguments</code>，而组合属性则通过<code>createCompositeProperty</code>存储在<code>seedArguments</code>中。最后再通过<code>spawn</code>方法，递归地将组合属性作为入参构建内嵌的实例。</p>
<h3 id="Final-deserialization-step-callBy-and-creating-objects-using-reflection"><a class="header-anchor" href="#Final-deserialization-step-callBy-and-creating-objects-using-reflection">¶</a>Final deserialization step: <code>callBy()</code> and creating objects using reflection</h3>
<p><code>KCallable.call</code>方法提供了一种反射机制来构建实例。实际的入参作为对应类的构造函数的入参。因为不支持默认参数值。需要使用另外一个方法：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">KCallable</span>&lt;<span class="type">out R</span>&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">callBy</span><span class="params">(args: <span class="type">Map</span>&lt;<span class="type">KParameter</span>, Any?&gt;)</span></span>: R</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(略…)</p>
<h2 id="Summary"><a class="header-anchor" href="#Summary">¶</a>Summary</h2>
<p>Kotlin 的反射特性并没有创新，因为也是基于jvm的运行时。仅仅在原来Java API上进行了一层封装。严格来说，当你的程序需要用到反射的实现的时候，基本离重构的日子已经不远了。</p>
</div></article><nav class="article-nav"><div class="article-nav-prev">🔙<a href="/2023/01/01/rust/beginning/chapter01_Printing%20on%20the%20Terminal/">rust基础入门[01] - Printing on the Terminal</a></div><div class="article-nav-next">🔜<a href="/2022/01/07/kotlin/08_generics/">泛型</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2022/01/28/kotlin/09_annotations_and_reflection/';
var disqus_title = '注解和反射';
var disqus_url = 'https://galudisu.info/2022/01/28/kotlin/09_annotations_and_reflection/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>