<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>泛型</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">泛型</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2022-01-07</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/kotlin/">kotlin</a></p></div><div class="article-content"><h2 id="主要内容"><a class="header-anchor" href="#主要内容">¶</a>主要内容</h2>
<ol>
<li>泛型函数和类的声明</li>
<li>类型擦除(erasure)和具现(reified)</li>
<li>Declaration-site and use-site variance</li>
</ol>
<p>kotlin的泛型类型并不属于类型系统上的实现，而是尽量往Java方向兼容。所以实现形式上很多概念是等价的。</p>
<span id="more"></span>
<h2 id="Generic-type-parameters"><a class="header-anchor" href="#Generic-type-parameters">¶</a>Generic type parameters</h2>
<p>泛型指允许你定义的类型有 <em>泛型参数(type parameters)</em> 。当一个该类型的实例被创建了，类型参数被替代为指定的类型称之为 <em>type arguments</em> 。</p>
<p>Kotlin的类型参数在编译器中可自动推断类型，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> authors = listOf(<span class="string">&quot;Dmitry&quot;</span>, <span class="string">&quot;Svetlana&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>因为传递给函数<code>listOf</code>的值的类型都是字符串，编译器推断创建了一个<code>List&lt;String&gt;</code>值对象。但如果创建一个空的list，因为无法进行推断，所以此时必须显式指定类型。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> readers: MutableList&lt;String&gt; = mutableListOf()</span><br><span class="line"><span class="keyword">val</span> readers = mutableListOf&lt;String&gt;()</span><br></pre></td></tr></table></figure>
<p>这种声明是等价的。</p>
<blockquote>
<p><strong>NOTE</strong> 和Java不同，Kotlin要求类型参数要么显式指定，要么由编译器推导。但泛型是从JDK1.5才出现，为了兼容旧的版本，它允许你使用泛型类型时，可以不指定类型参数，叫做——原生类型(raw type)。例如，Java中使用List时，可以不指定类型参数。但Kotlin不同于Java，最开始的版本就提供泛型支持，它是不支持raw type的，泛型参数必须显式指定。</p>
</blockquote>
<h3 id="Generic-functions-and-properties"><a class="header-anchor" href="#Generic-functions-and-properties">¶</a>Generic functions and properties</h3>
<p>当你编写的函数包含List集合时，需要处理泛型参数以使得List对所有类型都生效，这种带有泛型参数的函数称为 <em>泛型函数(generic function)</em>。</p>
<p>以标准库中的泛型函数<code>slice</code>为例，</p>
<p><img src="/img/kotlin-in-action/chapter09/Figure_09_01.png" alt="Figure 9.1"></p>
<p>该函数的类型参数<code>T</code>被用作接收类型和返回类型；都为<code>List&lt;T&gt;</code>。在调用这类函数时，需要显式指定类型参数。但绝大多数情况下可以不指定，由编译器推导即可。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> letters = (<span class="string">&#x27;a&#x27;</span>..<span class="string">&#x27;z&#x27;</span>).toList()</span><br><span class="line">&gt;&gt;&gt; println(letters.slice&lt;<span class="built_in">Char</span>&gt;(<span class="number">0.</span><span class="number">.2</span>))  <span class="comment">// Specifies the type argument explicitly</span></span><br><span class="line">[a, b, c]</span><br><span class="line">&gt;&gt;&gt; println(letters.slice(<span class="number">10.</span><span class="number">.13</span>))  <span class="comment">// The compiler infers that T is Char here.</span></span><br><span class="line">[k, l, m, n]</span><br></pre></td></tr></table></figure>
<p>这里的结果类型都是<code>List&lt;Chart&gt;</code>。编译器推导<code>T</code>替代为<code>Char</code>作为返回类型<code>List&lt;T&gt;</code>的表述。</p>
<p>上一章的高阶函数<code>filter</code>可以进行编译器推导，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> authors = listOf(<span class="string">&quot;Dmitry&quot;</span>, <span class="string">&quot;Svetlana&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> readers = mutableListOf&lt;String&gt;(<span class="comment">/* ... */</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> List<span class="type">&lt;T&gt;</span>.<span class="title">filter</span><span class="params">(predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: List&lt;T&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; readers.filter&#123; it !<span class="keyword">in</span> authors &#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>it</code>编译器推导为<code>String</code>，因为实际的接收类型是<code>readers</code> ，它的实际参数类型是<code>List&lt;String&gt;</code>。</p>
<p>类型参数可以声明在classes、interfaces、top-level functions 或 external functions这些地方。也可以对扩展属性也使用相同的语法。例如，下面是返回最后一个元素的extension property。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;T&gt; List&lt;T&gt;.penultimate: T  <span class="comment">// This generic extension property can be called on a list of any kind.</span></span><br><span class="line">  <span class="keyword">get</span>() = <span class="keyword">this</span>[size - <span class="number">2</span>]</span><br><span class="line">  </span><br><span class="line">&gt;&gt;&gt; println(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).penultimate)  <span class="comment">// The type parameter T is inferred to be Int in this invocation.</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>You can’t declare a generic non-extension property</strong></p>
<p>常规的属性(non-extension)不能有类型参数。因为一个类不能同时存储不同的类型值，因此声明一个泛型非扩展属性没有任何意义。你可以尝试这样做，但编译器报告错误：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;T&gt; x: T = TODO()</span><br><span class="line">ERROR: type parameter of a property must be used <span class="keyword">in</span> its receiver type</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Declaring-generic-classes"><a class="header-anchor" href="#Declaring-generic-classes">¶</a>Declaring generic classes</h3>
<p>和Java一样，Kotlin可以使用尖括号来声明泛型类或接口，一旦声明泛型类后，就可以在该类的body内使用该泛型参数。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">List</span>&lt;<span class="type">T</span>&gt; &#123;  <span class="comment">// The List interface defines a type parameter T.</span></span><br><span class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: T  <span class="comment">// T can be used as a regular type in an interface or a class.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型类的继承也和Java一致，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringList</span>: <span class="type">List</span>&lt;<span class="type">String</span>&gt; &#123;  <span class="comment">// This class implements List, providing a speific type argument: String</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: String = ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;<span class="type">T</span>&gt;: <span class="type">List</span>&lt;<span class="type">T</span>&gt; &#123;  <span class="comment">// Now the generic type parameter T of ArrayList is a type argument of list</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: T = ... &#125;  </span><br></pre></td></tr></table></figure>
<p><code>StringList</code>继承泛型了，声明了具体的类型参数，不再是泛型类，而是具体类；<code>ArrayList</code>执行了泛型参数并传递给父类泛型参数，自身作为泛型类实现。</p>
<p>一个类也可以引用自身作为泛型参数，例如<code>Comparable</code>接口，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">T</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>: <span class="type">Comparable</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">override</span> compareTo(other: String): <span class="built_in">Int</span> = <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Type-parameter-constraints"><a class="header-anchor" href="#Type-parameter-constraints">¶</a>Type parameter constraints</h3>
<p>Kotlin的类型约束用法和Java无异。只不过是写法上的区别。</p>
<p>要声明一个约束，需要在类型参数后带上冒号(😃，再跟着指定的边界类型，</p>
<p><img src="/img/kotlin-in-action/chapter09/Figure_09_02.png" alt="Figure 9.2"></p>
<p>等价于Java 的写法<code>&lt;T extends Number&gt;</code>。下面的函数调用是运行的，因为Kotlin中的<code>Int</code>实际上继承自<code>Number</code>，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; println(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).sum())</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>一旦指定了类型参数<code>T</code>的边界，你可以直接使用它的上界类型定义的方法或属性：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Number&gt;</span> <span class="title">oneHalf</span><span class="params">(value: <span class="type">T</span>)</span></span>: <span class="built_in">Double</span> &#123;  <span class="comment">// Specifies Number as the type parameter upper bound</span></span><br><span class="line">  <span class="keyword">return</span> value.toDouble() / <span class="number">2.0</span>  <span class="comment">// Invoke a method defined in the Number class</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(oneHalf(<span class="number">3</span>))</span><br><span class="line"><span class="number">1.5</span></span><br></pre></td></tr></table></figure>
<p>下面编写一个泛型函数查找两值中的最大值。你需要定义<code>Comparable</code>的上界才能进行比较。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Comparable&lt;T&gt;</span>&gt; <span class="title">max</span><span class="params">(first: <span class="type">T</span>, second: <span class="type">T</span>)</span></span>: T &#123;  <span class="comment">// The arguments of this function must be comprable elements.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">if</span> (first &gt; second) first <span class="keyword">else</span> second</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(max(<span class="string">&quot;kotlin&quot;</span>, <span class="string">&quot;java&quot;</span>))  <span class="comment">// The strings are compared alphabetically.</span></span><br><span class="line">kotlin</span><br></pre></td></tr></table></figure>
<p>如果传入的参数类型没有继承<code>Comprable</code>，编译将不通过，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; println(max(<span class="string">&quot;kotlin&quot;</span>, <span class="number">42</span>))</span><br><span class="line">ERROR: Type parameter bound <span class="keyword">for</span> T <span class="keyword">is</span> not satisfied:</span><br><span class="line">  inferred type Any <span class="keyword">is</span> not a subtype of Comparable&lt;Any&gt;</span><br></pre></td></tr></table></figure>
<p><code>T</code>的上界是一个泛型类型<code>Comparable&lt;T&gt;</code>。前面看到，<code>String</code>类继承了<code>Comparable&lt;String&gt;</code>，因此可以传入字符串类型作为参数。</p>
<p>记住，依据Kotlin的operator conventions的规约，<code>first &gt; second</code>实际上被编译为<code>first.compareTo(second) &gt; 0</code>。</p>
<p>很少的情况下需要对同一个类型参数指定多个上界的，你需要稍微使用不同的语法。例如，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">ensureTrailingPeriod</span><span class="params">(seq: <span class="type">T</span>)</span></span></span><br><span class="line">		<span class="keyword">where</span> T: CharSequence, T: Appendable &#123;</span><br><span class="line">  <span class="keyword">if</span>(!seq.endsWith(<span class="string">&#x27;.&#x27;</span>)) &#123;  <span class="comment">// Calls an extension function defined for the CharSequence interface</span></span><br><span class="line">    seq.append(<span class="string">&#x27;.&#x27;</span>)  <span class="comment">// Calls the method from the Appendable interface</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> helloWorld = StringBuilder(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; ensureTrailingPeriod(helloWorld)</span><br><span class="line">&gt;&gt;&gt; println(helloWorld)</span><br><span class="line">Hello World.</span><br></pre></td></tr></table></figure>
<p>这个例子中，使用的泛型类型必须同时继承<code>CharSequence</code>和<code>Appendable</code>接口。意味着可以对其进行访问(<code>endsWith</code>)和修改(<code>append</code>)操作。</p>
<h3 id="Making-type-parameters-non-null"><a class="header-anchor" href="#Making-type-parameters-non-null">¶</a>Making type parameters non-null</h3>
<p>如果你声明一个泛型类或函数，任何类型参数，包括可空，可以被替换为它自身的类型参数。实际上，一个类型参数如果不指定上界的话，它的上界则为<code>Any?</code>。考虑如下例子：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Processor</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    value?.hashCode()  <span class="comment">// &quot;value&quot; is nullable, so you have to use a safe call.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>process</code>的参数<code>value</code>是可空的，尽管<code>T</code>没有标记上问号。这种情况下<code>Processor</code>类可以传入可用类型来替换<code>T</code>：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> nullableStringProcessor = Processor&lt;String?&gt;()  <span class="comment">// String?, which is a nullable type, is substituted for T.</span></span><br><span class="line">nullableStringProcessor.process(<span class="literal">null</span>)  <span class="comment">// This code compiles fine, having &quot;null&quot; as the &quot;value&quot; argument.</span></span><br></pre></td></tr></table></figure>
<p>如果你想要确保一个非空类型总是被替换使用。你可以实现这种特定的边界。否则就不指定，使用默认的<code>Any?</code>实现，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Processor</span>&lt;<span class="type">T: Any</span>&gt; &#123;  <span class="comment">// Specifying a non-&quot;null&quot; upper bound</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    value.hashCode()  <span class="comment">// &quot;value&quot; of type T is now non-&quot;null&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;T: Any&gt;</code>约束确保了<code>T</code>类型总是不为空的参数类型。传入可空参数将发生编译错误：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> nullableStringProcessor = Processor&lt;String?&gt;()</span><br><span class="line">Error: Type argument <span class="keyword">is</span> not within its bounds: should be subtype of <span class="string">&#x27;Any&#x27;</span></span><br></pre></td></tr></table></figure>
<p>目前为止，Kotlin的基本泛型语法和Java类似。下面讨论运行时泛型的行为。</p>
<h2 id="Generics-at-runtime-erased-and-reified-type-parameters"><a class="header-anchor" href="#Generics-at-runtime-erased-and-reified-type-parameters">¶</a>Generics at runtime: erased and reified type parameters</h2>
<p>你可能已经知道，JVM上的泛型通过 <em>类型擦除(type erasure)</em> 实现，意味着一个泛型类的一个实例的类型参数在运行时是不保留的。我们将讨论Kotlin的类型确保的实际意义，以及如何应对<code>inline</code>函数的限制。你可以声明一个<code>inline</code>函数，这样它的类型参数不会被擦除<strong>erased</strong>(或，在Kotlin术语中，叫具现化<strong>reified</strong>)。</p>
<h3 id="Generics-at-runtime-type-checks-and-casts"><a class="header-anchor" href="#Generics-at-runtime-type-checks-and-casts">¶</a>Generics at runtime: type checks and casts</h3>
<p>和Java一样，Kotlin的泛型也是运行时擦除的。意味着一个泛型类的实例不会携带创建时的类型参数信息。例如，如果你创建了一个<code>List&lt;String&gt;</code>，里面放了一堆字符串，在运行时你将只能看到它是一个<code>List</code>。没有任何可能区分到它的实际包含的元素类型(当然，你可以获取到它的元素，校验它的类型，但不会给你任何保障，因为其它元素可能有不同类型)。</p>
<p>考虑如下代码并运行，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list1: List&lt;String&gt; = listOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> list2: List&lt;<span class="built_in">Int</span>&gt; = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/kotlin-in-action/chapter09/Figure_09_03.png" alt="Figure 9.3"></p>
<p>尽管编译器看出来这两个list有不同的类型，但在执行期间它们实际上是一样的。尽管如此，你可以确定<code>List&lt;String&gt;</code>仅包含字符串；<code>List&lt;Int&gt;</code>仅包含整型，因为编译器知道类型参数并且确保元素是被正确存储的。</p>
<p>我们继续讨论类型擦除的约束信息。因为类型参数不会被存储，你不能校验它们——例如，你不能校验一个list是一个字符串list而不是其它呢。通常规定，你无法使用<code>is</code>关键字来校验类型参数。下面代码不被编译：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">if</span> (value <span class="keyword">is</span> List&lt;String&gt;) &#123; ... &#125;</span><br><span class="line">ERROR: Cannot check <span class="keyword">for</span> instance of erased type</span><br></pre></td></tr></table></figure>
<p>尽管在运行时你可以找出该值是一个<code>List</code>，却没有告知它到底是字符串list还是其它类型的list：类型信息被擦除<strong>erased</strong>了。泛型类型信息被擦除是有好处的：总体的内存信息将被减少，因为需要尽可能少的存储类型信息到内存中。</p>
<p>Kotlin不允许你使用没有指定泛型参数的泛型类型。这样你可能想知道如何校验list的值，你可能会用到特定的 <em>star projection</em> 语法：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">is</span> List&lt;*&gt;) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>显著地，引入 <em><code>*</code></em> 表述它会是任何类型。我们可以认为它表示的是未知类型(类似于Java的 <code>List&lt;?&gt;</code>)。这样一来，你就可以校验<code>value</code>是否是一个<code>List</code>，但仍然无法得知它的元素类型。</p>
<p>你仍然可以使用传统的<code>as</code>和<code>as?</code>进行转换。但当该类包含有正确的基础类型和错误的参数类型，类型转换不会失败，因为进行转换时并不知道具体的类型参数。正因为这样，编译器会发出&quot;unchecked cast&quot;这样的警告。但仅仅是警告，后面你还可以继续使用它。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(c: <span class="type">Collection</span>&lt;*&gt;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> intList = c <span class="keyword">as</span>? List&lt;<span class="built_in">Int</span>&gt;  <span class="comment">// Warning here. Unchecked cast: List&lt;*&gt; to List&lt;Int&gt;</span></span><br><span class="line">		?: <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;List is expected&quot;</span>)</span><br><span class="line">  println(intList.sum())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; printSum(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))  <span class="comment">// Everything works as expected.</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>一切顺利：编译器仅产生一个告警，意味着代码是合理的(legitimate)。如果你在一个整型的list或set上调用<code>printSum</code>，第一种情况工作，后面会抛出异常。如果传递错误的值类型，则抛出<code>ClassCastException</code>运行期异常：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; printSum(setOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))  <span class="comment">// Set isn&#x27;t a list, so an exception is thrown.</span></span><br><span class="line">IllegalArgumentException: List <span class="keyword">is</span> expected</span><br><span class="line">&gt;&gt;&gt; printSum(listOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>))  <span class="comment">// The cast succeeds, and another exception is thrown later.</span></span><br><span class="line">ClassCastException: String cannot be cast to Number</span><br></pre></td></tr></table></figure>
<p>Kotlin的智能转换可以在编译期校验它的类型信息，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(c: <span class="type">Collection</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (c <span class="keyword">is</span> List&lt;<span class="built_in">Int</span>&gt;)  <span class="comment">// This check is legitimate.</span></span><br><span class="line">    println(c.sum())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; printSum(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>这里可以校验<code>c</code>是否是<code>List&lt;Int&gt;</code>，因为编译期已经确定了该集合类型。</p>
<p>通常，Kotlin编译期会处理好哪些类型是危险的(禁止<code>is</code>校验和抛出<code>as</code>转换的告警)。你仅需要知道告警的含义并理解操作是否是安全的。</p>
<p>前面提及到Kotlin有办法可以指定类型参数，但仅允许在<code>inline</code>内联函数使用。下面看看是怎么做到的。</p>
<h3 id="Declaring-functions-with-reified-type-parameters"><a class="header-anchor" href="#Declaring-functions-with-reified-type-parameters">¶</a>Declaring functions with reified type parameters</h3>
<p>前面提到，Kotlin的泛型和Java一样，都是运行期擦除的，意味着如果一个泛型类的实例，在实例被创建时无法得知它的类型参数。泛型函数也一样。当你调用一个泛型函数时，无法在调用时决定body的类型参数：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">isA</span><span class="params">(value: <span class="type">Any</span>)</span></span> = value <span class="keyword">is</span> T</span><br><span class="line">ERROR: Cannot check <span class="keyword">for</span> instance of erased type: T</span><br></pre></td></tr></table></figure>
<p>通常这是正确的，但有一种情况可以避免这种限制：内联函数。内联函数的类型参数可以具现化，意味着你可以引用到运行期的真实的类型参数。</p>
<p>Kotlin的内联函数，在编译期是被替换为真实代码实现的。标记一个<code>inline</code>函数可以提供性能，如果该函数使用lambda表达式作为入参的话：lambda代码被内联，匿名类被创建。这里显式<code>inline</code>函数另一个有用的场景：类型参数可以被具现(reified)。</p>
<p>更改前面的函数<code>isA</code>，标记上<code>inline</code>后，类型参数作为<code>reified</code>，现在你可以校验<code>value</code>的实例类型<code>T</code>。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">isA</span><span class="params">(value: <span class="type">Any</span>)</span></span> = value <span class="keyword">is</span> T  <span class="comment">// Now this code compiles.</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(isA&lt;String&gt;(<span class="string">&quot;abc&quot;</span>))</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt;&gt;&gt; println(isA&lt;String&gt;(<span class="number">123</span>))</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>看看一些其它很少用到的具现化的例子。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> items = listOf(<span class="string">&quot;one&quot;</span>, <span class="number">2</span>, <span class="string">&quot;three&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; println(items.filterIsInstance&lt;String&gt;())</span><br><span class="line">[one, threee]</span><br></pre></td></tr></table></figure>
<p>这里指定了<code>&lt;String&gt;</code>作为类型参数。因此它返回<code>List&lt;String&gt;</code>。这种情况下，<em>the type argument is known at runtime</em> ，<code>filterIsInstance</code>被用来校验list实例的具体类型。</p>
<p>下面是它的标准库实现。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span>  // &quot;<span class="keyword">reified</span>&quot; declares that this type parameter will not be erased at runtime.</span></span><br><span class="line">	Iterable&lt;*&gt;.filterIsInstance(): List&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">val</span> destination = mutableListOf&lt;T&gt;()</span><br><span class="line">  <span class="keyword">for</span> (element <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element <span class="keyword">is</span> T) &#123;  <span class="comment">// You can check whether the element is an instance of the class sepcified as a type argument.</span></span><br><span class="line">	  destination.add(element)</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> destination</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Why reification works for inline functions only</strong></p>
<p>编辑器将字节码插入到对应的内联函数的调用部分。每次调用带有reified 类型参数的函数，编译器都知道它的真实类型。因此编译器可以生成相应特定类型参数对应类的字节码。实际上，<code>filterIsInstance&lt;String&gt;</code>调用的等价字节码如下：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (element <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (element <span class="keyword">is</span> String) &#123;  <span class="comment">// References a specific class.</span></span><br><span class="line">    destination.add(element)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为生成的字节码引用一个特定的类，而不是类型参数，它不会在运行时收到类型擦除的影响。</p>
<p>注意带有<code>reified</code>类型参数的<code>inline</code>函数不能被Java所调用。常规的内联函数可以被Java作为普通函数访问——但不是内联的。带有reified类型参数的内联函数要求额外的字节码替换操作，因为它必须是内联的。所以无法从普通的方式调用它，Java代码也一样。</p>
</blockquote>
<p>内联函数可以有多个具现化参数类型，也可以没有。因为内联函数带来性能提供的唯一前提是函数的入参是一个lambda表达式，但这里的<code>filterIsInstance</code>没有任何入参。这种情况下，<code>inline</code>函数并不是作为性能提升的原因；相反，用于类型参数具现化。</p>
<p>为了确保良好的性能，你仍然需要关注<code>inline</code>函数编译后的内存占用大小。如果函数变得太大，最好重构提取出不依赖reified类型参数的非内联部分函数。</p>
<h3 id="Replacing-class-references-with-reified-type-parameters"><a class="header-anchor" href="#Replacing-class-references-with-reified-type-parameters">¶</a>Replacing class references with reified type parameters</h3>
<p>具现化类型参数的一个常规用法是为<code>java.lang.Class</code>构建API适配器。例如来自JDK的API是<code>ServiceLoader</code>，接收一个<code>java.lang.Class</code>作为接口或抽象类作为参数并返回该类的一个实例。我们看看具现化类型参数如何调用实现。</p>
<p>要使用Java API类<code>ServiceLoader</code>，可以如下调用：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> serviceImpl = ServiceLoader.load(Service::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure>
<p><code>::class.java</code>语法显式了如何获得一个<code>java.lang.Class</code>对应的Kotlin类。实际上等价于Java的<code>Service.class</code>。</p>
<p>我们可以使用具现化内联函数重写这个例子。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> serviceImpl = loadService&lt;Service&gt;()</span><br></pre></td></tr></table></figure>
<p>更简短。现在该类不作为入参而是作为类型参数使用。下面重定义<code>loadService</code>内联函数：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">loadService</span><span class="params">()</span></span> &#123;  <span class="comment">// The type parameter is marked as &quot;refied&quot;.</span></span><br><span class="line">  <span class="keyword">return</span> ServiceLoader.load(T::<span class="keyword">class</span>.java)  <span class="comment">// Accesses the class of the type parameter as T::class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你仍然可以使用同样的<code>::class.java</code>语法在具现化类型参数上。因为它是运行期替换的。</p>
<blockquote>
<p><strong>Simplifying the startActivity function on Android</strong></p>
<p>如果你是Android开发者，你可能发现另外一个更相似的例子：showing activities. 取代<code>java.lang.Class</code>进行传递，你可以使用具现化类型参数：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T : Activity&gt;</span></span></span><br><span class="line">        Context.startActivity() &#123;  <span class="comment">// The type parameter is marked as &quot;reified&quot;.</span></span><br><span class="line">  <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, T::<span class="keyword">class</span>.java)  <span class="comment">// Accesses the class of the type parameter as T::class</span></span><br><span class="line">  startActivity(intent)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">startActivity&lt;DetailActivity&gt;()  <span class="comment">// Invokes the method to show an activity</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Restrictions-on-reified-type-parameters"><a class="header-anchor" href="#Restrictions-on-reified-type-parameters">¶</a>Restrictions on reified type parameters</h3>
<p>尽管具现化类型参数非常有用，但它有某些限制。某些继承了这些概念，其它的特性则取决于当前的实现又获取在将来的Kotlin版本不加约束。</p>
<p>更具体来说，下面是如何使用一个具现化类型参数：</p>
<ul>
<li>In type checks and casts(<code>is</code>、<code>!is</code>、<code>as</code>、<code>as?</code>)</li>
<li>To use the Kotlin reflection APIs(<code>::class</code>)</li>
<li>To get the corresponding <code>java.lang.Class</code>(<code>::class.java</code>)</li>
<li>As a type argument to call other functions</li>
</ul>
<p>你 <em>不可以</em> 如下做：</p>
<ul>
<li>Create new instances of the class specified as a type parameter</li>
<li>Call methods on the companion object of the type parameter class</li>
<li>Use a non-reified type parameter as a type argument when calling a function with reified type parameter</li>
<li>Mark type parameters of classes, properties, or non-inline functions as <code>reified</code></li>
</ul>
<p>最后一个约束导致一个有趣的结果：因为具现化类型参数仅能被用于内联函数，使用一个具现化类型参数意味着函数连着所有传入的lambda都是被内联的。如果由于使用方式导致lambda不被内联，或者由于性能的原因不希望其被内联，你可以使用<code>noinline</code>修改器比较不让其内联。</p>
<h2 id="Variance-generics-and-subtyping"><a class="header-anchor" href="#Variance-generics-and-subtyping">¶</a>Variance: generics and subtyping</h2>
<p><em>协变(variance)</em> 的概念描述同一个基础类型在不同类型参数如何关联：例如，<code>List&lt;String&gt;</code>和<code>List&lt;Any&gt;</code>。首先我们将描述为什么这种关联关系的重要性，以及在Kotlin中如何表述。理解协变是编写泛型类或函数的本质：它帮助你创建API不强制用户以不方便的方式打破他们的类型安全期望。</p>
<h3 id="Why-variance-exists-passing-an-argument-to-a-function"><a class="header-anchor" href="#Why-variance-exists-passing-an-argument-to-a-function">¶</a>Why variance exists: passing an argument to a function</h3>
<p>假设你有一个函数接收一个<code>List&lt;Any&gt;</code>作为参数。传递<code>List&lt;String&gt;</code>类型变量给该函数是安全的吗？当然是安全的，因为<code>String</code>类继承自<code>Any</code>。但当<code>Any</code>和<code>String</code>变为<code>List</code>接口的类型参数时，语义不再清晰。</p>
<p>例如，考虑一个函数打印内容到控制台。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printContents</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">Any</span>&gt;)</span></span> &#123;</span><br><span class="line">   println(list.joinToString())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; printContents(listOf(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;bac&quot;</span>))</span><br><span class="line">abc, bac</span><br></pre></td></tr></table></figure>
<p>看起来字符串可以工作。该函数把每个元素看做是<code>Any</code>，然后每个字符串都是<code>Any</code>，它是安全的。</p>
<p>现在看看另一个函数，它将修改list(所以用到<code>MutableList</code>作为参数)。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addAnswer</span><span class="params">(list: <span class="type">MutableList</span>&lt;<span class="type">Any</span>&gt;)</span></span> &#123;</span><br><span class="line">  list.add(<span class="number">42</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果传递字符串list会怎样？</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> strings = mutableListOf(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;bac&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; addAnswer(strings)  <span class="comment">// If this line compiled...</span></span><br><span class="line">&gt;&gt;&gt; println(strings.maxBy &#123; it.length &#125;)  <span class="comment">// ...you&#x27;d get an exception at runtime.</span></span><br><span class="line">ClassCastException: Integer cannot be cast to String</span><br></pre></td></tr></table></figure>
<p>你声明一个<code>string</code>的类型<code>MutableList&lt;String&gt;</code>变量。然后传递给该函数。如果编译器接收它，你便可以在该list添加一个整数，当尝试访问这个list的内容这将导致运行时异常。正因如此，该调用无法编译。这个例子展示了传递一个<code>MutableList&lt;String&gt;</code>作为参数但却受到一个<code>MutableList&lt;Any&gt;</code>是不安全的；Kotlin编译器禁止这样做。</p>
<p>由于类型的不一致性，添加或替换list中的元素是不安全的。其它行为则是安全的。在Kotlin中，如果接口正确可以很好控制。</p>
<h3 id="Classes-types-and-subtypes"><a class="header-anchor" href="#Classes-types-and-subtypes">¶</a>Classes, types, and subtypes</h3>
<p>某些情况下<code>type</code>和<code>class</code>是等价的，某些情况下不是。</p>
<p>在非泛型类中，类名可以直接用作类型。例如，<code>var x: String</code>直接声明的变量的类型就是<code>String</code>类，并且也可以声明为可空类型，<code>var x: String?</code>。</p>
<p>在泛型类中，要获得有效的类型，需要在运行时替换真实的类型，譬如<code>List</code>不是一个类型(它是一个类)，但下列的情况是有效的类型：<code>List&lt;Int&gt;</code>、<code>List&lt;String?&gt;</code>、<code>List&lt;List&lt;String&gt;&gt;</code>，等等。每个泛型类产生一个可能的无限类型。</p>
<p>为了让我们讨论类型直接的关系，我们需要熟悉属于 <em>subtype</em> 。它的对立是 <em>supertype</em> 。子类型和父类型的关系有如下：</p>
<p><img src="/img/kotlin-in-action/chapter09/Figure_09_04.png" alt="Figure 9.4"></p>
<p>为什么一个类型到底是子类型或其它类型如此重要？编译器每次都对传递给函数的变量进行检查。考虑如下代码：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(i: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> n: Number = i  <span class="comment">// Compiles, because Int is a subtype of Number</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">(s: <span class="type">String</span>)</span></span> &#123; <span class="comment">/*..*/</span> &#125;</span><br><span class="line">  f(i)  <span class="comment">// Doesn&#x27;t compile, because Int isn&#x27;t a subtype of String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将一个值存储在变量仅当该值的类型是该变量的子类型；例如，这里的<code>i</code>的类型是<code>Int</code>，<code>Int</code>是<code>Number</code>的子类型，它可以存储在<code>n</code>变量中；但它不是<code>String</code>的子类型，编译将不通过。</p>
<p>某些情况下，子类等同于子类型的特性。例如，<code>Int</code>是<code>Number</code>的子类，因此<code>Int</code>类型是<code>Number</code>类型的子类型。</p>
<p><img src="/img/kotlin-in-action/chapter09/Figure_09_05.png" alt="Figure 9.5"></p>
<p>非空类型是可空类型的子类型，反之则不是，因为没有包含关系。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s: String = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">val</span> t: String? = s  <span class="comment">// This assignment is legal because String is a subtype of String?.</span></span><br></pre></td></tr></table></figure>
<p>诸如<code>MutableList</code>这样的泛型类，它的类型参数是不可变的，对于两个不同的类型A和B，<code>MutableList&lt;A&gt;</code>不是<code>MutableList&lt;B&gt;</code>的子类型或父类型。在Java中，所有类型都是不可变的(invariant)。</p>
<h3 id="Covariance-preserved-subtyping-relation"><a class="header-anchor" href="#Covariance-preserved-subtyping-relation">¶</a>Covariance: preserved subtyping relation</h3>
<p>泛型类的协变类遵循下面规则：<code>Producer&lt;A&gt;</code>是<code>Producer&lt;B&gt;</code>的子类型当<code>A</code> 是<code>B</code>的子类型。它是 <em>子类型保留的(subtyping is preserved)</em> 。例如，<code>Producer&lt;Cat&gt;</code>是<code>Producer&lt;Animal&gt;</code>的子类型，因为<code>Cat</code>是<code>Animal</code>的子类型。</p>
<p>在Kotlin 中声明一个类成为协变类，使用<code>out</code>关键字在类型参数前：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Producer</span>&lt;<span class="type">out T</span>&gt; &#123; <span class="comment">// This class is declared as covariant on T.</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使一个类的类型参数协变，可以令参数为该类的函数，入参可以不匹配函数定义。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">feed</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Herd</span>&lt;<span class="type">out T: Animal</span>&gt; &#123;  <span class="comment">// The type parameter is now covariant.</span></span><br><span class="line">  <span class="keyword">val</span> size: <span class="built_in">Int</span> <span class="keyword">get</span>() = ...</span><br><span class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(i: <span class="type">Int</span>)</span></span>: T &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">feedAll</span><span class="params">(animals: <span class="type">Herd</span>&lt;<span class="type">Animal</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until animals.size) &#123;</span><br><span class="line">    animals[i].feed()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">takeCareOfCats</span><span class="params">(cats: <span class="type">Herd</span>&lt;<span class="type">Cat</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">0</span> until cats.size) &#123;</span><br><span class="line">    cats[i].cleanLitter()</span><br><span class="line">  &#125;</span><br><span class="line">  feedAll(cats)  <span class="comment">// You don&#x27;t need a cast.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你不能令任何类都是协变的：会导致不安全。</p>
<p>假设一个类声明了类型参数<code>T</code>并且包含一个函数使用了<code>T</code>。我们说<code>T</code>作为函数的返回类型时，是在<code>out</code>位置。如果<code>T</code>作为函数的一个参数，是在<code>in</code>位置。</p>
<p><img src="/img/kotlin-in-action/chapter06/Figure_09_06.png" alt="Figure 9.6"></p>
<p><code>out</code>位置要求所有用到的类型参数所对应的<code>T</code>仅能在声明了<code>out</code>的类型关联使用。例如，<code>Hered</code>类使用了<code>T</code>就在<code>out</code>的位置。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Herd</span>&lt;<span class="type">out T: Animal</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">val</span> size: <span class="built_in">Int</span> <span class="keyword">get</span>() = ...</span><br><span class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(i: <span class="type">Int</span>)</span></span>: T &#123; ... &#125;  <span class="comment">// Uses T as the return type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>out</code>关键字在<code>T</code>类型参数意味着：</p>
<ul>
<li>子类型是被保留的(<code>Producer&lt;Cat&gt;</code>是<code>Producer&lt;Animal&gt;</code>的子类型)</li>
<li><code>T</code>仅能被用于<code>out</code>位置。</li>
</ul>
<p>现在在看下<code>List&lt;T&gt;</code>接口。Kotlin的<code>List</code>是只读的，它只有一个<code>get</code>方法返回<code>T</code>类型的元素，它是协变的。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">List</span>&lt;<span class="type">out T</span>&gt;: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: T  <span class="comment">// Read-only interface that defines only methods that return T (so T is in the &quot;out&quot; position</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意类型参数不仅是作为参数的类型或返回类型，也可以作为其它类型的类型参数。例如，<code>List</code>接口包含方法<code>subList</code>返回<code>List&lt;T&gt;</code>。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">List</span>&lt;<span class="type">out T</span>&gt;: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">subList</span><span class="params">(fromIndex: <span class="type">Int</span>, toIndex: <span class="type">Int</span>)</span></span>: List&lt;T&gt;  <span class="comment">// Here T is in the &quot;out&quot; position as well.</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>T</code>用在<code>subList</code>函数的<code>out</code>位置。</p>
<p>但你不能声明<code>MutableList&lt;T&gt;</code>作为协变类，因为它包含方法接收<code>T</code>作为参数并返回该值(<code>T</code>同时出现在<code>in</code>和<code>out</code>位置)。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MutableList</span>&lt;<span class="type">T</span>&gt;  // <span class="title">MutableList</span> <span class="title">can</span>&#x27;<span class="title">t</span> <span class="title">be</span> <span class="title">declared</span> <span class="title">a</span> <span class="title">covariant</span> <span class="title">on</span> <span class="title">T</span> ...</span><br><span class="line">		: List&lt;T&gt;, MutableCollection&lt;T&gt; &#123; </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span>  <span class="comment">// ...because T is used in the &quot;in&quot; postion.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器严格执行该约束。如果该类被声明为一个协变会报错误：<code>Type parameter T is declared as 'out' but occurs in 'in' postion.</code>。</p>
<p>注意构造参数既没有<code>in</code>也没有<code>out</code>。即使一个类型参数被声明为<code>out</code>，你仍然可以使用构造参数的声明：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Herd</span>&lt;<span class="type">out T: Animal</span>&gt;(vararge animals: T) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>构造函数不是方法，它在实例被创建后调用，因此不会有潜在的隐患。</p>
<p>你可以在构造参数使用<code>val</code>或<code>var</code>关键字，也可以声明一个getter和setter(mutable)。因此，类型参数用在<code>out</code>位置作为只读属性，同时在<code>out</code>和<code>in</code>位置则作为一个可变(mutable)属性：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Herd</span>&lt;<span class="type">T: Animal</span>&gt;(<span class="keyword">var</span> leadAnimal: T, vararge animals: T) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>现在可以令<code>Herd</code>对<code>T</code>协变，因为<code>leadAnimal</code>属性是private的。</p>
<h3 id="Contravariance-reversed-subtyping-relation"><a class="header-anchor" href="#Contravariance-reversed-subtyping-relation">¶</a>Contravariance: reversed subtyping relation</h3>
<p><em>逆变(contravariance)</em> 可以认为是协变(covariance)的镜像：对于逆变类，子类型关联的是它的类型参数的子类型的反面。我们以一个例子开始：<code>Comparator</code>接口。该接口定义一个方法，<code>compare</code>，比较两个对象：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">compare</span><span class="params">(e1: <span class="type">T</span>, e2: <span class="type">T</span>)</span></span>: <span class="built_in">Int</span> &#123; .. &#125;  <span class="comment">// Uses T in &quot;in&quot; positions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到该接口的唯一方法仅消费<code>T</code>类型。意味着<code>T</code>仅被用于<code>in</code>位置，因此它的声明前面是<code>in</code>关键字。</p>
<p>定义了comparator的类型值，可以对该类型的任意子类型进行比较。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> anyComparator = Comparator&lt;Any&gt; &#123;</span><br><span class="line">...    e1, e2 -&gt; e1.hashCode() - e2.hashCode()</span><br><span class="line">... &#125;</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> strings: List&lt;String&gt; = ...</span><br><span class="line">&gt;&gt;&gt; strings.sortedWith(anyComparator)  <span class="comment">// You can use the comparator for any objects to compare specific objects, such as strings.</span></span><br></pre></td></tr></table></figure>
<p>意味着<code>Comparator&lt;Any&gt;</code>是<code>Comparator&lt;String&gt;</code>的子类型，然而<code>Any</code>是<code>String</code>的超类型。两种类型的子类化关系刚好是相反的。</p>
<p>现在对逆变准备的更充分的定义。一个类如果是逆变的，那么它是一个泛型类(以<code>Consumer&lt;T&gt;</code>为例)，它的泛型参数遵循如下：如果<code>B</code>是<code>A</code>的超类型，那么<code>Consumer&lt;A&gt;</code>是<code>Consumer&lt;B&gt;</code>的子类型。类型参数<code>A</code>和<code>B</code>交换位置，所以我们看到子类化是反过来的。例如，<code>Consumer&lt;Animal&gt;</code>是<code>Consumer&lt;Cat&gt;</code>的子类型。</p>
<p>下图显示了协变和逆变的类型参数子类化的不同比较。可以看到，<code>Producer</code>和<code>Consumer</code>的子类化关系是相反的。</p>
<p><img src="/img/kotlin-in-action/chapter09/Figure_09_07.png" alt="Figure 9.7"></p>
<p><code>in</code>关键字表示相应类型的值被 <em>passed in</em> 到该类的方法消费。类似于协变，对类型参数的约束产生特定的子类化关系。类型<code>T</code>带有<code>in</code>关键字意味着子类化被反转，<code>T</code>仅能被用于<code>in</code>位置。下标总结了可能的variance的情况。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Covariant</th>
<th style="text-align:left">Contravariant</th>
<th style="text-align:left">Invariant</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>Producer&lt;out T&gt;</code></td>
<td style="text-align:left"><code>Consumer&lt;in T&gt;</code></td>
<td style="text-align:left"><code>MutableList&lt;T&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">Subtyping for the class is preserved: <code>Producer&lt;cat&gt;</code> is a subtype of <code>Producer&lt;Animal&gt;</code></td>
<td style="text-align:left">Subtyping is   reversed: <code>Consumer&lt;Animal&gt;</code> is a subtype of <code>Consumer&lt;Cat&gt;</code></td>
<td style="text-align:left">No subtyping</td>
</tr>
<tr>
<td style="text-align:left"><code>T</code> only in <code>out</code> positions</td>
<td style="text-align:left"><code>T</code> only in <code>in</code> positions</td>
<td style="text-align:left"><code>T</code> in any position</td>
</tr>
</tbody>
</table>
<p>一个类或接口同时可以对一个类型参数协变(covariant)，对另一个类型逆变(contravariant)。最经典的例子莫过于<code>Function</code>接口，下面是一个类型参数的<code>Function</code>定义：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Function1</span>&lt;<span class="type">in P, out R</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(p: <span class="type">P</span>)</span></span>: R</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面使用到了<code>operator</code>规约，说明它有更简单的写法<code>(P) -&gt; R</code>。这里看到<code>P</code>标记为<code>in</code>它是作为入参，而<code>R</code>则作为返回类型，用<code>out</code>标记仅能用在<code>out</code>的位置。意味着对于第一个类型参数<code>P</code>是逆变的、反转的；而对于第二个类型参数<code>R</code>是保留的、协变的。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">enumerateCats</span><span class="params">(f: (<span class="type">Cat</span>) -&gt; <span class="type">Number</span>)</span></span> &#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> Animal.<span class="title">getIndex</span><span class="params">()</span></span>: <span class="built_in">Int</span> = ...</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; enumerateCats(Animal::getIndex)  <span class="comment">// This code is legal in Kotlin. Animal is a supertype of Cat, and Int is a subtype Of Number.</span></span><br></pre></td></tr></table></figure>
<p>下图为其subtyping relationship。</p>
<p><img src="/img/kotlin-in-action/chapter09/Figure_09_08.png" alt="Figure 9.8"></p>
<h3 id="Use-site-variance-specifying-variance-for-type-occurrences"><a class="header-anchor" href="#Use-site-variance-specifying-variance-for-type-occurrences">¶</a>Use-site variance: specifying variance for type occurrences</h3>
<p>在类的声明上指定其可变性的能力会变得很方便，因为修改会作用到该类的使用的任何地方。这叫做 <em>declaration-site variance</em> 。如果你熟悉Java的通配符类型(<code>? extends</code> 和 <code>? super</code>)，你会意识到Java处理可变性的差异。在Java中，每次你都可以使用子类型或超类型来替代。这叫做 <em>use-site variance</em> 。</p>
<blockquote>
<p><strong>Declaration-site variance in Kotlin vs. Java wildcards</strong></p>
<p>Declaration-site variance 的方式会使得代码更加简明扼要，因为可变类仅修改一次，其它所有用到的地方都不用考虑。在Java，API的创建行为依据用户的期望，标准库总是使用通配符：<code>Function&lt;? super T, ? extends R&gt;</code>。Java8标准库到处都用到<code>Function</code>接口，例如<code>Stream.map</code>方法的声明如下，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Stream</span>&lt;T&gt; &#123;</span><br><span class="line">  &lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明地方对可变类型的一次修改即生效可使的代码更加简明和优雅。</p>
</blockquote>
<p>Kotlin 支持use-site variance，允许指定当前的类型参数。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">copyData</span><span class="params">(source: <span class="type">MutableList</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">				destination: <span class="type">MutableList</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (item <span class="keyword">in</span> source) &#123;</span><br><span class="line">    destination.add(item)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数将元素从一个集合copy到另一个集合。尽管两个集合都是不可变类型，但源集合仅仅用作读，目标集合仅用作写。这种情况，集合的元素类型并不需要匹配。你可以将一个字符串集合拷贝到一个<code>Any</code>类型的集合内。</p>
<p>为了便于比较，我们在该函数引入泛型参数，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: R, R&gt;</span> <span class="title">copyData</span><span class="params">(source: <span class="type">MutableList</span>&lt;<span class="type">T</span>&gt;,  <span class="comment">// Source&#x27;s element type should be a subtype of the destination&#x27;s element type</span></span></span></span><br><span class="line"><span class="params"><span class="function">						destination: <span class="type">MutableList</span>&lt;<span class="type">R</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (item <span class="keyword">in</span> source) &#123;</span><br><span class="line">    destination.add(item)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> ints = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> anyItems = mutableListOf&lt;Any&gt;()</span><br><span class="line">&gt;&gt;&gt; copyData(ints, anyItems)  <span class="comment">// You can call this function, because Int is a subtype of Any.</span></span><br><span class="line">&gt;&gt;&gt; println(anyItems)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>这里要求<code>destination</code>的元素的类型，需要是<code>source</code>的元素类型的父类型，否则无法调用<code>add()</code>。</p>
<p>不过Kotlin提供了更加优雅的方式来表述这种问题。当实现的函数内仅仅进行<code>out</code>、或仅仅进行<code>in</code>位置处理时，你可以直接使用可变修改器(variance modifier)定义类型参数。如下，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">copyData</span><span class="params">(source: <span class="type">MutableList</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;,  <span class="comment">// You can add the &quot;out&quot; keyword to the type usage: no methods with T in the &quot;in&quot; postion are used.</span></span></span></span><br><span class="line"><span class="params"><span class="function">				destination: <span class="type">MutableList</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (item <span class="keyword">in</span> source) &#123;</span><br><span class="line">    destination.add(item)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以在一个类型声明的任意类型参数的使用上指定一个可变性修改器：参数类型、本地变量类型、函数返回类型等等。这里出现的称为 <em>类型投影(type projection)</em> ：我们说<code>source</code>不是一个常规的<code>MutableList</code>，严格来说，是一个 <em>投影(projected)</em> 。你仅能调用那些返回泛型类型参数的方法，又或者，严格来说，仅能在<code>out</code>位置使用它。编译器禁止调用那些类型用作参数的方法(禁止调用 <code>in</code> 位置的方法)：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> list: MutableList&lt;<span class="keyword">out</span> Number&gt; = ...</span><br><span class="line">&gt;&gt;&gt; list.add(<span class="number">42</span>)</span><br><span class="line">Error: Out-projected type <span class="string">&#x27;MutableList&lt;out Number&gt;&#x27;</span> prohibits the use of <span class="string">&#x27;fun add(element: E): Boolean&#x27;</span></span><br></pre></td></tr></table></figure>
<p><em>Don’t be surprised that you can’t call some of the methods if you’re using a projected type</em> 。如果你需要调用它们，你需要使用常规类型取代投影类型。这要求你声明第二个参数类型，依赖其投影类型。譬如上述代码的<code>&lt;T: R, R&gt;</code>。</p>
<p>如果类型声明已经为<code>out</code>，在使用的使用再声明为协变是没意义的。譬如<code>List&lt;out T&gt;</code>，实际等同于<code>List&lt;T&gt;</code>，因为<code>List</code>的声明类本来就是<code>class List&lt;out T&gt;</code>。编译器会告警这样的投影是多余的。</p>
<p>类似的情况也出现在逆变类型上。我们可以使用<code>in</code>可变修改器表明该值是作为一个消费者，消费的类型将被反转(reversed)替换为父类型。如下，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">copyData</span><span class="params">(source: <span class="type">MutableList</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">				destination: <span class="type">MutableList</span>&lt;<span class="type">in</span> <span class="type">T</span>&gt;)</span></span> &#123;  <span class="comment">// Allows the destination element type to be a supertype of the source element type</span></span><br><span class="line">  <span class="keyword">for</span> (item <span class="keyword">in</span> source) &#123;</span><br><span class="line">    destination.add(item)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：use-site variance的声明在Kotlin是跟Java的通配类型对应的。<code>MutableList&lt;out T&gt;</code>在Kotlin等同于Java的<code>MutableList&lt;? extends T&gt;</code>。<code>in</code>投影<code>MutableList&lt;in T&gt;</code>等同于<code>MutableList&lt;? super T&gt;</code>。</p>
<h3 id="Star-projection-using-instead-of-a-type-argument"><a class="header-anchor" href="#Star-projection-using-instead-of-a-type-argument">¶</a>Star projection: using * instead of a type argument</h3>
<p>讨论类型检查和转换的时候，曾提及过 <em>star-projection</em> 这一语法用来告知 <em>no information about a generic argument</em> 。就是无法知道类型参数的信息。例如<code>List&lt;*&gt;</code>，就是包含未知元素类型的集合。</p>
<p>首先注意，<code>MutableList&lt;*&gt;</code>不是<code>MutableList&lt;Any?&gt;</code>(这很重要因为这里的<code>MutableList&lt;T&gt;</code>是不可变的<code>T</code>)。一个<code>MutableList&lt;Any?&gt;</code>告诉了你它包含的元素是任意类型。然而，<code>MutableList&lt;*&gt;</code>包含的元素是一个<strong>特定</strong>的元素，但我不清楚它是什么。这种特定的元素类型可能是<code>String</code>，也可能是其它，这样写的代码仅包含该特定类型的元素。因为你不知道类型是什么，你不能把任意东西都放进去，这会侵犯原来类型的代码调用。但可以从list获取元素，因为你知道所有存储于该list的元素，它都是<code>Any?</code>的子类型，</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> list: MutableList&lt;Any?&gt; = mutableListOf(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>, <span class="string">&quot;qwe&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> chars = mutableListOf(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> unknownElements: MutableList&lt;*&gt; =  <span class="comment">// MutableList&lt;*&gt; isn&#x27;t the same as MutableList&lt;Any?&gt;.</span></span><br><span class="line">			<span class="keyword">if</span> (Random().nextBoolean()) list <span class="keyword">else</span> chars</span><br><span class="line">&gt;&gt;&gt; unknownElements.add(<span class="number">42</span>)  <span class="comment">// The compiler forbids you to call this method.</span></span><br><span class="line">Error: Out-projected type <span class="string">&#x27;MutableList&lt;*&gt;&#x27;</span> prohibits the use of <span class="string">&#x27;fun add(element: E): Boolean&#x27;</span></span><br><span class="line">&gt;&gt;&gt; println(unknownElements.first())  <span class="comment">// It&#x27;s safe to get elements: first() returns an element of the Any? type.</span></span><br></pre></td></tr></table></figure>
<p>为什么编译器吧<code>MutableList&lt;*&gt;</code>引述为一个<code>out</code>-project类型？在上下文，<code>MutableList&lt;*&gt;</code>是被投影到<code>MutableList&lt;out Any?&gt;</code>：你无法知道元素的类型，但对于获取<code>Any?</code>类型的元素是安全的，而对于向里面添加元素则显得不安全。说到Java的通配类型，<code>MyType&lt;*&gt;</code>在Kotlin是和Java的<code>MyType&lt;?&gt;</code>相对应的。</p>
<p><strong>注意</strong> 对于逆变类型参数诸如<code>Consumer&lt;in T&gt;</code>，它的star-projection等价于<code>&lt;in Nothing&gt;</code>。实际上，你无法调用基于该投影的任何方法。如果类型是逆变的，它仅作为一个消费者，你不知道它实际上可以消费什么。因此，你不能让它消费。</p>
<p>当类型参数并不重要时，你可以使用 <em>star-projection</em> 的语法：在签名部分你不会用到类型参数的任何方法，或者你仅仅只读数据不关心它的具体类型。例如，你可以实现<code>printFirst</code>函数并接收<code>List&lt;*&gt;</code>作为参数：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printFirst</span><span class="params">(list: <span class="type">List</span>&lt;*&gt;)</span></span> &#123;  <span class="comment">// Every list is a possible argument.</span></span><br><span class="line">  <span class="keyword">if</span> (list.isNotEmpty()) &#123;  <span class="comment">// isNotEmpty() doesn&#x27;t use the generic type parameter.</span></span><br><span class="line">    println(list.first())  <span class="comment">// first() now returns Any?, but in this case that&#x27;s enough.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; printFirst(listOf(<span class="string">&quot;Svetlana&quot;</span>, <span class="string">&quot;Dmitry&quot;</span>))</span><br><span class="line">Svetlana</span><br></pre></td></tr></table></figure>
<p>如果是作为use-site variance，需要引入泛型类型参数：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">printFirst</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;  <span class="comment">// Again, every list is a possible argument.</span></span><br><span class="line">  <span class="keyword">if</span> (list.isNotEmpty()) &#123;</span><br><span class="line">    println(list.first())  <span class="comment">// first() now returns a value of T.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>带有星投影的语法更加简明，但它仅工作在你不需要关心实际泛型类型参数的情况：仅能使用产生该值的方法，不关心这些值的类型。</p>
<p>下面是另外一个星投影的例子，假设我们要验证用户输入，并声明<code>FieldValidator</code>。它包含的类型仅在<code>in</code>位置，因此它可以声明为逆变。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">FieldValidator</span>&lt;<span class="type">in T</span>&gt; &#123;  <span class="comment">// Interface declared as contravariant on T</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(input: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span>  <span class="comment">// T is used only in the &quot;in&quot; position(this method consumes a value of T).</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> DefaultStringValidator: FieldValidator&lt;String&gt; &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(input: <span class="type">String</span>)</span></span> = input.isNotEmpty()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> DefaultIntValidator: FieldValidator&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(input: <span class="type">Int</span>)</span></span> = input &gt;= <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想象你希望在相同的容器存储所有的validator，并根据输入类型获取正确的validator。最先你可能会用一个map来存储。并为任意类型存储validator，你可能需要声明一个<code>KClass</code>类型的map：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> validators = mutableMapOf&lt;KClass&lt;*&gt;, FieldValidator&lt;*&gt;&gt;()</span><br><span class="line">&gt;&gt;&gt; validators[String::<span class="keyword">class</span>] = DefaultStringValidator</span><br><span class="line">&gt;&gt;&gt; validators[<span class="built_in">Int</span>::<span class="keyword">class</span>] = DefaultIntValidator</span><br></pre></td></tr></table></figure>
<p>一旦这样做了，当使用这些validator时会觉得有困难。你不能用<code>FieldValidator&lt;*&gt;</code>来校验字符串。这不是类型安全的，因为编译器不知道它是哪种validator：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; validators[String::<span class="keyword">class</span>]!!.validate(<span class="string">&quot;&quot;</span>)  <span class="comment">// The value stored in the map has the type FieldValidator&lt;*&gt;.</span></span><br><span class="line">Error: Out-projected type <span class="string">&#x27;FieldValidator&lt;*&gt;&#x27;</span> prohibits the use of <span class="string">&#x27;fun validate(input: T): Boolean&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这类错误在以前介绍<code>MutableList&lt;*&gt;</code>描述过了。这类错误意味着输入特定类型到一个未知类型的入口，不是类型安全的。一种方式是，显式转换为指定的类型，但它既不是类型安全的、也不推荐这样做，不过下面可以列出代码作为参考一下：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> stringValidator = validators[String::<span class="keyword">class</span>] <span class="keyword">as</span> FieldValidator&lt;String&gt;  <span class="comment">// Warning: unchecked cast</span></span><br><span class="line">&gt;&gt;&gt; println(stringValidator.validate(<span class="string">&quot;&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>编译器发出告警关于unchecked 的转换。注意，这段代码仅会在校验时失败，不是在转换的地方，因为运行时所有泛型信息都被擦除。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> stringValidator = validators[<span class="built_in">Int</span>::<span class="keyword">class</span>] <span class="keyword">as</span> FieldValidator&lt;String&gt;  <span class="comment">// You get an incorrect validator(may be by mistake), but this code compiles.</span></span><br><span class="line">&gt;&gt;&gt; stringValidator.validate(<span class="string">&quot;&quot;</span>)  <span class="comment">// The real error is hidden until you use the validator.</span></span><br><span class="line">java.lang.ClassCastException:</span><br><span class="line">  java.lang.String cannot be cast to java.lang.Number at DefaultIntValidator.validate</span><br></pre></td></tr></table></figure>
<p>这段代码在编译期仅有一个告警，运行期由于泛型擦除，出现错误。</p>
<p>这种方案不是类型安全的(type-safe)、并且容易出错(error-prone)。因此，需要探讨一下其它可能的方案。</p>
<p>下面代码使用同一个<code>validators</code>map，但封装了所有的访问到两个泛型方法，仅包含正确的validator的注册和返回。该代码对未校验的转换会发出一个告警，但这里的<code>Validators</code>控制所有的访问，并确保不可能错误修改map。</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Validators &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> validators = <span class="comment">// Uses the same map as before, but now you can&#x27;t access it outside</span></span><br><span class="line">			mutableMapOf&lt;KClass&lt;*&gt;, FieldValidator&lt;*&gt;&gt;()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Any&gt;</span> <span class="title">registerValidator</span><span class="params">(kClass: <span class="type">KClass</span>&lt;<span class="type">T</span>&gt;, fieldValidator: <span class="type">FieldValidator</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    validators[kClass] = fieldValidator  <span class="comment">// Puts into the map only the correct key-value pairs, when a validator corresponds to a class</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Suppress(<span class="string">&quot;UNCECKED_CAST&quot;</span>)</span>  <span class="comment">// Suppresses the warning about the unchecked cast to FieldValidator&lt;T&gt;</span></span><br><span class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Any&gt;</span> <span class="title">get</span><span class="params">(kClass: <span class="type">KClass</span>&lt;<span class="type">T</span>&gt;)</span></span>: FieldValidator&lt;T&gt; = </span><br><span class="line">	validators[kClass] <span class="keyword">as</span>? FieldValidator&lt;T&gt; ?: <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;No validator for <span class="subst">$&#123;kClass.simpleName&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; Validators.registerValidator(String::<span class="keyword">class</span>, DefaultStringValidator)</span><br><span class="line">&gt;&gt;&gt; Validators.registerValidator(<span class="built_in">Int</span>::<span class="keyword">class</span>, DefaultIntValidator)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; println(Validators[String::<span class="keyword">class</span>].validate(<span class="string">&quot;Kotlin&quot;</span>))</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt;&gt;&gt; println(Validators[INt::<span class="keyword">class</span>].validate(<span class="number">42</span>))</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>现在你有了一个type-safe API。所有的unsafe逻辑被隐藏在类的body部分；通过本地化实现，确保了它不会被错误使用。编译器禁止你使用不正确的validator，因为<code>Validators</code>对象总是给定了正确的validator的实现：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; println(Validators[String::<span class="keyword">class</span>].validate(<span class="number">42</span>))  <span class="comment">// Now the &quot;get&quot; method returns an instance of FieldValidator&lt;String&gt;.</span></span><br><span class="line">Error: The integer literal does not conform to the expected type String</span><br></pre></td></tr></table></figure>
<p>严格来说，这是一种设计模式，并不算是Kotlin的特性内容。实现这种模式可以非常容易地对自定义泛型类型进行扩展。将unsafe的代码进行本地化分离避免误用。</p>
<p>Java的泛型和协变性通常被认为是该语言最棘手的部分。在Kotlin中，在Kotlin中我们尽最大努力使其易于理解和易于使用，同时有保留对Java的互操作性。</p>
<h2 id="Summary"><a class="header-anchor" href="#Summary">¶</a>Summary</h2>
<ul>
<li>Kotlin的泛型和Java的泛型非常相似：你可以以同样的方式声明泛型函数或类。</li>
<li>在Java，泛型类型的类型参数(type parameter)仅存在于编译期。</li>
<li>在使用类型时，不能同时将类型参数和<code>is</code>操作符一起使用，因为 <strong>类型参数是运行期擦除的</strong>。</li>
<li>类型参数和内联函数一起使用时可以标记上<code>reified</code>，它允许你在运行时操作<code>is</code>的校验以及获得<code>java.lang.Class</code>实例。</li>
<li>Variance is a way to specify whether one of two generic types with the same base class and different type arguments is a subtype or a supertype of the other one if one of the type arguments is the subtype of the other one.</li>
<li>你可以通过声明在类型参数上的类作为协变(covariant)，当且仅当该类型参数被用在<code>out</code>位置。</li>
<li>逆变(contravariant)则是相反：声明的类的类型参数仅用在<code>in</code>位置。</li>
<li>只读接口<code>List</code>在kotlin被声明为协变，意味着<code>List&lt;String&gt;</code>是<code>List&lt;Any&gt;</code>的子类型。</li>
<li><code>Function</code>类的接口声明就是第一个类型参数声明为逆变(contravariant)，以及第二个类型参数声明为协变(covariant)，可以使得<code>(Animal) -&gt; Int</code>是<code>(Cat) -&gt; Number</code>的类型子类。</li>
<li>Kotlin可以让你同时对泛型类(declaration-site variance)和特定泛型类型(use-site variance)指定可变性(variance)。</li>
<li>星投影(star-projection)语法被用于类型参数未知或不重要/不敏感的情况。</li>
</ul>
</div></article><nav class="article-nav"><div class="article-nav-prev"><a href="/2022/01/28/kotlin/09_annotations_and_reflection/">注解和反射</a></div><div class="article-nav-next"><a href="/2021/12/27/kotlin/07_higher-order_functions~lambdas_as_parameters_and_return_values/">高阶函数：lambda作为参数和返回</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2022/01/07/kotlin/08_generics/';
var disqus_title = '泛型';
var disqus_url = 'https://galudisu.info/2022/01/07/kotlin/08_generics/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>