<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>Scala中的Future和ExecutionContext</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">Scala中的Future和ExecutionContext</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2017-05-23</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/akka/">akka</a></p><p class="meta-item meta-category"><span class="meta-item-title"></span><i class="icon-bookmark"> </i><a class="category-link" href="/categories/future/">future</a></p></div><div class="article-content"><p>Scala 这个语言可以用得很复杂、也可以用得很简洁。它在 Java 并发和 OO 之上做了进一步的抽象，将代码量大大降低。<br>
最近流行的很多项目都使用 Scala，比如 Akka，Spark，Kafka，Spray，Play Framework，足见它是一门生产力很高的语言。<br>
这里主要总结了下一些并发模式和并发线程池需要注意的地方。</p>
<span id="more"></span>
<p><img src="/img/akka/future/scala_future.jpg" alt="Future"></p>
<h2 id="Scala中的Future并发模式"><a class="header-anchor" href="#Scala中的Future并发模式">¶</a>Scala中的Future并发模式</h2>
<h4 id="一切皆Future："><a class="header-anchor" href="#一切皆Future：">¶</a>一切皆Future：</h4>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mFuture = future &#123;</span><br><span class="line">  <span class="type">Thread</span> sleep <span class="number">1000</span></span><br><span class="line">  <span class="string">&quot;result&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> result = <span class="type">Await</span> result (mFuture, <span class="number">3</span> seconds)</span><br></pre></td></tr></table></figure>
<h4 id="Callback的几种方式："><a class="header-anchor" href="#Callback的几种方式：">¶</a>Callback的几种方式：</h4>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f.onComplete &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Success</span>(result) =&gt;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Failure</span>(ex) =&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Await</span> result (mFuture, <span class="number">5</span> seconds)</span><br></pre></td></tr></table></figure>
<h4 id="Timeout-Fallback"><a class="header-anchor" href="#Timeout-Fallback">¶</a>Timeout Fallback:</h4>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> searchFuture = search(worktime)</span><br><span class="line"><span class="keyword">val</span> fallback = after(timeout, context.system.scheduler) &#123;</span><br><span class="line">  <span class="type">Future</span> successful <span class="string">s&quot;<span class="subst">$worktime</span> ms &gt; <span class="subst">$timeout</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Future</span> firstCompletedOf <span class="type">Seq</span>(searchFuture, fallback)</span><br></pre></td></tr></table></figure>
<h4 id="Future-之后的运算-map-filter-成其他-Future："><a class="header-anchor" href="#Future-之后的运算-map-filter-成其他-Future：">¶</a>Future 之后的运算 map / filter 成其他 Future：</h4>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f.map &#123; r1 =&gt;</span><br><span class="line">    ...</span><br><span class="line">    r2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多个-Future-链的处理-flatMap"><a class="header-anchor" href="#多个-Future-链的处理-flatMap">¶</a>多个 Future 链的处理 flatMap:</h4>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> nestedFuture: <span class="type">Future</span>[<span class="type">Future</span>[<span class="type">Boolean</span>]] = heatWater(<span class="type">Water</span>(<span class="number">25</span>)).map &#123;</span><br><span class="line">  water =&gt; temperatureOkay(water)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> flatFuture: <span class="type">Future</span>[<span class="type">Boolean</span>] = heatWater(<span class="type">Water</span>(<span class="number">25</span>)).flatMap &#123;</span><br><span class="line">  water =&gt; temperatureOkay(water)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多个-Future-的链合并的另一种方式："><a class="header-anchor" href="#多个-Future-的链合并的另一种方式：">¶</a>多个 Future 的链合并的另一种方式：</h4>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> f = <span class="keyword">for</span> &#123;</span><br><span class="line">  result1 &lt;- remoteCall1</span><br><span class="line">  result2 &lt;-  remoteCall2</span><br><span class="line">&#125; <span class="keyword">yield</span> <span class="type">List</span>(result1, result2)</span><br></pre></td></tr></table></figure>
<p>假如 future 定义在 for 之前则会并发执行，否则会顺序执行。另外，假如顺序执行 result1 可以作为参数传递到 remoteCall2 中。</p>
<h4 id="转换-Future-List-成-List-Future-map-to"><a class="header-anchor" href="#转换-Future-List-成-List-Future-map-to">¶</a>转换 Future List 成 List Future (map to)</h4>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Future</span>.sequence(list) <span class="comment">//(并发执行)</span></span><br></pre></td></tr></table></figure>
<h4 id="转换-Future-List-成单个-Future-map-to"><a class="header-anchor" href="#转换-Future-List-成单个-Future-map-to">¶</a>转换 Future List 成单个 Future (map to)</h4>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Future</span>.reduce(list)(f)</span><br></pre></td></tr></table></figure>
<p>Option 和 getOrElse 经常用在 Future 执行中。</p>
<h4 id="Scala-中的并发任务执行体-ExecutionContext"><a class="header-anchor" href="#Scala-中的并发任务执行体-ExecutionContext">¶</a>Scala 中的并发任务执行体 ExecutionContext</h4>
<p>Scala 中的 ExecutionContext 和 Java 的线程池的概念非常相似。都是执行具体 Task 的执行体。</p>
<h4 id="Scala-中默认的线程池："><a class="header-anchor" href="#Scala-中默认的线程池：">¶</a>Scala 中默认的线程池：</h4>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">ExecutionContext</span>.<span class="type">Implicits</span>.global</span><br></pre></td></tr></table></figure>
<p>是最方便的做法，如果不考虑优化和性能，在所有需要 ExecutionContext 的地方引用即可。当然这在生产环境是行不通的，原因是假如有 Task Block 了整个 global 线程池，应用将变得不可响应，即使 Block 不一定发生在本应用中，比如数据库的操作引起的 blocking 。</p>
<p>可以修改默认线程池的大小</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="type">Dscala</span>.concurrent.context.numThreads=<span class="number">8</span> -<span class="type">Dscala</span>.concurrent.context.maxThreads=<span class="number">8</span></span><br></pre></td></tr></table></figure>
<h4 id="自定义线程池"><a class="header-anchor" href="#自定义线程池">¶</a>自定义线程池</h4>
<p>创建固定大小线程池</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> ec = <span class="type">ExecutionContext</span>.fromExecutor(<span class="type">Executors</span>.newFixedThreadPool(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p>假如熟悉 Java 线程池的话，线程池的创建和 Java 中完全一样，可以套用。</p>
<h4 id="Scala-Akka-中的-Dispatcher"><a class="header-anchor" href="#Scala-Akka-中的-Dispatcher">¶</a>Scala &amp; Akka 中的 Dispatcher</h4>
<p>定义一个 Dispatcher：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">my-dispatcher &#123;</span><br><span class="line">  # <span class="type">Dispatcher</span> is the name of the event-based dispatcher</span><br><span class="line">  <span class="class"><span class="keyword">type</span> </span>= <span class="type">Dispatcher</span></span><br><span class="line">  # <span class="type">What</span> kind of <span class="type">ExecutionService</span> to use</span><br><span class="line">  executor = <span class="string">&quot;fork-join-executor&quot;</span></span><br><span class="line">  # <span class="type">Configuration</span> <span class="keyword">for</span> the fork join pool</span><br><span class="line">  fork-join-executor &#123;</span><br><span class="line">    # <span class="type">Min</span> number of threads to cap factor-based parallelism number to</span><br><span class="line">    parallelism-min = <span class="number">2</span></span><br><span class="line">    # <span class="type">Parallelism</span> (threads) ... ceil(available processors * factor)</span><br><span class="line">    parallelism-factor = <span class="number">2.0</span></span><br><span class="line">    # <span class="type">Max</span> number of threads to cap factor-based parallelism number to</span><br><span class="line">    parallelism-max = <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">  # <span class="type">Throughput</span> defines the maximum number of messages to be</span><br><span class="line">  # processed per actor before the thread jumps to the next actor.</span><br><span class="line">  # <span class="type">Set</span> to <span class="number">1</span> <span class="keyword">for</span> as fair as possible.</span><br><span class="line">  throughput = <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">my-thread-pool-dispatcher &#123;</span><br><span class="line">  # <span class="type">Dispatcher</span> is the name of the event-based dispatcher</span><br><span class="line">  <span class="class"><span class="keyword">type</span> </span>= <span class="type">Dispatcher</span></span><br><span class="line">  # <span class="type">What</span> kind of <span class="type">ExecutionService</span> to use</span><br><span class="line">  executor = <span class="string">&quot;thread-pool-executor&quot;</span></span><br><span class="line">  # <span class="type">Configuration</span> <span class="keyword">for</span> the thread pool</span><br><span class="line">  thread-pool-executor &#123;</span><br><span class="line">    # minimum number of threads to cap factor-based core number to</span><br><span class="line">    core-pool-size-min = <span class="number">2</span></span><br><span class="line">    # <span class="type">No</span> of core threads ... ceil(available processors * factor)</span><br><span class="line">    core-pool-size-factor = <span class="number">2.0</span></span><br><span class="line">    # maximum number of threads to cap factor-based number to</span><br><span class="line">    core-pool-size-max = <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">  # <span class="type">Throughput</span> defines the maximum number of messages to be</span><br><span class="line">  # processed per actor before the thread jumps to the next actor.</span><br><span class="line">  # <span class="type">Set</span> to <span class="number">1</span> <span class="keyword">for</span> as fair as possible.</span><br><span class="line">  throughput = <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Scala 代码中引用引用之前定义的 Dispatcher：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> executionContext = system.dispatchers.lookup(<span class="string">&quot;my-dispatcher&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>给某个 Actor 指定 dispatcher：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myActor = context.actorOf(<span class="type">Props</span>[<span class="type">MyActor</span>].withDispatcher(<span class="string">&quot;my-dispatcher&quot;</span>), <span class="string">&quot;myactor1&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="最佳实践"><a class="header-anchor" href="#最佳实践">¶</a>最佳实践</h4>
<p>将不同类型的运算进行 dispatcher 隔离：</p>
<p>给 blocking I/O 创建单独的线程池：</p>
<p>因为 JDBC 没有 non-blocking API，所以为 DB R/W Heavey R/W 这些 Block 操作创建单独的 dispatcher。并在不同的 dispatcher 中执行不同类型的 Future 计算。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Contexts</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> simpleDbLookups: <span class="type">ExecutionContext</span> = <span class="type">Akka</span>.system.dispatchers.lookup(<span class="string">&quot;contexts.simple-db-lookups&quot;</span>)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> expensiveDbLookups: <span class="type">ExecutionContext</span> = <span class="type">Akka</span>.system.dispatchers.lookup(<span class="string">&quot;contexts.expensive-db-lookups&quot;</span>)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> dbWriteOperations: <span class="type">ExecutionContext</span> = <span class="type">Akka</span>.system.dispatchers.lookup(<span class="string">&quot;contexts.db-write-operations&quot;</span>)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> expensiveCpuOperations: <span class="type">ExecutionContext</span> = <span class="type">Akka</span>.system.dispatchers.lookup(<span class="string">&quot;contexts.expensive-cpu-operations&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理，需要给 CPU 密集计算创建单独的线程池。</p>
</div></article><nav class="article-nav"><div class="article-nav-prev"><a href="/2017/05/24/akka/streaming/akka-reactive-streams/">Akka Reactive Streams</a></div><div class="article-nav-next"><a href="/2017/05/18/akka/http/spray-to-akka-http/">Migrating from Spray to Akka</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2017/05/23/akka/future/future-and-execute/';
var disqus_title = 'Scala中的Future和ExecutionContext';
var disqus_url = 'https://galudisu.info/2017/05/23/akka/future/future-and-execute/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>