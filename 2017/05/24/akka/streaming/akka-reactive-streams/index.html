<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>Akka Reactive Streams</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">Akka Reactive Streams</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2017-05-24</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/akka/">akka</a></p><p class="meta-item meta-category"><span class="meta-item-title"></span><i class="icon-bookmark"> </i><a class="category-link" href="/categories/streaming/">streaming</a></p></div><div class="article-content"><p>Akka Streams have these key properties:</p>
<ul>
<li>They implement the <a target="_blank" rel="noopener" href="https://github.com/reactive-streams/reactive-streams-jvm/tree/v1.0.0">Reactive Streams specification</a>, whose three main goals backpressure, async and non-blocking boundaries and interoperability between different implementations do fully apply for Akka Streams too.</li>
<li>They provide an abstraction for an evaluation engine for the streams, which is called <code>Materializer</code>.</li>
<li>Programs are formulated as reusable building blocks, which are represented as the three main types <code>Source</code>, <code>Sink</code> and <code>Flow</code>. The building blocks form a graph whose evaluation is based on the <code>Materializer</code> and needs to be explicitly triggered.<br>
In the following a deeper introduction in how to use the three main types shall be given.</li>
</ul>
<span id="more"></span>
<h2 id="Relationship-with-Reactive-Streams"><a class="header-anchor" href="#Relationship-with-Reactive-Streams">¶</a>Relationship with Reactive Streams</h2>
<p>The Akka Streams API is completely decoupled from the Reactive Streams interfaces. While Akka Streams focus on the formulation of transformations on data streams the scope of Reactive Streams is just to define a common mechanism of how to move data across an asynchronous boundary without losses, buffering or resource exhaustion.</p>
<p>The relationship between these two is that the Akka Streams API is geared towards end-users while the Akka Streams implementation uses the Reactive Streams interfaces internally to pass data between the different processing stages. For this reason you will not find any resemblance between the Reactive Streams interfaces and the Akka Streams API. This is in line with the expectations of the Reactive Streams project, whose primary purpose is to define interfaces such that different streaming implementation can interoperate; it is not the purpose of Reactive Streams to describe an end-user API.</p>
<h2 id="Source"><a class="header-anchor" href="#Source">¶</a>Source</h2>
<p>A <code>Source</code> is a data creator, it serves as an input source to the stream. Each <code>Source</code> has a single output channel and no input channel. All the data flows through the output channel to whatever is connected to the <code>Source</code>.</p>
<p><img src="/img/akka/streaming/akka-streams-source.png" alt="Source"></p>
<p>A <code>Source</code> can be created in multiple ways:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val s = Source.empty</span></span><br><span class="line">s: akka.stream.scaladsl.Source[Nothing,akka.NotUsed] = ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val s = Source.single(<span class="string">&quot;single element&quot;</span>)</span></span><br><span class="line">s: akka.stream.scaladsl.Source[String,akka.NotUsed] = ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val s = Source(1 to 3)</span></span><br><span class="line">s: akka.stream.scaladsl.Source[Int,akka.NotUsed] = ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val s = Source(Future(<span class="string">&quot;single value from a Future&quot;</span>))</span></span><br><span class="line">s: akka.stream.scaladsl.Source[String,akka.NotUsed] = ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">s runForeach println</span></span><br><span class="line">res0: scala.concurrent.Future[akka.Done] = ...</span><br><span class="line">single value from a Future</span><br></pre></td></tr></table></figure>
<p>In the above cases we fed the <code>Source</code> with finite data, which means they will terminate eventually. One should not forget, that Reactive Streams are lazy and asynchronous by default. This means one explicitly has to request the evaluation of the stream. In Akka Streams this can be done through the <code>run*</code> methods. The <code>runForeach</code> would be no different to the well known <code>foreach</code> function - through the <code>run</code> addition it makes explicit that we ask for an evaluation of the stream. Since finite data is boring, we continue with infinite one:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val s = Source.repeat(5)</span></span><br><span class="line">s: akka.stream.scaladsl.Source[Int,akka.NotUsed] = ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">s take 3 runForeach println</span></span><br><span class="line">res1: scala.concurrent.Future[akka.Done] = ...</span><br><span class="line">5</span><br><span class="line">5</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>With the <code>take</code> method we can create an artificial stop point that prevents us from evaluating indefinitely. Since actor support is built-in, we can also easily feed the stream with messages that are sent to an actor:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def run(actor: ActorRef) = &#123;</span><br><span class="line">  Future &#123; Thread.sleep(300); actor ! 1 &#125;</span><br><span class="line">  Future &#123; Thread.sleep(200); actor ! 2 &#125;</span><br><span class="line">  Future &#123; Thread.sleep(100); actor ! 3 &#125;</span><br><span class="line">&#125;</span><br><span class="line">val s = Source</span><br><span class="line">  .actorRef[Int](bufferSize = 0, OverflowStrategy.fail)</span><br><span class="line">  .mapMaterializedValue(run)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">s runForeach println</span></span><br><span class="line">res1: scala.concurrent.Future[akka.Done] = ...</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>We can see that the <code>Futures</code> are executed asynchronously on different threads, which explains the result. In the above example a buffer for the incoming elements is not necessary and therefore with <code>OverflowStrategy.fail</code> we can configure that the stream should fail on a buffer overflow. Especially through this actor interface, we can feed the stream through any data source. It doesn’t matter if the data is created by the same thread, by a different one, by another process or if they come from a remote system over the Internet.</p>
<h2 id="Sink"><a class="header-anchor" href="#Sink">¶</a>Sink</h2>
<p>A <code>Sink</code> is basically the opposite of a <code>Source</code>. It is the endpoint of a stream and therefore consumes data. A <code>Sink</code> has a single input channel and no output channel. <code>Sinks</code> are especially needed when we want to specify the behavior of the data collector in a reusable way and without evaluating the stream. The already known <code>run*</code> methods do not allow us these properties, therefore it is preferred to use <code>Sink</code> instead.</p>
<p><img src="/img/akka/streaming/akka-streams-sink.png" alt="Sink"></p>
<p>A short example of a <code>Sink</code> in action:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val <span class="built_in">source</span> = Source(1 to 3)</span></span><br><span class="line">source: akka.stream.scaladsl.Source[Int,akka.NotUsed] = ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val sink = Sink.foreach[Int](elem =&gt; println(s<span class="string">&quot;sink received: <span class="variable">$elem</span>&quot;</span>))</span></span><br><span class="line">sink: akka.stream.scaladsl.Sink[Int,scala.concurrent.Future[akka.Done]] = ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val flow = <span class="built_in">source</span> to sink</span></span><br><span class="line">flow: akka.stream.scaladsl.RunnableGraph[akka.NotUsed] = ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">flow.run()</span></span><br><span class="line">res3: akka.NotUsed = NotUsed</span><br><span class="line">sink received: 1</span><br><span class="line">sink received: 2</span><br><span class="line">sink received: 3</span><br></pre></td></tr></table></figure>
<p>Connecting a <code>Source</code> to a <code>Sink</code> can be done with the <code>to</code> method. It returns a so called <code>RunnableFlow</code>, which is as we will later see a special form of a <code>Flow</code> - a stream that can be executed by just calling its <code>run()</code> method.</p>
<p><img src="/img/akka/streaming/akka-streams-runaable-flow.png" alt="run"></p>
<p>It is of course possible to forward all values that arrive at a sink to an actor:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> actor = system.actorOf(<span class="type">Props</span>(<span class="keyword">new</span> <span class="type">Actor</span> &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> msg =&gt; println(<span class="string">s&quot;actor received: <span class="subst">$msg</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> sink = <span class="type">Sink</span>.actorRef[<span class="type">Int</span>](actor, onCompleteMessage = <span class="string">&quot;stream completed&quot;</span>)</span><br><span class="line">sink: akka.stream.scaladsl.<span class="type">Sink</span>[<span class="type">Int</span>,akka.<span class="type">NotUsed</span>] = ...</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> runnable = <span class="type">Source</span>(<span class="number">1</span> to <span class="number">3</span>) to sink</span><br><span class="line">runnable: akka.stream.scaladsl.<span class="type">RunnableGraph</span>[akka.<span class="type">NotUsed</span>] = ...</span><br><span class="line"></span><br><span class="line">scala&gt; runnable.run()</span><br><span class="line">res3: akka.<span class="type">NotUsed</span> = <span class="type">NotUsed</span></span><br><span class="line">actor received: <span class="number">1</span></span><br><span class="line">actor received: <span class="number">2</span></span><br><span class="line">actor received: <span class="number">3</span></span><br><span class="line">actor received: stream completed</span><br></pre></td></tr></table></figure>
<h2 id="Flow"><a class="header-anchor" href="#Flow">¶</a>Flow</h2>
<p>Data sources and sinks are great if you need a connection between Akka streams and an existing system but one can not really do anything with them. Flows are the last missing piece in the Akka Streams base abstraction. They act as a connector between different streams and can be used to transform its elements.</p>
<p><img src="/img/akka/streaming/akka-streams-flow.png" alt="Flow"></p>
<p>If a <code>Flow</code> is connected to a <code>Source</code> a new <code>Source</code> is the result. Likewise, a <code>Flow</code> connected to a <code>Sink</code> creates a new <code>Sink</code>. And a <code>Flow</code> connected with both a <code>Source</code> and a <code>Sink</code> results in a <code>RunnableFlow</code>. Therefore, they sit between the input and the output channel but by themselves do not correspond to one of the flavors as long as they are not connected to either a <code>Source</code> or a <code>Sink</code>.</p>
<p><img src="/img/akka/streaming/akka-streams-source-flow-sink.png" alt=""></p>
<p>In order to get a better understanding of <code>Flows</code>, we will have a look at some examples:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val <span class="built_in">source</span> = Source(1 to 3)</span></span><br><span class="line">source: akka.stream.scaladsl.Source[Int,akka.NotUsed] = ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val sink = Sink.foreach[Int](println)</span></span><br><span class="line">sink: akka.stream.scaladsl.Sink[Int,scala.concurrent.Future[akka.Done]] = ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val invert = Flow[Int].map(elem =&gt; elem * -1)</span></span><br><span class="line">invert: akka.stream.scaladsl.Flow[Int,Int,akka.NotUsed] = ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val doubler = Flow[Int].map(elem =&gt; elem * 2)</span></span><br><span class="line">doubler: akka.stream.scaladsl.Flow[Int,Int,akka.NotUsed] = ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val runnable = <span class="built_in">source</span> via invert via doubler to sink</span></span><br><span class="line">runnable: akka.stream.scaladsl.RunnableGraph[akka.NotUsed] = ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">runnable.run()</span></span><br><span class="line">res10: akka.NotUsed = NotUsed</span><br><span class="line">-2</span><br><span class="line">-4</span><br><span class="line">-6</span><br></pre></td></tr></table></figure>
<p>Via the <code>via</code> method we can connect a <code>Source</code> with a <code>Flow</code>. We need to specify the input type because the compiler can’t infer it for us. As we can already see in this simple example, the flows <code>invert</code> and <code>double</code> are completely independent from any data producers and consumers. They only transform the data and forward it to the output channel. This means that we can reuse a flow among multiple streams:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val s1 = Source(1 to 3) via invert to sink</span></span><br><span class="line">s1: akka.stream.scaladsl.RunnableGraph[akka.NotUsed] = ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val s2 = Source(-3 to -1) via invert to sink</span></span><br><span class="line">s2: akka.stream.scaladsl.RunnableGraph[akka.NotUsed] = ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">s1.run()</span></span><br><span class="line">res10: akka.NotUsed = NotUsed</span><br><span class="line">-1</span><br><span class="line">-2</span><br><span class="line">-3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">s2.run()</span></span><br><span class="line">res11: akka.NotUsed = NotUsed</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p><code>s1</code> and <code>s2</code> represent completely new streams - they do not share any data through their building blocks.</p>
<h2 id="Unbounded-Data-Streams"><a class="header-anchor" href="#Unbounded-Data-Streams">¶</a>Unbounded Data Streams</h2>
<p>Before we move on we should first revisit some of the key aspects of Reactive Streams. An unbounded number of elements can arrive at any point and can put a stream in different states. Beside from a runnable stream, which is the usual state, a stream may get stopped either through an error or through a signal that denotes that no further data will arrive. A stream can be modeled in a graphical way by marking events on a timeline as it is the case here:</p>
<p><img src="/img/akka/streaming/rcmwZ.png" alt=""></p>
<p>We have already seen runnable flows in the examples of the previous section. We get a <code>RunnableGraph</code> whenever a stream can actually be materialized, which means that a <code>Sink</code> is connected to a <code>Source</code>. So far we always materialized to the value <code>Unit</code>, which can be seen in the types:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> source: <span class="type">Source</span>[<span class="type">Int</span>, <span class="type">NotUsed</span>] = <span class="type">Source</span>(<span class="number">1</span> to <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> sink: <span class="type">Sink</span>[<span class="type">Int</span>, <span class="type">Future</span>[<span class="type">Done</span>]] = <span class="type">Sink</span>.foreach[<span class="type">Int</span>](println)</span><br><span class="line"><span class="keyword">val</span> flow: <span class="type">Flow</span>[<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">NotUsed</span>] = <span class="type">Flow</span>[<span class="type">Int</span>].map(x =&gt; x)</span><br></pre></td></tr></table></figure>
<p>For <code>Source</code> and <code>Sink</code> the second type parameter and for <code>Flow</code> the third type parameter denote the materialized value. Throughout this answer, the full meaning of materialization shall not be explained. However, further details about materialization can be found at the <a target="_blank" rel="noopener" href="http://doc.akka.io/docs/akka/2.4.2-RC1/scala/stream/index.html">official documentation</a>. For now the only thing we need to know is that the materialized value is what we get when we run a stream. Since we were only interested in side effects so far, we got <code>Unit</code> as the materialized value. The exception to this was a materialization of a sink, which resulted in a <code>Future</code>. It gave us back a <code>Future</code>, since this value can denote when the stream that is connected to the sink has been ended. So far, the previous code examples were nice to explain the concept but they were also boring because we only dealt with finite streams or with very simple infinite ones. To make it more interesting, in the following a full asynchronous and unbounded stream shall be explained.</p>
<h2 id="ClickStream-Example"><a class="header-anchor" href="#ClickStream-Example">¶</a>ClickStream Example</h2>
<p>As an example, we want to have a stream that captures click events. To make it more challenging, let’s say we also want to group click events that happen in a short time after each other. This way we could easily discover double, triple or tenfold clicks. Furthermore, we want to filter out all single clicks. Take a deep breath and imagine how you would solve that problem in an imperative manner. I bet no one would be able to implement a solution that works correctly on the first try. In a reactive fashion this problem is trivial to solve. In fact, the solution is so simple and straightforward to implement that we can even express it in a diagram that directly describes the behavior of the code:</p>
<p><img src="/img/akka/streaming/3tH8R.png" alt=""></p>
<p>The gray boxes are functions that describe how one stream is transformed into another. With the <code>throttle</code> function we accumulate clicks within 250 milliseconds, the <code>map</code> and <code>filter</code> functions should be self-explanatory. The color orbs represent an event and the arrows depict how they flow through our functions. Later in the processing steps, we get less and less elements that flow through our stream, since we group them together and filter them out. The code for this image would look something like this:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> multiClickStream = clickStream</span><br><span class="line">    .throttle(<span class="number">250.</span>millis)</span><br><span class="line">    .map(clickEvents =&gt; clickEvents.length)</span><br><span class="line">    .filter(numberOfClicks =&gt; numberOfClicks &gt;= <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>The whole logic can be represented in only four lines of code! In Scala, we could write it even shorter:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> multiClickStream = clickStream.throttle(<span class="number">250.</span>millis).map(_.length).filter(_ &gt;= <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>The definition of <code>clickStream</code> is a little bit more complex but this is only the case because the example program runs on the JVM, where capturing of click events is not easily possible. Another complication is that Akka by default doesn’t provide the <code>throttle</code> function. Instead we had to write it by ourselves. Since this function is (as it is the case for the <code>map</code> or <code>filter</code> functions) reusable across different use cases I don’t count these lines to the number of lines we needed to implement the logic. In imperative languages however, it is normal that logic can’t be reused that easily and that the different logical steps happen all at one place instead of being applied sequentially, which means that we probably would have misshaped our code with the throttling logic. The full code example is available as a <a target="_blank" rel="noopener" href="https://gist.github.com/sschaef/8533e23f5856bd459e27#file-clickstreamexample-scala">gist</a> and shall not be discussed here any further.</p>
<h2 id="SimpleWebServer-Example"><a class="header-anchor" href="#SimpleWebServer-Example">¶</a>SimpleWebServer Example</h2>
<p>What should be discussed instead is another example. While the click stream is a nice example to let Akka Streams handle a real world example, it lacks the power to show parallel execution in action. The next example shall represent a small web server that can handle multiple requests in parallel. The web sever shall be able to accept incoming connections and receive byte sequences from them that represent printable ASCII signs. These byte sequences or strings should be split at all newline-characters into smaller parts. After that, the server shall respond to the client with each of the split lines. Alternatively, it could do something else with the lines and give a special answer token, but we want to keep it simple in this example and therefore don’t introduce any fancy features. Remember, the server needs to be able to handle multiple requests at the same time, which basically means that no request is allowed to block any other request from further execution. Solving all of these requirements can be hard in an imperative way - with Akka Streams however, we shouldn’t need more than a few lines to solve any of these. First, let’s have an overview over the server itself:</p>
<p><img src="/img/akka/streaming/Ji6AG.png" alt=""></p>
<p>Basically, there are only three main building blocks. The first one needs to accept incoming connections. The second one needs to handle incoming requests and the third one needs to send a response. Implementing all of these three building blocks is only a little bit more complicated than implementing the click stream:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mkServer</span></span>(address: <span class="type">String</span>, port: <span class="type">Int</span>)(<span class="keyword">implicit</span> system: <span class="type">ActorSystem</span>, materializer: <span class="type">Materializer</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">import</span> system.dispatcher</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> connectionHandler: <span class="type">Sink</span>[<span class="type">Tcp</span>.<span class="type">IncomingConnection</span>, <span class="type">Future</span>[<span class="type">Unit</span>]] =</span><br><span class="line">    <span class="type">Sink</span>.foreach[<span class="type">Tcp</span>.<span class="type">IncomingConnection</span>] &#123; conn =&gt;</span><br><span class="line">      println(<span class="string">s&quot;Incoming connection from: <span class="subst">$&#123;conn.remoteAddress&#125;</span>&quot;</span>)</span><br><span class="line">      conn.handleWith(serverLogic)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> incomingCnnections: <span class="type">Source</span>[<span class="type">Tcp</span>.<span class="type">IncomingConnection</span>, <span class="type">Future</span>[<span class="type">Tcp</span>.<span class="type">ServerBinding</span>]] =</span><br><span class="line">    <span class="type">Tcp</span>().bind(address, port)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> binding: <span class="type">Future</span>[<span class="type">Tcp</span>.<span class="type">ServerBinding</span>] =</span><br><span class="line">    incomingCnnections.to(connectionHandler).run()</span><br><span class="line"></span><br><span class="line">  binding onComplete &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Success</span>(b) =&gt;</span><br><span class="line">      println(<span class="string">s&quot;Server started, listening on: <span class="subst">$&#123;b.localAddress&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Failure</span>(e) =&gt;</span><br><span class="line">      println(<span class="string">s&quot;Server could not be bound to <span class="subst">$address</span>:<span class="subst">$port</span>: <span class="subst">$&#123;e.getMessage&#125;</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The function <code>mkServer</code> takes (besides from the address and the port of the server) also an actor system and a materializer as implicit parameters. The control flow of the server is represented by <code>binding</code>, which takes a source of incoming connections and forwards them to a sink of incoming connections. Inside of <code>connectionHandler</code>, which is our sink, we handle every connection by the flow  <code>serverLogic</code>, which will be described later. <code>binding</code> returns a <code>Future</code>, which completes when the server has been started or the start failed, which could be the case when the port is already taken by another process. The code however, doesn’t completely reflect the graphic as we can’t see a building block that handles responses. The reason for this is that the connection already provides this logic by itself. It is a bidirectional flow and not just a unidirectional one as the flows we have seen in the previous examples. As it was the case for materialization, such complex flows shall not be explained here. The <a target="_blank" rel="noopener" href="http://doc.akka.io/docs/akka/2.4.2-RC1/scala/stream/index.html">official documentation</a> has plenty of material to cover more complex flow graphs. For now it is enough to know that  <code>Tcp.IncomingConnection</code> represents a connection that knows how to receive requests and how to send responses. The part that is still missing is the <code>serverLogic</code> building block. It can look like this:</p>
<p><img src="/img/akka/streaming/xq4p8.png" alt=""></p>
<p>Once again, we are able to split the logic in several simple building blocks that all together form the flow of our program. First we want to split our sequence of bytes in lines, which we have to do whenever we find a newline character. After that, the bytes of each line need to be converted to a string because working with raw bytes is cumbersome. Overall we could receive a binary stream of a complicated protocol, which would make working with the incoming raw data extremely challenging. Once we have a readable string, we can create an answer. For simplicity reasons the answer can be anything in our case. In the end, we have to convert back our answer to a sequence of bytes that can be sent over the wire. The code for the entire logic may look like this:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> serverLogic: <span class="type">Flow</span>[<span class="type">ByteString</span>, <span class="type">ByteString</span>, <span class="type">Unit</span>] = &#123;</span><br><span class="line">  <span class="keyword">val</span> delimiter = <span class="type">Framing</span>.delimiter(</span><br><span class="line">    <span class="type">ByteString</span>(<span class="string">&quot;\n&quot;</span>),</span><br><span class="line">    maximumFrameLength = <span class="number">256</span>,</span><br><span class="line">    allowTruncation = <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> receiver = <span class="type">Flow</span>[<span class="type">ByteString</span>].map &#123; bytes =&gt;</span><br><span class="line">    <span class="keyword">val</span> message = bytes.utf8String</span><br><span class="line">    println(<span class="string">s&quot;Server received: <span class="subst">$message</span>&quot;</span>)</span><br><span class="line">    message</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> responder = <span class="type">Flow</span>[<span class="type">String</span>].map &#123; message =&gt;</span><br><span class="line">    <span class="keyword">val</span> answer = <span class="string">s&quot;Server hereby responds to message: <span class="subst">$message</span>\n&quot;</span></span><br><span class="line">    <span class="type">ByteString</span>(answer)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">Flow</span>[<span class="type">ByteString</span>]</span><br><span class="line">    .via(delimiter)</span><br><span class="line">    .via(receiver)</span><br><span class="line">    .via(responder)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We already know that <code>serverLogic</code> is a flow that takes a <code>ByteString</code> and has to produce a <code>ByteString</code>. With <code>delimiter</code> we can split a <code>ByteString</code> in smaller parts - in our case it needs to happen whenever a newline character occurs. <code>receiver</code> is the flow that takes all of the split byte sequences and converts them to a string. This is of course a dangerous conversion, since only printable ASCII characters should be converted to a string but for our needs it is good enough. <code>responder</code> is the last component and is responsible for creating an answer and converting the answer back to a sequence of bytes. As opposed to the graphic we didn’t split this last component in two, since the logic is trivial. At the end, we connect all of the flows through the <code>via</code> function. At this point one may ask whether we took care of the multi-user property that was mentioned at the beginning. And indeed we did even though it may not be obvious immediately. By looking at this graphic it should get more clear:</p>
<img src="/img/akka/streaming/0a3Ey.png" alt="" style="width:460px;"/>
<p>The <code>serverLogic</code> component is nothing but a flow that contains smaller flows. This component takes an input, which is a request, and produces an output, which is the response. Since flows can be constructed multiple times and they all work independently to each other, we achieve through this nesting our multi-user property. Every request is handled within its own request and therefore a short running request can overrun a previously started long running request. In case you wondered, the definition of <code>serverLogic</code> that was shown previously can of course be written a lot shorter by inlining most of its inner definitions:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> serverLogic = <span class="type">Flow</span>[<span class="type">ByteString</span>]</span><br><span class="line">  .via(<span class="type">Framing</span>.delimiter(</span><br><span class="line">      <span class="type">ByteString</span>(<span class="string">&quot;\n&quot;</span>),</span><br><span class="line">      maximumFrameLength = <span class="number">256</span>,</span><br><span class="line">      allowTruncation = <span class="literal">true</span>))</span><br><span class="line">  .map(_.utf8String)</span><br><span class="line">  .map(msg =&gt; <span class="string">s&quot;Server hereby responds to message: <span class="subst">$msg</span>\n&quot;</span>)</span><br><span class="line">  .map(<span class="type">ByteString</span>(_))</span><br></pre></td></tr></table></figure>
<p>A test of the web server may look like this:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="comment"># Client</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;Hello World\nHow are you?&quot;</span> | netcat 127.0.0.1 6666</span></span><br><span class="line">Server hereby responds to message: Hello World</span><br><span class="line">Server hereby responds to message: How are you?</span><br></pre></td></tr></table></figure>
<p>In order for the above code example to function correctly, we first need to start the server, which is depicted by the <code>startServer</code> script:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="comment"># Server</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./startServer 127.0.0.1 6666</span></span><br><span class="line">[DEBUG] Server started, listening on: /127.0.0.1:6666</span><br><span class="line">[DEBUG] Incoming connection from: /127.0.0.1:37972</span><br><span class="line">[DEBUG] Server received: Hello World</span><br><span class="line">[DEBUG] Server received: How are you?</span><br></pre></td></tr></table></figure>
<p>The full code example of this simple TCP server can be found <a target="_blank" rel="noopener" href="https://gist.github.com/sschaef/bd5ee6273ddaa7b015af#file-simpletcpserver-scala">here</a>. We are not only able to write a server with Akka Streams but also the client. It may look like this:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> connection = <span class="type">Tcp</span>().outgoingConnection(address, port)</span><br><span class="line"><span class="keyword">val</span> flow = <span class="type">Flow</span>[<span class="type">ByteString</span>]</span><br><span class="line">  .via(<span class="type">Framing</span>.delimiter(</span><br><span class="line">      <span class="type">ByteString</span>(<span class="string">&quot;\n&quot;</span>),</span><br><span class="line">      maximumFrameLength = <span class="number">256</span>,</span><br><span class="line">      allowTruncation = <span class="literal">true</span>))</span><br><span class="line">  .map(_.utf8String)</span><br><span class="line">  .map(println)</span><br><span class="line">  .map(_ ⇒ <span class="type">StdIn</span>.readLine(<span class="string">&quot;&gt; &quot;</span>))</span><br><span class="line">  .map(_+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">  .map(<span class="type">ByteString</span>(_))</span><br><span class="line"></span><br><span class="line">connection.join(flow).run()</span><br></pre></td></tr></table></figure>
<p>The full code TCP client can be found <a target="_blank" rel="noopener" href="https://gist.github.com/sschaef/6b2661a0df512eb321e9">here</a>. The code looks quite similar but in contrast to the server we don’t have to manage the incoming connections anymore.</p>
<h2 id="Complex-Graphs"><a class="header-anchor" href="#Complex-Graphs">¶</a>Complex Graphs</h2>
<p>In the previous sections we have seen how we can construct simple programs out of flows. However, in reality it is often not enough to just rely on already built-in functions to construct more complex streams. If we want to be able to use Akka Streams for arbitrary programs we need to know how to build our own custom control structures and combinable flows that allow us to tackle the complexity of our applications. The good news is that Akka Streams was designed to scale with the needs of the users and in order to give you a short introduction into the more complex parts of Akka Streams, we add some more features to our client/server example.</p>
<p>One thing we can’t do yet is closing a connection. At this point it starts to get a little bit more complicated because the stream API we have seen so far doesn’t allow us to stop a stream at an arbitrary point. However, there is the <code>GraphStage</code> abstraction, which can be used to create arbitrary graph processing stages with any number of input or output ports. Let’s first have a look at the server side, where we introduce a new component, called <code>closeConnection</code>:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> closeConnection = <span class="keyword">new</span> <span class="type">GraphStage</span>[<span class="type">FlowShape</span>[<span class="type">String</span>, <span class="type">String</span>]] &#123;</span><br><span class="line">  <span class="keyword">val</span> in = <span class="type">Inlet</span>[<span class="type">String</span>](<span class="string">&quot;closeConnection.in&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> out = <span class="type">Outlet</span>[<span class="type">String</span>](<span class="string">&quot;closeConnection.out&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> shape = <span class="type">FlowShape</span>(in, out)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">createLogic</span></span>(inheritedAttributes: <span class="type">Attributes</span>) = <span class="keyword">new</span> <span class="type">GraphStageLogic</span>(shape) &#123;</span><br><span class="line">    setHandler(in, <span class="keyword">new</span> <span class="type">InHandler</span> &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onPush</span></span>() = grab(in) <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;q&quot;</span> ⇒</span><br><span class="line">          push(out, <span class="string">&quot;BYE&quot;</span>)</span><br><span class="line">          completeStage()</span><br><span class="line">        <span class="keyword">case</span> msg ⇒</span><br><span class="line">          push(out, <span class="string">s&quot;Server hereby responds to message: <span class="subst">$msg</span>\n&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    setHandler(out, <span class="keyword">new</span> <span class="type">OutHandler</span> &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onPull</span></span>() = pull(in)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This API looks a lot more cumbersome than the flow API. No wonder, we have to do a lot of imperative steps here. In exchange, we have more control over the behavior of our streams. In the above example, we only specify one input and one output port and make them available to the system by overriding the <code>shape</code> value. Furthermore we defined a so called <code>InHandler</code> and a <code>OutHandler</code>, which are in this order responsible for receiving and emitting elements. If you looked closely to the full click stream example you should recognize these components already. In the <code>InHandler</code> we grab an element and if it is a string with a single character <code>'q'</code>, we want to close the stream. In order to give the client a chance to find out that the stream will get closed soon, we emit the string <code>&quot;BYE&quot;</code> and then we immediately close the stage afterwards. The <code>closeConnection</code> component can be combined with a stream via the <code>via</code> method, which was introduced in the section about flows.</p>
<p>Beside from being able to close connections, it would also be nice if we could show a welcome message to a newly created connection. In order to do this we once again have to go a little bit further:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serverLogic</span></span></span><br><span class="line">    (conn: <span class="type">Tcp</span>.<span class="type">IncomingConnection</span>)</span><br><span class="line">    (<span class="keyword">implicit</span> system: <span class="type">ActorSystem</span>)</span><br><span class="line">    : <span class="type">Flow</span>[<span class="type">ByteString</span>, <span class="type">ByteString</span>, <span class="type">NotUsed</span>]</span><br><span class="line">    = <span class="type">Flow</span>.fromGraph(<span class="type">GraphDSL</span>.create() &#123; <span class="keyword">implicit</span> b ⇒</span><br><span class="line">  <span class="keyword">import</span> <span class="type">GraphDSL</span>.<span class="type">Implicits</span>._</span><br><span class="line">  <span class="keyword">val</span> welcome = <span class="type">Source</span>.single(<span class="type">ByteString</span>(<span class="string">s&quot;Welcome port <span class="subst">$&#123;conn.remoteAddress&#125;</span>!\n&quot;</span>))</span><br><span class="line">  <span class="keyword">val</span> logic = b.add(internalLogic)</span><br><span class="line">  <span class="keyword">val</span> concat = b.add(<span class="type">Concat</span>[<span class="type">ByteString</span>]())</span><br><span class="line">  welcome ~&gt; concat.in(<span class="number">0</span>)</span><br><span class="line">  logic.outlet ~&gt; concat.in(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="type">FlowShape</span>(logic.in, concat.out)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>The function <code>serverLogic</code> now takes the incoming connection as a parameter. Inside of its body we use a DSL that allows us to describe complex stream behavior. With <code>welcome</code> we create a stream that can only emit one element - the welcome message. logic is what was described as <code>serverLogic</code> in the previous section. The only notable difference is that we added <code>closeConnection</code> to it. Now actually comes the interesting part of the DSL. The <code>GraphDSL.create</code> function makes a builder <code>b</code> available, which is used to express the stream as a graph. With the <code>~&gt;</code> function it is possible to connect input and output ports with each other. The <code>Concat</code> component that is used in the example can concatenate elements and is here used to prepend the welcome message in front of the other elements that come out of <code>internalLogic</code>. In the last line, we only make the input port of the server logic and the output port of the concatenated stream available because all the other ports shall remain an implementation detail of the <code>serverLogic</code> component. For an in-depth introduction to the graph DSL of Akka Streams, visit the corresponding section in the <a target="_blank" rel="noopener" href="http://doc.akka.io/docs/akka/2.4.2-RC1/scala/stream/stream-graphs.html">official documentation</a>. The full code example of the complex TCP server and of a client that can communicate with it can be found <a target="_blank" rel="noopener" href="https://gist.github.com/sschaef/df6315c87140d1d5951e">here</a>. Whenever you open a new connection from the client you should see a welcoming message and by typing <code>&quot;q&quot;</code> on the client you should see a message that tells you that the connection has been canceled.</p>
<p>There are still some topics which weren’t covered by this answer. Especially materialization may scare one reader or another but I’m sure with the material that is covered here everyone should be able to go the next steps by themselves. As already said, the <a target="_blank" rel="noopener" href="http://doc.akka.io/docs/akka/2.4.2-RC1/scala/stream/index.html">official documentation</a> is a good place to continue learning about Akka Streams.</p>
<h3 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h3>
<ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/35120082/how-to-get-started-with-akka-streams">https://stackoverflow.com/questions/35120082/how-to-get-started-with-akka-streams</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/reactive-streams/reactive-streams-jvm/tree/v1.0.0">https://github.com/reactive-streams/reactive-streams-jvm/tree/v1.0.0</a></li>
<li><a target="_blank" rel="noopener" href="http://doc.akka.io/docs/akka/2.5.1/scala/stream/stream-introduction.html#motivation">http://doc.akka.io/docs/akka/2.5.1/scala/stream/stream-introduction.html#motivation</a></li>
<li><a target="_blank" rel="noopener" href="http://doc.akka.io/docs/akka/2.5.1/general/stream/stream-design.html#stream-design">http://doc.akka.io/docs/akka/2.5.1/general/stream/stream-design.html#stream-design</a></li>
</ul>
</div></article><nav class="article-nav"><div class="article-nav-prev"><a href="/2017/05/26/akka/streaming/akka-streams-learning/">Akka Streaming学习</a></div><div class="article-nav-next"><a href="/2017/05/23/akka/future/future-and-execute/">Scala中的Future和ExecutionContext</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2017/05/24/akka/streaming/akka-reactive-streams/';
var disqus_title = 'Akka Reactive Streams';
var disqus_url = 'https://galudisu.info/2017/05/24/akka/streaming/akka-reactive-streams/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>