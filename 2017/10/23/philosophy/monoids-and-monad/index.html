<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>Monoids and Monads</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/maths/">Maths</a></li><li class="menu-item"><a class="menu-link" href="/projects/">Projects</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/maths/">Maths</a></li><li class="menu-item"><a class="menu-link" href="/projects/">Projects</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">Monoids and Monads</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2017-10-23</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/scala-fp/">scala, fp</a></p></div><div class="article-content"><blockquote>
<p>Haskell由于使用了Monad这种较费解的概念来控制副作用而遭到了一些批评意见。Wadler试图平息这些质疑，他解释说：“一个单子（Monad）说白了不过就是自函子范畴上的一个幺半群而已，这有什么难以理解的？”<br>
A monad is just a monoid in the category of endofunctors, what’s the problem?</p>
</blockquote>
<p>这一句话包含了好几个概念：单子(monad)，自函子(Endo-Functor)，幺半群(Monoid)，范畴(category)。</p>
<span id="more"></span>
<h2 id="Monoid"><a class="header-anchor" href="#Monoid">¶</a>Monoid</h2>
<p>函数式编程的Monoid形式定义为：</p>
<ul>
<li>给定的类型 <code>T</code></li>
<li>一个二元操作，<code>Op: (T,T) =&gt; T</code>	使得任意的 x, y, z ∈ T，满足 op(op(x,y), z) == op(x, op(y,z))</li>
<li>元单位 <code>Zero: T</code>					使得任意的 x ∈ T，满足 op(x, zero) == x and op(zero, x) == x</li>
</ul>
<p>满足以上关系的代数数据结构，存在一种普遍存在形式：</p>
<ol>
<li>若T为整数，则有 <code>(a+b)+c == a+(b+c)</code>、<code>0+n == n+0 == n</code>; <code>(a*b)*c == a*(b*c)</code>、<code>1*n == n*1 == n</code></li>
<li>若T为字符串，则有 <code>a+(b+c)==(a+b)+c; &quot;&quot;+s==s</code>、<code>s+&quot;&quot; == s</code></li>
<li>若T为数组，则有 <code>List(1,2)+List(3,4) == List(1,2,3,4)</code></li>
<li>若T为集合，则有 <code>Set(1,2,3)+Set(2,4) == Set(1,2,3,4)</code></li>
</ol>
<p>可以看出，整数时明显满足了 “加法交换律和乘法分配律，包含一个单位元<code>e</code>”，它实际上是一个线性空间。尽管其它数据类型没有特别明显，我们要构造相应的定义关系，在其映射关系上构造一个幺半群(Monoid)。</p>
<p>一个群的定义为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）封闭性（Closure）：对于任意a，b∈G，有a*b∈G</span><br><span class="line">（2）结合律（Associativity）：对于任意a，b，c∈G，有（a*b）*c=a*（b*c）</span><br><span class="line">（3）幺元 （Identity）：存在幺元e，使得对于任意a∈G，e*a=a*e=a</span><br><span class="line">（4）逆元：对于任意a∈G，存在逆元a^-1，使得a^-1*a=a*a^-1=e</span><br></pre></td></tr></table></figure>
<p>则称 (G, *) 是群，简称G是群。</p>
<p>如果仅满足封闭性和结合律，则称G是一个半群（Semigroup）；如果仅满足封闭性、结合律并且有幺元，则称G是一个含幺半群（Monoid）。</p>
<p>所以一个半群(semigroup)的定义是：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">SemiGroup</span>[<span class="type">T</span>] </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">T</span>, a2: <span class="type">T</span>): <span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包含单位元或幺元的半群，为幺半群(monoid)：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monoid</span>[<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="comment">// 二元操作</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">T</span>, a2: <span class="type">T</span>): <span class="type">T</span></span><br><span class="line">  <span class="comment">// 单位元</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero</span></span>: <span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monoid</span>[<span class="type">T</span>] <span class="keyword">extends</span> <span class="title">SemiGroup</span>[<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero</span></span>: <span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照语义，属于群的任意集合要满足定义关系，所以任意集合的形式为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">IntMonoid</span> <span class="keyword">extends</span> <span class="title">Monoid</span>[<span class="type">Int</span>] </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">Int</span>, a2: <span class="type">Int</span>) = a1 + a2</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zero</span> </span>= <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stringMonoid = <span class="keyword">new</span> <span class="type">Monoid</span>[<span class="type">String</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">String</span>, a2: <span class="type">String</span>) = a1 + a2</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">zero</span> </span>= <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listMonoid</span></span>[<span class="type">A</span>] = <span class="keyword">new</span> <span class="type">Monoid</span>[<span class="type">List</span>[<span class="type">A</span>]] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">List</span>[<span class="type">A</span>], a2: <span class="type">List</span>[<span class="type">A</span>]) = a1 ++ a2</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">zero</span> </span>= <span class="type">Nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这种定义在函数式编程中有什么作用？函数的抽象性在于，我们可以抽象一种类型，实现高阶函数。幺半群(Monoid)的抽象实际是一个域(Domain)，对应Scala的类型系统(type class)。我们用一个例子来说明Monoid这种类型类带来的函数式编程魅力。</p>
<p>Monoid带来两个重要法则：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">associativeLaw</span></span>[<span class="type">A</span>](x: <span class="type">A</span>, y: <span class="type">A</span>, z: <span class="type">A</span>)(<span class="keyword">implicit</span> m: <span class="type">Monoid</span>[<span class="type">A</span>]): <span class="type">Boolean</span> = m.op(x, m.op(y, z)) == m.op(m.op(x, y), z)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">identityLaw</span></span>[<span class="type">A</span>](x: <span class="type">A</span>)(<span class="keyword">implicit</span> m: <span class="type">Monoid</span>[<span class="type">A</span>]): <span class="type">Boolean</span> = &#123;</span><br><span class="line">  (m.op(x, m.zero) == x) &amp;&amp;</span><br><span class="line">	(m.op(m.zero, x) == x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monoid</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(a1: <span class="type">A</span>, a2: <span class="type">A</span>): <span class="type">A</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero</span></span>: <span class="type">A</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> intMonoid = <span class="keyword">new</span> <span class="type">Monoid</span>[<span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>):<span class="type">Int</span> = a + b</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero</span> </span>= <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>[<span class="type">A</span>](ts: <span class="type">List</span>[<span class="type">A</span>])(<span class="keyword">implicit</span> m: <span class="type">Monoid</span>[<span class="type">A</span>]): <span class="type">A</span> = ts.foldLeft(m.zero)(m.f)</span><br></pre></td></tr></table></figure>
<h2 id="范畴"><a class="header-anchor" href="#范畴">¶</a>范畴</h2>
<p>范畴由三部分组成：</p>
<blockquote>
<p>（1）一组对象<br>
（2）一组态射（morphisms）。每个态射会绑定两个对象，假如f是从源对象A到目标对象B的态射，记作：<code>f：A -&gt; B</code><br>
（3）态射组合。假如h是态射f和g的组合，记作：<code>h = g o f</code></p>
</blockquote>
<p>下图展示了一个简单的范畴，该范畴由对象 <code>A</code>, <code>B</code> 和 <code>C</code> 组成，有三个单位态射 <code>id_A</code>, <code>id_B</code> 和 <code>id_C</code> ，还有另外两个态射 <code>f : C =&gt; B</code> 和 <code>g : A =&gt; B </code></p>
<p><img src="/img/philosophy/fcp/category.png" alt="Simple-cat"></p>
<p>态射我们可以简单的理解为函数，假如在某范畴中存在一个态射，它可以把范畴中一个Int对象转化为String对象。在Scala中我们可以这样定义这个态射：<code>f : Int =&gt; String = ...</code>。所以态射的组合也就是函数的组合，见代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> f1: <span class="type">Int</span> =&gt; <span class="type">Int</span> = i =&gt; i + <span class="number">1</span></span><br><span class="line">f1: <span class="type">Int</span> =&gt; <span class="type">Int</span> = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> f2: <span class="type">Int</span> =&gt; <span class="type">Int</span> = i =&gt; i + <span class="number">2</span></span><br><span class="line">f2: <span class="type">Int</span> =&gt; <span class="type">Int</span> = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> f3 = f1 compose f2</span><br><span class="line">f3: <span class="type">Int</span> =&gt; <span class="type">Int</span> = &lt;function1&gt;</span><br></pre></td></tr></table></figure>
<h4 id="范畴公理"><a class="header-anchor" href="#范畴公理">¶</a>范畴公理</h4>
<p>范畴需要满足以下三个公理。</p>
<blockquote>
<p>（1）态射的组合操作要满足结合律。记作：<code>f o (g o h) = (f o g) o h</code><br>
（2）对任何一个范畴 C，其中任何一个对象A一定存在一个单位态射，<code>id_A: A =&gt; A</code>。并且对于态射<code>g：A =&gt; B</code> 有 <code>id_B o g = g = g o id_A</code>。<br>
（3）态射在组合操作下是闭合的。所以如果存在态射<code>f: A =&gt; B</code> 和<code>g: B =&gt; C</code>，那么范畴中必定存在态射 <code>h: A =&gt; C</code> 使得 <code>h = g o f</code>。</p>
</blockquote>
<p><img src="/img/philosophy/fcp/composition-ex.png" alt="Composition-ex"></p>
<p><code>f</code> 和 <code>g</code> 都是态射，所以我们一定能够对它们进行组合并得到范畴中的另一个态射。那么哪一个是态射 <code>f o g</code> 呢？唯一的选择就是 <code>id_A</code> 了。类似地，<code>g o f=id_B</code> 。</p>
<h2 id="函子-Functor"><a class="header-anchor" href="#函子-Functor">¶</a>函子(Functor)</h2>
<h4 id="函子定义"><a class="header-anchor" href="#函子定义">¶</a>函子定义</h4>
<p>函子有一种能力，把两个范畴关联在一起。函子本质上是范畴之间的转换。比如对于范畴 C 和 D ，函子<code>F : C =&gt; D</code> 能够：将 C 中任意对象a 转换为 D 中的 F(A); 将 C 中的态射<code>f : A =&gt; B</code> 转换为 D 中的 <code>F(f) : F(A) =&gt; F(B)</code></p>
<p>下图表示从范畴C到范畴D的函子。图中的文字描述了对象 A 和 B 被转换到了范畴 D 中同一个对象，因此，态射 g 就被转换成了一个源对象和目标对象相同的态射（不一定是单位态射），而且 id_A 和 id_B 变成了相同的态射。对象之间的转换是用浅黄色的虚线箭头表示，态射之间的转换是用蓝紫色的箭头表示。</p>
<p><img src="/img/philosophy/fcp/Functor.png" alt="Functor"></p>
<h4 id="单位函子"><a class="header-anchor" href="#单位函子">¶</a>单位函子</h4>
<p>每一个范畴C都可以定义一个单位函子：<code>Id： C =&gt; C</code>。它将对象和态射直接转换成它们自己：<code>Id[A] = A; f: A =&gt; B, Id[f] = f</code>。</p>
<h4 id="函子公理"><a class="header-anchor" href="#函子公理">¶</a>函子公理</h4>
<blockquote>
<p>（1）给定一个对象 A 上的单位态射Id_A ， F(Id_A) 必须也是 F(A) 上的单位态射，也就是说：<code>F(Id_A) = Id_(F(A))</code><br>
（2）函子在态射组合上必须满足分配律，也就是说：<code>F(f o g) = F(f) o F(g)</code></p>
</blockquote>
<p>一个函子<code>Functor</code>表示范畴A到范畴B之间的映射。函子和函数都表示一种映射关系，但是针对的类型不同。</p>
<ol>
<li>函数表达的映射关系在类型上体现在**特定类型(proper type)**上。</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Int =&gt; String</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(i:<span class="type">Int</span>): <span class="type">String</span> = i.toString</span><br><span class="line"></span><br><span class="line"><span class="comment">// List[Int] =&gt; List[String]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span></span>(l:<span class="type">List</span>[<span class="type">Int</span>]): <span class="type">List</span>[<span class="type">String</span>] = l.map(_.toString)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>函子表达的映射关系，则体现在**高阶函数(high-order function)**上(确切来说是范畴)。</li>
</ol>
<p>怎么用代码来描述函子？根据定义，它包含两个层面的映射关系：</p>
<blockquote>
<ol>
<li>将C1中的类型 T 映射为 C2 中的 <code>List[T] :  T =&gt; List[T]</code></li>
<li>将C1中的函数 f 映射为 C2 中的 函数<code>fm :  (A =&gt; B) =&gt; (List[A] =&gt; List[B])</code></li>
</ol>
</blockquote>
<p>我们定义一个类型构造器</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Functor</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">typeMap</span></span>[<span class="type">A</span>]: <span class="type">F</span>[<span class="type">A</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">funcMap</span></span>[<span class="type">A</span>,<span class="type">B</span>](f: <span class="type">A</span>=&gt;<span class="type">B</span>): <span class="type">F</span>[<span class="type">A</span>]=&gt;<span class="type">F</span>[<span class="type">B</span>] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把这项定义再简化</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Functor</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](a: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">F</span>[<span class="type">B</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//list Functor的实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listFunctor</span> </span>= <span class="keyword">new</span> <span class="type">Functor</span>[<span class="type">List</span>] &#123;</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](a: <span class="type">List</span>[<span class="type">A</span>])(f: (<span class="type">A</span>) =&gt; <span class="type">B</span>) = a.map(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用归纳证明的方法来阐述<code>Functor[F[_]]</code>是否满足定义关系。<code>f: A =&gt; B</code> 是一个态射，它构成了<code>A=&gt;B =&gt; F[A] =&gt; F[B]</code> 的一个映射关系。<code>map[Int, Int](List(1, 2, 3))(_ + 1)</code>，对于map 它的入参是<code>List(1,2,3)</code>，执行过程中被映射该函数 <code>_: Int + 1</code>，得到结果 List(2,3,4)。对于List范畴来说，这个过程就是：<code>List[Int] =&gt; List[Int]</code>。它就是Int 到 List 范畴的函子，即 <code>Int =&gt; Int =&gt; List[Int] =&gt; List[Int]</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">范畴Int				范畴List[_]</span><br><span class="line">+------------+            +----------------+</span><br><span class="line">|            |            |                |</span><br><span class="line">|    Int     |    map     |   List[Int]    |</span><br><span class="line">|     ↓      |   =====&gt;   |       ↓        |</span><br><span class="line">|    Int     |   f:A=&gt;B   |   List[Int]    |</span><br><span class="line">|            |            |                |</span><br><span class="line">+------------+            +----------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在haskell里把这两个行为叫做提升(lift)，相当于把类型和函数放到容器里。</p>
<h2 id="自函子-Endofunctor"><a class="header-anchor" href="#自函子-Endofunctor">¶</a>自函子(Endofunctor)</h2>
<p>自函子是一类比较特殊的函子，它是一种将范畴映射到自身的函子 (A functor that maps a category to itself)。例如Int =&gt; Int, String =&gt; String等。</p>
<p>自函子的映射结果是自身，因此，对于自函子F，<code>F[Int]</code> 的结果是 <code>Int</code>，<code>F[Int =&gt; String]</code> 的结果仍是 <code>Int =&gt; String</code></p>
<h2 id="Monad"><a class="header-anchor" href="#Monad">¶</a>Monad</h2>
<p>那么回过头来看看定义，<strong>“一个单子（Monad）说白了不过就是自函子范畴上的一个幺半群而已，有什么难以理解的。”</strong></p>
<p>首先，自函子是长这样的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Functor</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](a: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">F</span>[<span class="type">B</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>幺半群是长这样的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monoid</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(a1: <span class="type">A</span>, a2: <span class="type">A</span>): <span class="type">A</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero</span></span>: <span class="type">A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自函子上的幺半群是啥？首先它是一个自函子，所以它应该包含类型<code>[M[_]]</code>，自函子满足 <code>A =&gt; B → M[A] =&gt; M[B]</code> 的关系，所以它包含有：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](value: <span class="type">F</span>[<span class="type">A</span>])(func: <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">B</span>]): <span class="type">F</span>[<span class="type">B</span>]</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好像还漏点什么？幺元(单位元)！补全之后，</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](value: <span class="type">F</span>[<span class="type">A</span>])(func: <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">B</span>]): <span class="type">F</span>[<span class="type">B</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>): <span class="type">F</span>[<span class="type">A</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Monad的确切定义为：</p>
<blockquote>
<p>Monad是一个函子：M: C -&gt; C，并且对C中的每一个对象x以下两个态射：</p>
<ol>
<li><code>unit: x -&gt; M[x]</code></li>
<li><code>join/bind: M[M[x]] -&gt; M[x]</code></li>
</ol>
</blockquote>
<p>第一个态射比较容易理解，它就是子函数的幺元；第二个就是我们描述的自函子！按照定义实现的Monad：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[<span class="type">M</span>[_]] </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>): <span class="type">M</span>[<span class="type">A</span>]   <span class="comment">//identity</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>[<span class="type">A</span>](mma: <span class="type">M</span>[<span class="type">M</span>[<span class="type">A</span>]]): <span class="type">M</span>[<span class="type">A</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它实际上和第一种Monad定义是等价的！！不过它还有更多的推导形式…</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">join</span></span>[<span class="type">A</span>](mma: <span class="type">M</span>[<span class="type">M</span>[<span class="type">A</span>]]): <span class="type">M</span>[<span class="type">A</span>] = flatMap(mma)(ma =&gt; ma)</span><br></pre></td></tr></table></figure>
<p>例子：我们实现下图的一个装箱操作：</p>
<p><img src="/img/philosophy/fcp/Monad.png" alt="Monad"></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](value: <span class="type">F</span>[<span class="type">A</span>])(func: <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">B</span>]): <span class="type">F</span>[<span class="type">B</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>): <span class="type">F</span>[<span class="type">A</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Monad在类库中总是和<code>implicity</code>一起使用，我们不做这么复杂，假设自函子范畴是<code>List</code>，实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="type">ListMonad</span> = <span class="keyword">new</span> <span class="type">Monad</span>[<span class="type">List</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](value: <span class="type">List</span>[<span class="type">A</span>])(func: <span class="type">A</span> =&gt; <span class="type">List</span>[<span class="type">B</span>]): <span class="type">List</span>[<span class="type">B</span>] = &#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">fun</span></span>: (<span class="type">List</span>[<span class="type">A</span>]) =&gt; <span class="type">List</span>[<span class="type">B</span>] = &#123;</span><br><span class="line">	  <span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="type">Nil</span></span><br><span class="line">	  <span class="keyword">case</span> x :: xs =&gt; func(x) ::: fun(xs)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fun(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>) = <span class="type">List</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对该幺半群做自函子的映射，即每个元素加3</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger info <span class="string">s&quot;<span class="subst">$&#123;ListMonad.flatMap(List(1, 2, 3))(x =&gt; x + 3 :: Nil) &#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>一点改进：尾递归实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listMonad = <span class="keyword">new</span> <span class="type">Monad</span>[<span class="type">List</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](value: <span class="type">List</span>[<span class="type">A</span>])(func: <span class="type">A</span> =&gt; <span class="type">List</span>[<span class="type">B</span>]): <span class="type">List</span>[<span class="type">B</span>] = &#123;</span><br><span class="line">	<span class="meta">@tailrec</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">fun</span></span>(a: <span class="type">List</span>[<span class="type">A</span>], b: <span class="type">List</span>[<span class="type">B</span>]): <span class="type">List</span>[<span class="type">B</span>] = a <span class="keyword">match</span> &#123;</span><br><span class="line">	  <span class="keyword">case</span> <span class="type">Nil</span> =&gt; b</span><br><span class="line">	  <span class="keyword">case</span> x :: xs =&gt; fun(xs, b ::: func(x))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fun(value, <span class="type">Nil</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>) = <span class="type">List</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得益于范畴论的推理总是辣么的多，Monad有几个常见的推导：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](v: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">B</span>]): <span class="type">F</span>[<span class="type">B</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>): <span class="type">F</span>[<span class="type">A</span>]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">compose</span></span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>](f: <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">B</span>], g: <span class="type">B</span> =&gt; <span class="type">F</span>[<span class="type">C</span>]): <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">C</span>] = a =&gt; flatMap(f(a))(g)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>[<span class="type">A</span>, <span class="type">B</span>](mma: <span class="type">F</span>[<span class="type">F</span>[<span class="type">A</span>]]): <span class="type">F</span>[<span class="type">A</span>] = flatMap(mma)(ma =&gt; ma)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>,<span class="type">B</span>](ma: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">F</span>[<span class="type">B</span>] = flatMap(ma)(a =&gt; unit(f(a)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1">《Advanced Scala with Cats》, underscore.<a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2">Scala和范畴论, <a target="_blank" rel="noopener" href="http://www.jianshu.com/p/31377066bf97">http://www.jianshu.com/p/31377066bf97</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem">http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem</a><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div></div></article><nav class="article-nav"><div class="article-nav-prev"><a href="/2017/11/06/philosophy/cap-theorem/">CAP理论</a></div><div class="article-nav-next"><a href="/2017/10/09/pattern/magent/scala-method-overloading-and-default-argument-values/">Scala Method Overloading and Default Argument Values</a></div></nav><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2017/10/23/philosophy/monoids-and-monad/';
var disqus_title = 'Monoids and Monads';
var disqus_url = 'https://galudisu.info/2017/10/23/philosophy/monoids-and-monad/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>