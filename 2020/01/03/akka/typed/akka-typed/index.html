<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>Akka Typed 协议和行为</title>
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="/css/vendors/rabbit-lyrics.css">
<link rel="shortcut icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="简单易懂の现代魔法" type="application/atom+xml">
</head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a class="menu-link" href="/">简单易懂の现代魔法</a></li><li class="menu-item"><a class="menu-link" href="/archives/">Archives</a></li><li class="menu-item"><a class="menu-link" target="_blank" rel="noopener" href="http://weibo.com/u/2360401155">Weibo</a></li><li class="menu-item"><a class="menu-link" href="/about">About</a></li><li class="menu-item"><a class="menu-link" href="/atom.xml">Rss</a></li></ul></nav><div class="toggle-menu" id="mobile-menu-toggle"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">Akka Typed 协议和行为</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title"></span><i class="icon-calendar"> </i>2020-01-03</p><p class="meta-item meta-tag"><span class="meta-item-title"></span><i class="icon-tag"> </i><a class="tag-link" href="/tags/akka-typed/">akka-typed</a></p><p class="meta-item meta-category"><span class="meta-item-title"></span><i class="icon-bookmark"> </i><a class="category-link" href="/categories/akka/">akka</a></p></div><div class="article-content"><p>2019年11月6号LightBend公司发布了AKKA 2.6版本，带来了类型安全的actor，新的Akka Cluster底层通信设施——Artery，带来了更好的稳定性，使用Jackson进行消息序列化，支持SLF4J日志接口。</p>
<h2 id="Why-Akka-Typed"><a class="header-anchor" href="#Why-Akka-Typed">¶</a>Why Akka Typed</h2>
<p>actor编程模型是一个强有力的抽象模型，尤其擅长解决真实世界建模，容错、并发、分布式系统问题。actor抽象编程模型构建于在互相独立的actor之间发送消息的基础之上，actor可以创建子actor，并负责监管，当子actor出现错误的时候可以重启或者重新创建，这套容错机制给整个actor系统带来了自愈能力。</p>
<p>经典的Akka actor API非常简单，就是提供一组处理和接收消息的函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the Actor trait (AbstractActor class in Java) is the entry point for using the API</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderProcessor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// receive方法处理消息</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> order @ <span class="type">OrderProcessor</span>.<span class="type">ProcessOrder</span> =&gt;</span><br><span class="line">	  <span class="comment">// actor方法繁衍新的actor</span></span><br><span class="line">	  <span class="keyword">val</span> connection = context.actorOf(</span><br><span class="line">	    <span class="type">BankConnection</span>.props(order.bankIndentifier)</span><br><span class="line">	  )</span><br><span class="line">	  <span class="comment">// !方法表示即发即弃</span></span><br><span class="line">	  connection ! <span class="type">BankConnection</span>.<span class="type">ExecuteOrder</span>(order)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种编程模型和API在多线程环境中具有显著的优势，每个actor顺序处理接收到的消息，actor的内部状态也只有它本身可以修改，这比并发的修改共享状态容易多了。</p>
<p>天下没有免费的午餐，actor编程模型也有它的缺点，槽点在这篇文章中有提到：<a target="_blank" rel="noopener" href="https://manuel.bernhardt.io/2017/05/29/akka-anti-patterns-overview/">Akka anti-patterns series</a></p>
<p>这些年来我在一些稍微大一些的Akka工程中见到的最大的问题是actor系统随着业务越做越大，并且非常难以扩展。根本原因是这套Akka API没有强制用户采用“协议优先”的规范。实际上Akka官方教程里最先讲述的就是清晰的定义组件之间的通信协议（也就是消息），并使用全路径访问消息。已上面的例子来说，OrderProcessor的通信协议定义如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伴生对象存放了消息的定义</span></span><br><span class="line"><span class="comment">// 对于集群或持久化系统，消息定义需要使用合适的序列化机制，譬如protobuf</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">OrderProcessor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Command</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessOrder</span>(<span class="params">bank: <span class="type">BankId</span>, fromAccount: <span class="type">AccountId</span>, toAccount: <span class="type">AccountId</span>, amount: <span class="type">Amount</span></span>) <span class="keyword">extends</span> <span class="title">Command</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即便你遵照Akka最佳实践，但还是无法保证给actor发送一些它不支持消息，actor的receive方法会接受任意类型的消息，当它收到不支持的消息时，便自动转给unhandled方法，此方法默认只会打日志记录一下（需要正确的配置日志打印机制），这对新人来说太坑了，你找不到任何错误，但是系统就是无法正常工作。</p>
<p>更深层次的原因在于缺少一种机制来帮助我们维护actor之间的通信协议。随着消息类型增多，很容易忘记这些actor都支持什么类型的消息。通过单元测试和严格的日志级别会有助于缓解这种问题（只要接受到不支持的消息就打warn日志），但是仍然无法完全避免。</p>
<p>Akka Typed就是为了解决这个问题，新的API是为“协议优先”设计的，在实现功能之前，你必须花一点时间想一想每一个actor要处理哪些消息。经典的Actor API的最佳实践也是如此，但却是可选的，你需要在实现的过程中使要处理消息条理清晰。</p>
<p>看过许多真实的Akka System分享之后，有一点必须强调一下：开发Akka Typed的目的不仅仅是为了以结构化的方式组织消息以及防止丢失那一点点actor不支持的消息，它的主要目的是引导我们优先考虑系统设计。设计一组恰到好处的actor，适当的通信粒度，正确的消息模式，这样就可以构建一个强大的系统，但是它的核心却非常简单，就像高考一样简单。但是我见到太多过度设计，大家倾向于设计过多的actor以及消息，引入了不必要的复杂度，最后尾大不掉。</p>
<h2 id="Let’s-build-a-payment-processor"><a class="header-anchor" href="#Let’s-build-a-payment-processor">¶</a>Let’s build a payment processor</h2>
<p>前面我们已经讲过使用Akka Typed可以非常容易的定义协议，但什么是“协议”呢？协议仅仅是“消息”吗？简单来说协议就是：定义一组消息，在两个及以上的组件之间按特定的顺序和组合传递。常见的协议有TCP、HTTPS等，而我们定义的是应用层的协议。你可以认为协议就是增强版的API：API只定义了个体之间的调用格式（参数、请求内容、响应内容等），协议描述了怎么通过组件之间的相互调用使系统到达期望的状态。</p>
<p>在Akka Typed API中，协议由一组消息class和对应类型的actor组成。下面的例子展示了从configuration组件获取配置数据的协议：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">ConfigurationMessage</span></span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">RetrieveConfiguration</span>(<span class="params">merchantId: <span class="type">MerchantId</span>, replyTo: <span class="type">ActorRef</span>[<span class="type">ConfigurationResponse</span>]</span>) <span class="keyword">extends</span> <span class="title">ConfigurationMessage</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">ConfigurationResponse</span></span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationFound</span>(<span class="params">merchantId: <span class="type">MerchantId</span>,  merchantConfiguration: <span class="type">MerchantConfiguration</span></span>) <span class="keyword">extends</span> <span class="title">ConfigurationResponse</span></span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationNotFound</span>(<span class="params">merchanId: <span class="type">MerchantId</span></span>) <span class="keyword">extends</span> <span class="title">ConfigurationResponse</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">MerchantId</span>(<span class="params">id: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">AnyVal</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">BankIdentifier</span>(<span class="params">id: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">AnyVal</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">MerchantConfiguration</span>(<span class="params">bankIdentifier: <span class="type">BankIdentifier</span></span>)</span></span><br></pre></td></tr></table></figure>
<p>这个例子遵循了请求-响应的消息设计模式，欲知更多详情，请参见本书：<a target="_blank" rel="noopener" href="https://www.manning.com/books/reactive-design-patterns">Reactive Design Patterns</a></p>
<p>如果你以前用过经典的Actor API，你会发现这里的实现方式有两个不同的地方，第一个是消息发送者的引用包含在消息的定义中，经典的Actor API是通过Akka提供的sender()方法来获取发送者的。第二个是消息class中包含的ActorRef是有类型的，发送者使用它的时候就可以清楚的知道应该发送什么类型的消息。我们使用接口ConfigurationResponse定义了配置数据的返回格式，它有两个实现类，这样发送者就可以发送两种格式的消息。</p>
<p>看了Actor的定义之后，就能理解为什么Akka Typed比经典的Actor更容易且更安全的解决协议问题，Configuration的定义如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Configuration</span>(<span class="params">context: <span class="type">ActorContext</span>[<span class="type">ConfigurationMessage</span>]</span>) <span class="keyword">extends</span> <span class="title">AbstractBehavior</span>[<span class="type">ConfigurationMessage</span>] </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义的actor继承<code>AbstractBehavior</code>，并带有指定的类型，它只能处理<code>ConfigurationMessage</code>类型的消息，编译器可以帮助我们检查消息的发送者发送的消息是否正确。</p>
<p>上面的例子中我们使用面向对象的编程方式定义了Actor，稍后我们会展示函数式编程风格。</p>
<h2 id="Implementing-our-first-typed-actor"><a class="header-anchor" href="#Implementing-our-first-typed-actor">¶</a>Implementing our first typed actor</h2>
<p><code>Configuration</code>提供查询功能：根据商户Id查询支付方式。我们继续使用面向对象的编程方式，如果使用过经典的Akka API，你对这种使用方式应该非常熟悉。</p>
<p>继承<code>AbstractBehavior</code>就必须实现<code>onMessage</code>方法，它返回一个<code>Behavior</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the AbstractBehavior trait is the entry point for using the object-oriented style API</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Configuration</span>(<span class="params">context: <span class="type">ActorContext</span>[<span class="type">ConfigurationMessage</span>]</span>) <span class="keyword">extends</span> <span class="title">AbstractBehavior</span>[<span class="type">ConfigurationMessage</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the mutable state here holds the configuration values of each merchant we know about</span></span><br><span class="line">  <span class="keyword">var</span> configurations: <span class="type">Map</span>[<span class="type">MerchantId</span>, <span class="type">MerchantConfiguration</span>] = <span class="type">Map</span>.empty</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the onMessage method defines the initial behavior applied to a message upon reception</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onMessage</span></span>(msg: <span class="type">ConfigurationMessage</span>): <span class="type">Behavior</span>[<span class="type">ConfigurationMessage</span>] = msg <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">RetrieveConfiguration</span>(merchantId, replyTo) =&gt;</span><br><span class="line">      configurations.get(merchantId) <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Some</span>(configuration) =&gt;</span><br><span class="line">          <span class="comment">// reply to the sender using the fire-and-forget paradigm</span></span><br><span class="line">          replyTo ! <span class="type">ConfigurationFound</span>(merchantId, configuration)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">          <span class="comment">// reply to the sender using the fire-and-forget paradigm</span></span><br><span class="line">          replyTo ! <span class="type">ConfigurationNotFound</span>(merchantId)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// lastly, return the Behavior to be applied to the next received message</span></span><br><span class="line">      <span class="comment">// in this case, that&#x27;s just the same Behavior as we already have</span></span><br><span class="line">      <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个actor与我们在本文开头使用经典的actor API定义的actor非常相似：覆盖onMessage方法，并根据指定的消息类型做出对应的响应。</p>
<p>不同点在于onMessage对应的方法返回的是一个Behavior，一个actor接收到消息之后的行为包含如下3个步骤：</p>
<p>发送一条或多条消息给其他的actor<br>
创建子acotr<br>
返回一个新的行为，准备接收下一个消息<br>
在Akka Typed API中，一个Behavior即代表了处理当前消息的行为，也表明了如何处理下一个消息——通过返回一个新的Behavior。也可以只是返回当前行为（就像上面的例子一样），因为使用面向对象风格的actor继承自AbstractBehavior，它本身就是一个Behavior，所以可以使用return this。</p>
<p>本系列教程后面会讨论更多关于Behavior的用法，使用Akka Typed API定义的actor的一个优点就是非常容易组合和测试。</p>
<p>Typed Akka TestKit可以帮助你轻而易举的对actor进行测试：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigurationSpec</span> <span class="keyword">extends</span> <span class="title">ScalaTestWithActorTestKit</span> <span class="keyword">with</span> <span class="title">WordSpecLike</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;The Configuration actor&quot;</span> should &#123;</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;not find a configuration for an unknown merchant&quot;</span> in &#123;</span><br><span class="line">      <span class="comment">// define a probe which allows it to easily send messages</span></span><br><span class="line">      <span class="keyword">val</span> probe = createTestProbe[<span class="type">ConfigurationResponse</span>]()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// spawn a new Configuration actor as child of the TestKit&#x27;s guardian actor</span></span><br><span class="line">      <span class="keyword">val</span> configurationActor = spawn(<span class="type">Configuration</span>())</span><br><span class="line"></span><br><span class="line">      <span class="comment">// send a message to the actor under test with the probe&#x27;s reference as sender</span></span><br><span class="line">      configurationActor ! <span class="type">Configuration</span>.<span class="type">RetrieveConfiguration</span>(<span class="type">MerchantId</span>(<span class="string">&quot;unknown&quot;</span>), probe.ref)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// expect a certain type of message as response. there are many different ways to retrieve</span></span><br><span class="line">      <span class="comment">// or to expect messages</span></span><br><span class="line">      <span class="keyword">val</span> response = probe.expectMessageType[<span class="type">Configuration</span>.<span class="type">ConfigurationNotFound</span>]</span><br><span class="line">      response.merchanId shouldBe <span class="type">MerchantId</span>(<span class="string">&quot;unknown&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Supervising-and-starting-the-actor"><a class="header-anchor" href="#Supervising-and-starting-the-actor">¶</a>Supervising and starting the actor</h2>
<p>actor System为actor提供运行环境、分配资源、基础设施。在这个系统中，每一个actor都有一个父actor，最顶层的actor叫做根节点（<code>root</code>)，使用<code>/</code>代表，它的两个直接子actor是<code>/user</code>和<code>/system</code>，<code>/user</code>用于在用户空间创建子actor，<code>/system</code>属于akka系统内部管理，所以我们创建的所有的actor都从属于<code>/user</code>。</p>
<p>Akka Typed与经典的Actor API有一个非常重要的不同点：<code>/user</code>的处理逻辑。在经典的Akka API中，Akka提供的<code>/useractor</code>负责监管一切；但是Akka Typed把这个权力交给了用户。也就是说应用程序的开发者在实现actor的时候同时也必须多考虑一下actor都会有哪些行为。</p>
<p>在创建<code>Configuration</code> actor的时候，我们大可以直接把它传给<code>ActorSystem</code>并把它作为监管者，但当创建更多actor的时候，这些actor全部都由<code>Configuration</code> actor监管就不合适了。而且在actor模型中父监管机制采用级联的方式处理actor失败的问题：父actor负责决定如何处理子actor（当它抛异常的时候），因此如何对actor分组直接影响了监管策略。同样的我们应该使用一个专用的父actor做为监管actor，由它来决定如何处理子actor的失败问题。Akka Typed API中默认的监管策略是停止失败的子actor（经典的Akka API是重启）。由我们指定监管actor可以开发更灵活的监管策略，根据不同的异常做出相应的决策。综上所述我们决定使用<code>PaymentProcessor</code> actor做为所有actor的监管者，actor层级如下图所示：</p>
<p>![/img/akka/typed/supervision.png]</p>
<p><code>PaymentProcessor</code>的功能目前非常简单，启动的时候创建一个子actor——Configuration，它是无状态的，也不接收任何消息，这次我们使用函数式编程的风格，无需继承任何接口，只需要返回一个Behavior：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PaymentProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>() = <span class="type">Behaviors</span>.setup[<span class="type">Nothing</span>] &#123; context =&gt;</span><br><span class="line">    context.log.info(<span class="string">&quot;Typed Payment Processor started&quot;</span>)</span><br><span class="line">    context.spawn(<span class="type">Configuration</span>(), <span class="string">&quot;config&quot;</span>)</span><br><span class="line">    <span class="type">Behaviors</span>.empty</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Behaviors.setup()</code>方法是创建<code>Behavior</code>的入口，该方法包含一个<code>ActorContext</code>变量，我们用它打日志，记录actor已经启动，并使用<code>spawn()</code>方法创建了一个<code>Configuration actor</code>，第一个参数用于创建actor，第二个参数是actor的名字，它在actor路径中是<code>/user/config</code>。</p>
<p>因为<code>PaymentProcessor</code>不处理任何消息，所以这里使用了<code>setup[Nothing]</code>。</p>
<p><code>Configuration</code> actor使用静态的create函数创建<code>Behavior</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">Behavior</span>[<span class="type">ConfigurationMessage</span>] = <span class="type">Behaviors</span>.setup(context =&gt; <span class="keyword">new</span> <span class="type">Configuration</span>(context))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在万事俱备，只欠东风，需要启动<code>ActorSystem</code>来创建我们的监管actor。Akka提供了静态方法用来创建监管actor：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">ActorSystem</span>[<span class="type">Nothing</span>](<span class="type">PaymentProcessor</span>(), <span class="string">&quot;typed-payment-processor&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搞定！现在运行<code>Main</code>方法，就可以看到<code>PaymentProcessor</code>启动了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[info] Running io.bernhardt.typedpayment.Main</span><br><span class="line">[INFO] [07/10/2019 09:36:42.483] [typed-payment-processor-akka.actor.default-dispatcher-5] [akka://typed-payment-processor/user] Typed Payment Processor started</span><br></pre></td></tr></table></figure>
</div></article><div id="base-discus"><div id="disqus_thread"></div><script>var disqus_shortname = 'barudisshu-github-io';
var disqus_identifier = '2020/01/03/akka/typed/akka-typed/';
var disqus_title = 'Akka Typed 协议和行为';
var disqus_url = 'https://galudisu.info/2020/01/03/akka/typed/akka-typed/';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async>  </script></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>©2016 - 2025 <a href="https://galudisu.info">barudisshu</a>, unless otherwise noted.</span></div></footer><div class="dom-ready">
<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/green/pace-theme-flash.min.css">

<script src="/js/base.js"></script>

<script src="/js/rabbit-lyrics.js"></script>
</div></body></html>